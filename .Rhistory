" adult populations for streams that were not trapped.  Then the stream estimates were added up to get lakewide estimates (Table 2, Figure 1).",
"  The precision of the lake-wide estimates depends on the size of the population (larger estimates tend to have wider confidence intervals),",
" the fit of the spawner model, and the precision of mark-recapture estimates.",
"  Because variability among annual estimates in part reflects the cyclic nature of lampricide treatments, changes in adult",
" estimates over the long term are best examined using running means (Figure 2).")
last.year <- alltots[alltots$year==YEAR-1, ]
this.year <- alltots[alltots$year==YEAR, ]
thyr <- round(this.year$PE)
layr <- round(last.year$PE)
hier <- this.year$lo > last.year$hi
loer <- this.year$hi < last.year$lo
phrase <- rep("not significantly different from", 5)
delta <- round(100*abs(this.year$PE - last.year$PE) / last.year$PE)
phrase[hier] <- paste0(delta[hier], "% higher than")
phrase[loer] <- paste0(delta[loer], "% lower than")
sentence <- vector("list", 5)
abta <- sum(TAB.targs$"Above Target?"=="***")
beta <- 5-abta
for(i in 1:5) {
sentence[[i]] <- paste(c("For Lake ", lakenames[i], ", the abundance in ", YEAR, " (", format(thyr[i], big.mark=","), ") was ", phrase[i], 
" the abundance in ", YEAR-1, " (", format(layr[i], big.mark=","), ")."), collapse="")
}
para("Comparing the 95% confidence intervals of the abundance estimates in ", YEAR, " with those in ", YEAR-1, 
", the number of adults significantly increased in ", numbers2words(sum(hier)), " lakes, significantly decreased in ", 
numbers2words(sum(loer)), " lakes, and stayed the same in ", numbers2words(5-sum(hier)-sum(loer)), " lakes.",
"  ", sentence[[1]], "  ", sentence[[2]], "  ", sentence[[3]], "  ", sentence[[4]], "  ", sentence[[5]],
"  Based on the ", YEAR, " point estimates (ignoring confidence intervals), ", numbers2words(abta), 
" lakes were above targets and ", numbers2words(beta), " were within targets (Table 3).")
para("More than half of the total number of adult sea lampreys across the Great Lakes basin in ", YEAR, 
" was attributed to ", numbers2words(dim(TAB.highest)[1]), " streams (Table 4, Figure 3).",
"  Of these streams, ", numbers2words(table(TAB.highest$Source)["m-r"]), " had estimates based on mark-recapture studies.",
"  The other ", numbers2words(dim(TAB.highest)[1] - table(TAB.highest$Source)["m-r"]), " streams had",
" trap efficiency or model estimates, because they were not trapped or we were not able to calculate a valid estimate.")
para(capwords(numbers2words(dim(TAB.twice)[1])), " streams had population estimates more than twice as large as those predicted by the model",
" (Table 5).  These extremes may indicate the presence of some unusual circumstances, e.g., trapping issues, model shortcomings,", 
" unusually high pheromone signal in the river, etc.")
head2("REFERENCES")
para("Mullett, K. M., J. W. Heinrich, J. V. Adams, R. J. Young, M. P. Henson, R. B. McDonald, and M. F. Fodale.",
"  2003.  Estimating lake-wide abundance of adult sea lampreys (Petromyzon marinus) in the Great Lakes:",
" extrapolating from sampled streams using regression models.  Journal of Great Lakes Research 29(Supplement 1):240-252.")
# 1
tabl("Summary of the fit of the spawner model to each lake, including residual standard error (RSE), model and error degrees of freedom (df),",
" F statistic for the model, P value, and coefficient of determination (R2).  P values are rounded to the nearest thousandth.",
"  So P values of 0 indicate that the P value was < 0.001.", 
TAB=apply(TAB.r2, 2, format), just=c("L", "R")[c(1, rep(2, 6))])
# 2
TAB.lakewide <- round(tapply(alltots$PE, list(alltots$year, alltots$lake), mean))
dimnames(TAB.lakewide)[[2]] <- lakenames
TAB.lakewide <- myformat(TAB.lakewide)
tabl("Lake-wide adult population estimates, 1977-", YEAR, ".", 
TAB=TAB.lakewide, just="R")
# 3
tabl("Lake-wide adult abundance estimates and targets with 95% confidence intervals.",
"  The judgement of whether a lake is above target is based on the point estimates alone, ignoring confidence intervals.",
TAB=TAB.targs, just=c("L", TAB.targs.just))
# 4
tabl("Streams with the highest numbers of adult sea lampreys estimated during ", YEAR, ", combining for half of the basin-wide total.",
"  Information includes source of estimate (m-r = mark-recapture, trap = trap efficiency, model = model prediction),",
" number trapped, population estimate (PE),",
" percent of basin-wide total (%), and cumulative percent of basin-wide total (Cum. %).", 
TAB=TAB.highest, row.names=FALSE, just=TAB.highest.just)
# 5
tabl("Streams with ", YEAR, " population estimates from mark and recapture studies that were more than twice as large as those",
" predicted by the model.  Information includes number of years since last treatment, model prediction, trap catch, population",
" estimate (PE), and source of population estimate (m-r = mark-recapture, trap = trap efficiency, model = model prediction).", 
TAB=TAB.twice, row.names=FALSE, just=TAB.twice.just)
# 1
figu("Lake-wide adult abundance estimates and targets with 95% confidence intervals for each Great Lake",
" and all lakes combined through ", YEAR, ".", 
FIG=FIG.lakeCI, newpage="port")#, w=6.5, h=7.5)
# 2
figu("Five-year running means of annual, lake-wide adult population estimates for each Great Lake and all lakes combined, 1980-", YEAR, ".",
FIG=FIG.running, newpage="port")#, w=6.5, h=7.5)
# 3
figu("Distribution of adult sea lampreys in the Great Lakes, ", YEAR, ".",
"  Circle size represents size of population estimate, circle color represent the source of the population estimate.",
"  Streams with the largest estimates, combining for more than half of the basin-wide total, are labeled and identified by thicker circles.",
FIG=FIG.bubble, newpage="land")
end.rtf()
cat(paste0("\n\n", YEAR, " Lake-Wide Adult Abundance Estimates and Targets with 95% Confidence Intervals\n\n"))
print(format(TAB.targs), row.names=TRUE)
cat(paste0("\n\n\nDon't forget to look at the ERRORS (", OUTERROR, "), and the FIRST DRAFT (", OUTDRAFT, "),",
" all in directory, ", DIRECTORY, ".\n\n\n"))
cleanup()
q()
# C:\JVA\Lamprey\Adults\SpawnDisModel\2014\Inputs v2014.r - inputs and source command to run Spawner Model (Mullett et al. 2013)
# spawner populations estimates generated dynamically every year (i.e., all estimates change every year)
# study years for selected Superior streams included in specified years
# mse + hat matrix is used for error propagation
#################################################################################################################
#########   Each year, the YEAR must be updated,                                                         ########
#########   Make changes as needed to the directory and input file names.                                ########
#################################################################################################################
#########                                       I N P U T S                                              ########
#################################################################################################################
YEAR        <- 2014
#DIRECTORY  <- "C:\\Documents and Settings\\jbarber\\My Documents\\Jessica Files\\Spawner Model Files\\2014 files"
#DIRECTORY   <- "C:\\Documents and Settings\\jbarber\\My Documents\\Jessica Files\\Spawner Model Files\\2014 files"
DIRECTORY   <- "C:\\JVA\\Lamprey\\Adults\\SpawnDisModel\\2014"
OLDDATA     <- "Trap&Schaefer 1977-2013.csv"
NEWDATA     <- "Trap&Schaefer 2014.csv"
TRAPPER     <- "Trapping Periods 2014.csv"
PROGRAM     <- "DynamicPECV ver2014-09-19.r"
FUNCTIONS   <- "Functions v2013.r"
LAKEMAP     <- "GreatLakes.dat"
#################################################################################################################
#########                                R U N   T H E   P R O G R A M                                   ########
#################################################################################################################
source(paste(DIRECTORY, FUNCTIONS, sep="\\"))
source(paste(DIRECTORY, PROGRAM, sep="\\"))
cleanup()
q()
??color
blindcolz
q()
blindcolz
plot(1:10, 1:10, cex=2, col="#1f78b4")
??yai
utils:::menuInstallPkgs()
utils:::menuInstallPkgs()
library(yaImpute)
library(randomForest)
yai
?yai
?AsciiGridImpute
data(iris)
y <- data.frame(Species=iris[refs,5],row.names=rownames(iris[refs,]))
refs=sample(rownames(iris),50)
y <- data.frame(Species=iris[refs,5],row.names=rownames(iris[refs,]))
dim(y)
y
head(y)
x=iris[refs,1:4]
head(x)
?randomForest
cleanup()
q()
??corr
search()
ls(5)
dat <- matrix(rnorm(1000), ncol=10)
corr(dat)
?cor.test
cor(dat)
colr
??col
?rain
??rain
?terrain
??terrain
length(seq(-1, 1, 0.1))
?cut
colr
rcat <- cut(r, breaks=seq(-1, 1, 0.01), labels=FALSE)
dat <- matrix(rnorm(1000), ncol=10)
r <- cor(dat)
rcat <- cut(r, breaks=seq(-1, 1, 0.01), labels=FALSE)
r
rcat
apply(r, 2, cut, breaks=seq(-1, 1, 0.01), labels=FALSE)
# categorize correlations from -1 to 1 by 0.01
brks <- seq(-1, 1, 0.01)
rcat <- apply(r, 2, cut, breaks=brks, labels=FALSE)
cm.colors(length(brks))
cm.colors(length(brks))[rcat]
apply(rcat, 2, function(x) cm.colors(length(brks))[x])
??ellipse
library(ellipse)
plotcorr
?ellipse
ellipse(r)
plot(ellipse(0.8), type = 'l')
lines(ellipse(0.6), col="red")
lines(ellipse(0.2), col="blue")
lines(ellipse(0), col="blue")
lines(ellipse(0.99), col="blue")
lines(ellipse(1), col="blue")
ellipse(1)
ellipse(0)
ellipse(c(0, 1))
apply(r, 2, lapply, ellipse)
els <- apply(r, 2, lapply, ellipse)
dim(els)
length(els)
lapply(r[, 1], ellipse)
els[[1]]
length(els[[1]])
n <- dim(r)[1]
plot(1:n, 1:n, type="n")
for(i in 1:n) {
for(j in 1:n) {
ell <- ellipse(r[i, j], center=c(i, j))
lines(ell)
}}
n <- dim(r)[1]
plot(1:n, 1:n, type="n")
for(i in 1:n) {
for(j in 1:n) {
ell <- ellipse(r[i, j], centre=c(i, j))
lines(ell)
}}
plot(1:n, 1:n, type="n")
for(i in 1:n) {
for(j in 1:n) {
ell <- ellipse(r[i, j], scale=c(1/n, 1/n), centre=c(i, j))
lines(ell)
}}
plot(1:n, 1:n, type="n")
for(i in 1:n) {
for(j in 1:n) {
zer <- ellipse(0, scale=c(2/n, 2/n), centre=c(i, j))
polygon(zer, col=colz[i, j])
ell <- ellipse(r[i, j], scale=c(2/n, 2/n), centre=c(i, j))
polygon(ell, col="white")
}}
# data
dat <- matrix(rnorm(1000), ncol=10)
# correlation matrix
r <- cor(dat)
# categorize correlations from -1 to 1 by 0.01
brks <- seq(-1, 1, 0.01)
rcat <- apply(r, 2, cut, breaks=brks, labels=FALSE)
# assign colors on the cyan-magenta scale
colz <- apply(rcat, 2, function(x) cm.colors(length(brks))[x])
n <- dim(r)[1]
plot(1:n, 1:n, type="n")
for(i in 1:n) {
for(j in 1:n) {
zer <- ellipse(0, scale=c(2/n, 2/n), centre=c(i, j))
polygon(zer, col=colz[i, j])
ell <- ellipse(r[i, j], scale=c(2/n, 2/n), centre=c(i, j))
polygon(ell, col="white")
}}
zer
?polygon
library(ellipse)
# data
dat <- matrix(rnorm(1000), ncol=10)
dat[, 3] <- 3*dat[, 5] + 2 + rnorm(100)
# correlation matrix
r <- cor(dat)
# categorize correlations from -1 to 1 by 0.01
brks <- seq(-1, 1, 0.01)
rcat <- apply(r, 2, cut, breaks=brks, labels=FALSE)
# assign colors on the cyan-magenta scale
colz <- apply(rcat, 2, function(x) cm.colors(length(brks))[x])
n <- dim(r)[1]
plot(1:n, 1:n, type="n")
for(i in 1:n) {
for(j in 1:n) {
zer <- ellipse(0, scale=c(2/n, 2/n), centre=c(i, j))
polygon(zer, col=colz[i, j], border=NA)
ell <- ellipse(r[i, j], scale=c(2/n, 2/n), centre=c(i, j))
polygon(ell, col="white", border=NA)
}}
par(xaxs="i", yaxs="i")
plot(1:n, 1:n, type="n", xlim=c(0, n+1), ylim=c(0, n+1))
for(i in 1:n) {
for(j in 1:n) {
zer <- ellipse(0, scale=c(2/n, 2/n), centre=c(i, j))
polygon(zer, col=colz[i, j], border=NA)
ell <- ellipse(r[i, j], scale=c(2/n, 2/n), centre=c(i, j))
polygon(ell, col="white", border=NA)
}}
summary(fit, correlation = TRUE)$correlation
# Plot the correlation matrix for the mtcars data full model fit 
data(mtcars)
fit <- lm(mpg ~ ., mtcars)
summary(fit, correlation = TRUE)$correlation
# Plot the correlation matrix for the mtcars data full model fit 
data(mtcars)
fit <- lm(mpg ~ ., mtcars)
r <- summary(fit, correlation = TRUE)$correlation
# categorize correlations from -1 to 1 by 0.01
brks <- seq(-1, 1, 0.01)
rcat <- apply(r, 2, cut, breaks=brks, labels=FALSE)
# assign colors on the cyan-magenta scale
colz <- apply(rcat, 2, function(x) cm.colors(length(brks))[x])
n <- dim(r)[1]
par(xaxs="i", yaxs="i")
plot(1:n, 1:n, type="n", xlim=c(0, n+1), ylim=c(0, n+1))
for(i in 1:n) {
for(j in 1:n) {
zer <- ellipse(0, scale=c(2/n, 2/n), centre=c(i, j))
polygon(zer, col=colz[i, j], border=NA)
ell <- ellipse(r[i, j], scale=c(2/n, 2/n), centre=c(i, j))
polygon(ell, col="white", border=NA)
}}
r
r[4, 4]
library(ellipse)
# data
dat <- matrix(rnorm(1000), ncol=10)
dat[, 3] <- 3*dat[, 5] + 2 + rnorm(100)
# correlation matrix
r <- cor(dat)
# Plot the correlation matrix for the mtcars data full model fit 
data(mtcars)
fit <- lm(mpg ~ ., mtcars)
r <- summary(fit, correlation = TRUE)$correlation
# round to the nearest hundredth
rr <- round(r, 2)
# categorize correlations from -1 to 1 by 0.01
brks <- seq(-1, 1, 0.01)
rcat <- apply(rr, 2, cut, breaks=brks, labels=FALSE)
# assign colors on the cyan-magenta scale
colz <- apply(rcat, 2, function(x) cm.colors(length(brks))[x])
n <- dim(rr)[1]
windows()
par(xaxs="i", yaxs="i")
plot(1:n, 1:n, type="n", xlim=c(0, n+1), ylim=c(0, n+1))
for(i in 1:n) {
for(j in 1:n) {
zer <- ellipse(0, scale=c(2/n, 2/n), centre=c(i, j))
polygon(zer, col=colz[i, j], border=NA)
ell <- ellipse(rr[i, j], scale=c(2/n, 2/n), centre=c(i, j))
polygon(ell, col="white", border=NA)
}}
windows()
plotcorr(rr)
n <- dim(rr)[1]
windows()
par(xaxs="i", yaxs="i", pty="s")
plot(1:n, 1:n, type="n", xlim=c(0, n+1), ylim=c(0, n+1))
for(i in 1:n) {
for(j in 1:n) {
zer <- ellipse(0, scale=c(2/n, 2/n), centre=c(i, j))
polygon(zer, col=colz[i, j], border=NA)
ell <- ellipse(rr[i, j], scale=c(2/n, 2/n), centre=c(i, j))
polygon(ell, col="white", border=NA)
}}
??seriate
library(seriation)
n <- dim(rr)[1]
windows()
par(xaxs="i", yaxs="i", pty="s")
plot(1:n, 1:n, type="n", xlim=c(0, n+1), ylim=c(0, n+1))
for(i in 1:n) {
for(j in 1:n) {
zer <- ellipse(0, scale=c(2/n, 2/n), centre=c(i, j))
polygon(zer, col=colz[i, j], border=NA)
ell <- ellipse(rr[i, j], scale=c(2/n, 2/n), centre=c(i, j))
polygon(ell, col="white", border=NA)
text(i, j, rr)
}}
rrf <- format(rr)
rrf
par(xaxs="i", yaxs="i", pty="s")
plot(1:n, 1:n, type="n", xlim=c(0, n+1), ylim=c(0, n+1))
for(i in 1:n) {
for(j in 1:n) {
zer <- ellipse(0, scale=c(2/n, 2/n), centre=c(i, j))
polygon(zer, col=colz[i, j], border=NA)
ell <- ellipse(rr[i, j], scale=c(2/n, 2/n), centre=c(i, j))
polygon(ell, col="white", border=NA)
text(i, j, rrf[i, j])
}}
par(xaxs="i", yaxs="i", pty="s")
plot(1:n, 1:n, type="n", xlim=c(0, n+1), ylim=c(0, n+1))
for(i in 1:n) {
for(j in 1:n) {
zer <- ellipse(0, scale=c(2/n, 2/n), centre=c(i, j))
polygon(zer, col=colz[i, j], border=NA)
ell <- ellipse(rr[i, j], scale=c(2/n, 2/n), centre=c(i, j))
polygon(ell, col="white", border=NA)
text(i, j, rrf[i, j], cex=2/n)
}}
par(xaxs="i", yaxs="i", pty="s")
plot(1:n, 1:n, type="n", xlim=c(0, n+1), ylim=c(0, n+1))
for(i in 1:n) {
for(j in 1:n) {
zer <- ellipse(0, scale=c(2/n, 2/n), centre=c(i, j))
polygon(zer, col=colz[i, j], border=NA)
ell <- ellipse(rr[i, j], scale=c(2/n, 2/n), centre=c(i, j))
polygon(ell, col="white", border=NA)
text(i, j, rrf[i, j], cex=8/n)
}}
??alpha
n <- dim(rr)[1]
windows()
par(xaxs="i", yaxs="i", pty="s")
plot(1:n, 1:n, type="n", xlim=c(0, n+1), ylim=c(0, n+1))
for(i in 1:n) {
for(j in 1:n) {
zer <- ellipse(0, scale=c(2/n, 2/n), centre=c(i, j))
polygon(zer, col=colz[i, j], border=NA)
ell <- ellipse(rr[i, j], scale=c(2/n, 2/n), centre=c(i, j))
polygon(ell, col="white", border=NA)
text(i, j, rrf[i, j], cex=8/n, col=rgb(1, 1, 1))
}}
par(xaxs="i", yaxs="i", pty="s")
plot(1:n, 1:n, type="n", xlim=c(0, n+1), ylim=c(0, n+1))
for(i in 1:n) {
for(j in 1:n) {
zer <- ellipse(0, scale=c(2/n, 2/n), centre=c(i, j))
polygon(zer, col=colz[i, j], border=NA)
ell <- ellipse(rr[i, j], scale=c(2/n, 2/n), centre=c(i, j))
polygon(ell, col="white", border=NA)
text(i, j, rrf[i, j], cex=8/n, col=rgb(0, 0, 0))
}}
par(xaxs="i", yaxs="i", pty="s")
plot(1:n, 1:n, type="n", xlim=c(0, n+1), ylim=c(0, n+1))
for(i in 1:n) {
for(j in 1:n) {
zer <- ellipse(0, scale=c(2/n, 2/n), centre=c(i, j))
polygon(zer, col=colz[i, j], border=NA)
ell <- ellipse(rr[i, j], scale=c(2/n, 2/n), centre=c(i, j))
polygon(ell, col="white", border=NA)
text(i, j, rrf[i, j], cex=8/n, col=rgb(0, 0, 0, alpha=abs(rr[i, j])))
}}
seriate(r)
(1-r)/2
(1-rr)/2
rr
seriate((1-rr)/2)
# order rows/columns
ser <- seriate((1-rr)/2)
ord1 <- get_order(ser, 1)
ord1
ord2 <- get_order(ser, 2)
ord2
library(ellipse)
library(seriation)
# data
dat <- matrix(rnorm(1000), ncol=10)
dat[, 3] <- 3*dat[, 5] + 2 + rnorm(100)
# correlation matrix
r <- cor(dat)
# Plot the correlation matrix for the mtcars data full model fit 
data(mtcars)
fit <- lm(mpg ~ ., mtcars)
r <- summary(fit, correlation = TRUE)$correlation
# options
# text size
# diagonal
# round to the nearest hundredth
rr <- round(r, 2)
rrf <- format(rr)
rra <- abs(rr)
n <- dim(rr)[1]
# order rows/columns
ser <- seriate((1-rr)/2)
ord1 <- get_order(ser, 1)
ord2 <- get_order(ser, 2)
# categorize correlations from -1 to 1 by 0.01
brks <- seq(-1, 1, 0.01)
rcat <- apply(rr, 2, cut, breaks=brks, labels=FALSE)
# assign colors on the cyan-magenta scale
colz <- apply(rcat, 2, function(x) cm.colors(length(brks))[x])
windows()
par(xaxs="i", yaxs="i", pty="s")
plot(1:n, 1:n, type="n", xlim=c(0, n+1), ylim=c(0, n+1))
for(i in ord1) {
for(j in ord2) {
zer <- ellipse(0, scale=c(2/n, 2/n), centre=c(i, j))
polygon(zer, col=colz[i, j], border=NA)
ell <- ellipse(rr[i, j], scale=c(2/n, 2/n), centre=c(i, j))
polygon(ell, col="white", border=NA)
text(i, j, rrf[i, j], cex=8/n, col=rgb(0, 0, 0, alpha=rra[i, j]))
}}
windows()
plotcorr(rr)
par(xaxs="i", yaxs="i", pty="s")
plot(1:n, 1:n, type="n", xlim=c(0, n+1), ylim=c(0, n+1))
for(i in 1:n) {
for(j in 1:n) {
io <- ord1[i]
jo <- ord2[j]
zer <- ellipse(0, scale=c(2/n, 2/n), centre=c(i, j))
polygon(zer, col=colz[io, jo], border=NA)
ell <- ellipse(rr[io, jo], scale=c(2/n, 2/n), centre=c(i, j))
polygon(ell, col="white", border=NA)
text(i, j, rrf[io, jo], cex=8/n, col=rgb(0, 0, 0, alpha=rra[io, jo]))
}}
par(xaxs="i", yaxs="i", pty="s")
plot(1:n, 1:n, type="n", xlim=c(0, n+1), ylim=c(0, n+1))
for(i in 1:n) {
for(j in 1:n) {
io <- ord1[i]
jo <- ord1[j]
zer <- ellipse(0, scale=c(2/n, 2/n), centre=c(i, j))
polygon(zer, col=colz[io, jo], border=NA)
ell <- ellipse(rr[io, jo], scale=c(2/n, 2/n), centre=c(i, j))
polygon(ell, col="white", border=NA)
text(i, j, rrf[io, jo], cex=8/n, col=rgb(0, 0, 0, alpha=rra[io, jo]))
}}
reorder
order
diag(r)
r
?upper.tri
addtext=TRUE
incdiag=FALSE
rorder=TRUE
q()
cleanup()
q()
utils:::menuInstallPkgs()
q()
library(devtools)
library(roxygen2)
setwd("C:/JVA/GitHub")
install("jvamisc")
setwd("C:/JVA/R/Working Directory")
library(jvamisc)
?plotcor
plotcor(cor(swiss))
plotcor(cor(longley))
library(devtools)
setwd("C:/JVA/GitHub/jvamisc")
document()
q()
