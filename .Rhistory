matrixtrim(m)
#' Trim Matrix
#'
#' Trim the rows and columns of a logical matrix until every row and columns has a specified level of TRUE values.
#' @param m A logical matrix to be trimmed, should be all TRUE, FALSE (or 0, 1).
#' @param prop A numeric scalar, the minimum proportion of TRUE values in any row or column of the trimmed matrix, default 1.
#' @return A list of length six, the first three resulting from using method 1, the next threre from method 2 (see details).
#' \itemize{
#'   \item \code{trim1}(\code{trim2}) = a logical matrix, the resulting trimmed matrix using method 1(2)
#'   \item \code{dim1}(\code{dim2}) = a numeric vector of length 2, the dimensions of \code{trim1}(\code{trim2})
#'   \item \code{n1}(\code{n2}) = a numeric scaler, the total number of TRUE values in \code{trim1}(\code{trim2})
#' }
#' @detailsTwo methods are used to trim the matrix.  Method 1 removes columns with many FALSE values before removing rows.
#' Method 2 removes rows with many FALSE values before removing columns.
#' @export
#' @examples 
#' m <- matrix(c(1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0), nrow=5)
#' matrixtrim(m)
#' matrixtrim(m, 0.8)
matrixtrim <- function(m, prop=1) {
# trim the rows and columns of a 0/1 (or F/T) matrix
# until every row and column has at least "prop" proportion of 1's (T's)
# method1 tends to delete columns first
# method2 tends delete rows first
newm1 <- m
allmin1 <- 0
while(allmin1 < prop) {
rowmeans <- apply(newm1, 1, mean)
rowminval <- min(rowmeans)
rowofmin <- which(rowmeans==rowminval)
colmeans <- apply(newm1, 2, mean)
colminval <- min(colmeans)
colofmin <- which(colmeans==colminval)
allmin1 <- min(c(rowminval, colminval))
if(allmin1 >= prop) break()
if(rowminval < colminval) {
newm1 <- newm1[-rowofmin, ]
} else {
newm1 <- newm1[, -colofmin]
}
}
newm2 <- m
allmin2 <- 0
while(allmin2 < prop) {
rowmeans <- apply(newm2, 1, mean)
rowminval <- min(rowmeans)
rowofmin <- which(rowmeans==rowminval)
colmeans <- apply(newm2, 2, mean)
colminval <- min(colmeans)
colofmin <- which(colmeans==colminval)
allmin2 <- min(c(rowminval, colminval))
if(allmin2 >= prop) break()
if(rowminval > colminval) {
newm2 <- newm2[, -colofmin]
} else {
newm2 <- newm2[-rowofmin, ]
}
}
list(trim1=newm1, dim1=dim(newm1), n1=sum(newm1), trim2=newm2, dim2=dim(newm2), n2=sum(newm2))
}
m <- matrix(c(1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0), nrow=5)
matrixtrim(m)
matrixtrim(m, 0.8)
m
matrixtrim <- function(m, prop=1) {
# trim the rows and columns of a 0/1 (or F/T) matrix
# until every row and column has at least "prop" proportion of 1's (T's)
# method1 tends to delete columns first
# method2 tends delete rows first
newm1 <- m
allmin1 <- 0
while(allmin1 <= prop) {
rowmeans <- apply(newm1, 1, mean)
rowminval <- min(rowmeans)
rowofmin <- which(rowmeans==rowminval)
colmeans <- apply(newm1, 2, mean)
colminval <- min(colmeans)
colofmin <- which(colmeans==colminval)
allmin1 <- min(c(rowminval, colminval))
#if(allmin1 >= prop) break()
if(rowminval < colminval) {
newm1 <- newm1[-rowofmin, ]
} else {
newm1 <- newm1[, -colofmin]
}
}
newm2 <- m
allmin2 <- 0
while(allmin2 <= prop) {
rowmeans <- apply(newm2, 1, mean)
rowminval <- min(rowmeans)
rowofmin <- which(rowmeans==rowminval)
colmeans <- apply(newm2, 2, mean)
colminval <- min(colmeans)
colofmin <- which(colmeans==colminval)
allmin2 <- min(c(rowminval, colminval))
#if(allmin2 >= prop) break()
if(rowminval > colminval) {
newm2 <- newm2[, -colofmin]
} else {
newm2 <- newm2[-rowofmin, ]
}
}
list(trim1=newm1, dim1=dim(newm1), n1=sum(newm1), trim2=newm2, dim2=dim(newm2), n2=sum(newm2))
}
matrixtrim(m)
newm1 <- m
allmin1 <- 0
allmin1 <= prop
prop <- 1
allmin1 <= prop
rowmeans <- apply(newm1, 1, mean)
rowminval <- min(rowmeans)
rowofmin <- which(rowmeans==rowminval)
colmeans <- apply(newm1, 2, mean)
colminval <- min(colmeans)
colofmin <- which(colmeans==colminval)
allmin1 <- min(c(rowminval, colminval))
?break
?while
?"while"
allmin1
rowminval < colminval
rowminval
colminval
m
newm1 <- newm1[-rowofmin, ]
rowmeans <- apply(newm1, 1, mean)
rowminval <- min(rowmeans)
rowofmin <- which(rowmeans==rowminval)
colmeans <- apply(newm1, 2, mean)
colminval <- min(colmeans)
colofmin <- which(colmeans==colminval)
allmin1 <- min(c(rowminval, colminval))
allmin1
prop
matrixtrim(m, 0.7)
#' Trim Matrix
#'
#' Trim the rows and columns of a logical matrix until every row and columns has a specified level of TRUE values.
#' @param m A logical matrix to be trimmed, should be all TRUE, FALSE (or 0, 1).
#' @param prop A numeric scalar, the minimum proportion of TRUE values in any row or column of the trimmed matrix, default 1.
#' @return A list of length six, the first three resulting from using method 1, the next threre from method 2 (see details).
#' \itemize{
#'   \item \code{trim1}(\code{trim2}) = a logical matrix, the resulting trimmed matrix using method 1(2)
#'   \item \code{dim1}(\code{dim2}) = a numeric vector of length 2, the dimensions of \code{trim1}(\code{trim2})
#'   \item \code{n1}(\code{n2}) = a numeric scaler, the total number of TRUE values in \code{trim1}(\code{trim2})
#' }
#' @detailsTwo methods are used to trim the matrix.  Method 1 removes columns with many FALSE values before removing rows.
#' Method 2 removes rows with many FALSE values before removing columns.
#' @export
#' @examples 
#' m <- matrix(c(1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0), nrow=5)
#' matrixtrim(m)
#' matrixtrim(m, 0.7)
matrixtrim <- function(m, prop=1) {
# trim the rows and columns of a 0/1 (or F/T) matrix
# until every row and column has at least "prop" proportion of 1's (T's)
# method1 tends to delete columns first
# method2 tends delete rows first
newm1 <- m
allmin1 <- 0
while(allmin1 <= prop) {
rowmeans <- apply(newm1, 1, mean)
rowminval <- min(rowmeans)
rowofmin <- which(rowmeans==rowminval)
colmeans <- apply(newm1, 2, mean)
colminval <- min(colmeans)
colofmin <- which(colmeans==colminval)
allmin1 <- min(c(rowminval, colminval))
if(allmin1 >= prop) break()
if(rowminval < colminval) {
newm1 <- newm1[-rowofmin, ]
} else {
newm1 <- newm1[, -colofmin]
}
}
newm2 <- m
allmin2 <- 0
while(allmin2 <= prop) {
rowmeans <- apply(newm2, 1, mean)
rowminval <- min(rowmeans)
rowofmin <- which(rowmeans==rowminval)
colmeans <- apply(newm2, 2, mean)
colminval <- min(colmeans)
colofmin <- which(colmeans==colminval)
allmin2 <- min(c(rowminval, colminval))
#if(allmin2 >= prop) break()
if(rowminval > colminval) {
newm2 <- newm2[, -colofmin]
} else {
newm2 <- newm2[-rowofmin, ]
}
}
list(trim1=newm1, dim1=dim(newm1), n1=sum(newm1), trim2=newm2, dim2=dim(newm2), n2=sum(newm2))
}
matrixtrim(m, 0.7)
matrixtrim <- function(m, prop=c(1, 1), removerowsfirst=TRUE) {
# trim the rows and columns of a 0/1 (or F/T) matrix
# until every row and column has at least "prop" proportion of 1's (T's)
# method1 tends to delete columns first
# method2 tends delete rows first
newm <- m
rmin <- 0
cmin <- 0
while(rmin < prop[1] | cmin < prop[2]) {
rowmeans <- apply(newm, 1, mean)
rmin <- min(rowmeans)
rowofmin <- which(rowmeans==rmin)
colmeans <- apply(newm, 2, mean)
cmin <- min(colmeans)
colofmin <- which(colmeans==cmin)
if(rmin >= prop[1] & cmin >= prop[2]) break()
if(rmin1 < cmin) {
newm <- newm[-rowofmin, ]
} else {
if(rmin1 > cmin) {
newm <- newm[, -colofmin]
} else {
if(removerowsfirst) {
newm <- newm[-rowofmin, ]
} else {
newm <- newm[, -colofmin]
}
}
}
list(trim=newm, dim=dim(newm), n=sum(newm))
}
matrixtrim <- function(m, prop=c(1, 1), removerowsfirst=TRUE) {
# trim the rows and columns of a 0/1 (or F/T) matrix
# until every row and column has at least "prop" proportion of 1's (T's)
# method1 tends to delete columns first
# method2 tends delete rows first
newm <- m
rmin <- 0
cmin <- 0
while(rmin < prop[1] | cmin < prop[2]) {
rowmeans <- apply(newm, 1, mean)
rmin <- min(rowmeans)
rowofmin <- which(rowmeans==rmin)
colmeans <- apply(newm, 2, mean)
cmin <- min(colmeans)
colofmin <- which(colmeans==cmin)
if(rmin >= prop[1] & cmin >= prop[2]) break()
if(rmin1 < cmin) {
newm <- newm[-rowofmin, ]
} else {
if(rmin1 > cmin) {
newm <- newm[, -colofmin]
} else {
if(removerowsfirst) {
newm <- newm[-rowofmin, ]
} else {
newm <- newm[, -colofmin]
}
}
}
}
list(trim=newm, dim=dim(newm), n=sum(newm))
}
m <- matrix(c(1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0), nrow=5)
matrixtrim(m)
matrixtrim <- function(m, prop=c(1, 1), rowsfirst=TRUE) {
# trim the rows and columns of a 0/1 (or F/T) matrix
# until every row and column has at least "prop" proportion of 1's (T's)
# method1 tends to delete columns first
# method2 tends delete rows first
newm <- m
rmin <- 0
cmin <- 0
while(rmin < prop[1] | cmin < prop[2]) {
rowmeans <- apply(newm, 1, mean)
rmin <- min(rowmeans)
rowofmin <- which(rowmeans==rmin)
colmeans <- apply(newm, 2, mean)
cmin <- min(colmeans)
colofmin <- which(colmeans==cmin)
if(rmin >= prop[1] & cmin >= prop[2]) break()
if(rmin < cmin) {
newm <- newm[-rowofmin, ]
} else {
if(rmin > cmin) {
newm <- newm[, -colofmin]
} else {
if(rowsfirst) {
newm <- newm[-rowofmin, ]
} else {
newm <- newm[, -colofmin]
}
}
}
}
list(trim=newm, dim=dim(newm), n=sum(newm))
}
matrixtrim(m)
matrixtrim(m, rowsfirst=FALSE)
matrixtrim(m, prop=c(0.7, 0.7))
matrixtrim(m, prop=c(0.7, 0.7), rowsfirst=FALSE)
#' Trim Matrix
#'
#' Trim the rows and columns of a logical matrix until every row and columns has a specified level of TRUE values.
#' @param m A logical matrix to be trimmed, should be all TRUE, FALSE (or 0, 1).
#' @param prop A numeric vector of length two, the minimum proportion of TRUE values in each row and column of the trimmed matrix, 
#' default c(1, 1).
#' @param rowsfirstA logical scalar, indicating if rows (TRUE, the default) or columns (FALSE) should be trimmed from the matrix first.
#' @return A list of length three:
#' \itemize{
#'   \item \code{trim} = a logical matrix, the resulting trimmed matrix
#'   \item \code{dim} = a numeric vector of length 2, the dimensions of \code{trim}
#'   \item \code{n} = a numeric scaler, the total number of TRUE values in \code{trim}
#' }
#' @export
#' @examples 
#' m <- matrix(c(1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0), nrow=5)
#' matrixtrim(m)
#' matrixtrim(m, rowsfirst=FALSE)
#' matrixtrim(m, prop=c(0.7, 0.7))
matrixtrim <- function(m, prop=c(1, 1), rowsfirst=TRUE) {
# trim the rows and columns of a 0/1 (or F/T) matrix
# until every row and column has at least "prop" proportion of 1's (T's)
# method1 tends to delete columns first
# method2 tends delete rows first
newm <- m
rmin <- 0
cmin <- 0
while(rmin < prop[1] | cmin < prop[2]) {
rowmeans <- apply(newm, 1, mean)
rmin <- min(rowmeans)
rowofmin <- which(rowmeans==rmin)
colmeans <- apply(newm, 2, mean)
cmin <- min(colmeans)
colofmin <- which(colmeans==cmin)
if(rmin >= prop[1] & cmin >= prop[2]) break()
if(rmin < cmin) {
newm <- newm[-rowofmin, ]
} else {
if(rmin > cmin) {
newm <- newm[, -colofmin]
} else {
if(rowsfirst) {
newm <- newm[-rowofmin, ]
} else {
newm <- newm[, -colofmin]
}
}
}
}
list(trim=newm, dim=dim(newm), n=sum(newm))
}
?cheat
library(devtools)
setwd("C:/JVA/GitHub/jvamisc")
document()
q()
