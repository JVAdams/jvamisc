dat[obs %in% obs[duplicated(obs)], ]
search()
detach()
dat <- read.csv("C:/JVA/Consult/Kraus/Gill net walleye/GLIMMIX_alldata_commonmeshes (1).txt", sep="",
header=FALSE, col.names=c("year", "type", "mesh", "we", "holes", "catch", "secchi", "site", "serial"))
# site is a "block" effect representing the "pair" ... both location and year information
# mesh is a covariate
# type is a factor
dat <- dat[order(dat$year, dat$site, dat$type, dat$mesh), ]
attach(dat)
obs <- interaction(year, site, type, mesh)
dat[obs %in% obs[duplicated(obs)], ]
head(dat)
dat[obs %in% obs[duplicated(obs)], c("year", "site", "type", "mesh", "serial", "secchi", "catch", "holes", "we")]
table(site, year)
a <- table(site, year)
apply(a>0, 1, sum)
sort(apply(a>0, 1, sum))
dat$accum <- 100*catch/holes
dat$water <- cut(secchi, c(0, 1, 2, 4), right=FALSE, labels=FALSE)
dat$typef <- as.factor(type)
dat$sitef <- as.factor(site)
fit <- gam(we ~ typef + sitef + s(mesh, k=5) + s(secchi, k=5), data=dat)
summary(fit)
plot(fit, all.terms=TRUE)
fit <- glm(we ~ typef + sitef + poly(mesh, 2) + secchi, data=dat)
summary(fit)
fit <- aov(we ~ typef + sitef + poly(mesh, 2) + secchi, data=dat)
summary(fit)
fit <- aov(we ~ sitef + poly(mesh, 2) + secchi*typef, data=dat)
summary(fit)
fit <- aov(we ~ sitef + poly(mesh, 2) + secchi + typef, data=dat)
summary(fit)
plot(fit)
summary(we)
fit <- aov(sqrt(we) ~ sitef + poly(mesh, 2) + secchi + typef, data=dat)
summary(fit)
plot(fit)
plot(predict(fit), resid(fit))
windows()
par(mfrow=c(3, 2))
plot(predict(fit), resid(fit))
plot(sitef, resid(fit))
plot(mesh, resid(fit))
plot(secchi, resid(fit))
plot(typef, resid(fit))
detach(dat)
attach(dat)
windows()
par(mfrow=c(3, 2))
plot(predict(fit), resid(fit))
plot(sitef, resid(fit))
plot(mesh, resid(fit))
plot(secchi, resid(fit))
plot(typef, resid(fit))
windows()
par(mfrow=c(3, 2), mar=c(4, 4, 1, 1))
plot(predict(fit), predict(fit))
plot(sitef, predict(fit))
plot(mesh, predict(fit))
plot(secchi, predict(fit))
plot(typef, predict(fit))
par(mfrow=c(3, 2), mar=c(4, 4, 1, 1))
plot(predict(fit), predict(fit))
plot(sitef, predict(fit))
plot(jitter(mesh), predict(fit))
plot(jitter(secchi), predict(fit))
plot(typef, predict(fit))
par(mfrow=c(2, 3), mar=c(4, 4, 1, 1))
plot(sqrt(we), predict(fit))
plot(sitef, predict(fit))
plot(jitter(mesh), predict(fit))
plot(jitter(secchi), predict(fit))
plot(typef, predict(fit))
par(mfrow=c(2, 3), mar=c(4, 4, 1, 1))
plot(sqrt(we), predict(fit))
lines(loess.smooth(sqrt(we), predict(fit)))
plot(sitef, predict(fit))
plot(jitter(mesh), predict(fit))
lines(loess.smooth(mesh, predict(fit)))
plot(jitter(secchi), predict(fit))
lines(loess.smooth(secchi, predict(fit)))
plot(typef, predict(fit))
par(mfrow=c(2, 3), mar=c(4, 4, 1, 1))
plot(sqrt(we), predict(fit))
lines(loess.smooth(sqrt(we), predict(fit)), lwd=2, col="red")
plot(sitef, predict(fit))
plot(jitter(mesh), predict(fit))
lines(loess.smooth(mesh, predict(fit)), lwd=2, col="red")
plot(jitter(secchi), predict(fit))
lines(loess.smooth(secchi, predict(fit)), lwd=2, col="red")
plot(typef, predict(fit))
fit <- aov(sqrt(we) ~ sitef + poly(mesh, 2) + poly(secchi, 2) + typef, data=dat)
summary(fit)
windows()
par(mfrow=c(2, 3), mar=c(4, 4, 1, 1))
plot(predict(fit), resid(fit))
plot(sitef, resid(fit))
plot(mesh, resid(fit))
plot(secchi, resid(fit))
plot(typef, resid(fit))
graphics.off()
windows()
par(mfrow=c(2, 3), mar=c(4, 4, 1, 1))
plot(predict(fit), resid(fit))
abline(h=0, lwd=2, col="red")
plot(sitef, resid(fit))
abline(h=0, lwd=2, col="red")
plot(jitter(mesh), resid(fit))
abline(h=0, lwd=2, col="red")
plot(jitter(secchi), resid(fit))
abline(h=0, lwd=2, col="red")
plot(typef, resid(fit))
abline(h=0, lwd=2, col="red")
windows()
par(mfrow=c(2, 3), mar=c(4, 4, 1, 1))
plot(sqrt(we), predict(fit))
lines(loess.smooth(sqrt(we), predict(fit)), lwd=2, col="red")
plot(sitef, predict(fit))
plot(jitter(mesh), predict(fit))
lines(loess.smooth(mesh, predict(fit)), lwd=2, col="red")
plot(jitter(secchi), predict(fit))
lines(loess.smooth(secchi, predict(fit)), lwd=2, col="red")
plot(typef, predict(fit))
head(dat)
windows()
par(mfrow=c(2, 3), mar=c(4, 4, 1, 1))
plot(as.factor(year), resid(fit))
plot(sqrt(catch), resid(fit))
plot(serial, resid(fit))
plot(accum, resid(fit))
par(mfrow=c(2, 2), mar=c(4, 4, 1, 1))
plot(as.factor(year), resid(fit))
abline(h=0, lwd=2, col="red")
plot(sqrt(catch), resid(fit))
abline(h=0, lwd=2, col="red")
plot(sqrt(accum), resid(fit))
abline(h=0, lwd=2, col="red")
par(mfrow=c(2, 2), mar=c(4, 4, 1, 1))
plot(as.factor(year), resid(fit))
abline(h=0, lwd=2, col="red")
plot(sqrt(catch), resid(fit))
lines(loess.smooth(sqrt(catch), resid(fit)), lwd=2, col="cyan")
abline(h=0, lwd=2, col="red")
plot(sqrt(accum), resid(fit))
lines(loess.smooth(sqrt(accum), resid(fit)), lwd=2, col="cyan")
abline(h=0, lwd=2, col="red")
windows()
par(mfrow=c(2, 3), mar=c(4, 4, 1, 1))
plot(predict(fit), resid(fit))
abline(h=0, lwd=2, col="red")
plot(sqrt(we), resid(fit))
lines(loess.smooth(sqrt(we), resid(fit)), lwd=2, col="cyan")
abline(h=0, lwd=2, col="red")
plot(sitef, resid(fit))
abline(h=0, lwd=2, col="red")
plot(jitter(mesh), resid(fit))
abline(h=0, lwd=2, col="red")
plot(jitter(secchi), resid(fit))
abline(h=0, lwd=2, col="red")
plot(typef, resid(fit))
abline(h=0, lwd=2, col="red")
q()
# C:\JVA\Lamprey\Adults\AdultIndex\2014\AdultIndex v2.r
{ # functions
# the following seven plot.table related function are from the Systmatic Investor Toolbox
# load Systematic Investor Toolbox
# require(RCurl)
# sit = getURLContent("https://github.com/systematicinvestor/SIT/raw/master/sit.gz", binary=TRUE, followlocation=TRUE, ssl.verifypeer=FALSE)
# con = gzcon(rawConnection(sit, "rb"))
# source(con)
# close(con)
draw.cell <- function(title, r, c, text.cex = 1, bg.col = 'white', frame.cell = T) {
if(!frame.cell) bcol = bg.col else bcol = 'black'
rect((2*(c - 1) + .5), -(r - .5), (2*c + .5), -(r + .5), col = bg.col, border = bcol)
if( c == 1) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else if( r == 1 ) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else {
text((2*c + .5), -r, title, adj = 1, cex = text.cex)
}
}
plot.table.helper.auto.adjust.cex <- function(temp.table, keep.all.same.cex = FALSE) {
nr = nrow(temp.table)
nc = ncol(temp.table)
all.xrange = diff(par()$usr[1:2]) / nc
xrange = matrix( strwidth(paste('  ', temp.table), units = 'user', cex = 1), nc = nc)
all.yrange = diff(par()$usr[3:4]) / nr
yrange = matrix( 5/3 * strheight(temp.table, units = 'user', cex = 1), nc = nc)
plot.matrix.cex = pmin( round(all.yrange / yrange, 2) , round(all.xrange / xrange, 2) )
header.col.cex = min(plot.matrix.cex[1,-1])
header.row.cex = min(plot.matrix.cex[-1,1])
title.cex = plot.matrix.cex[1, 1]
data.cex = min(plot.matrix.cex[-1, -1])
if ( keep.all.same.cex ) {
plot.matrix.cex[] = min(plot.matrix.cex)
} else {
plot.matrix.cex[1,-1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,-1]= min(c(header.col.cex, header.row.cex, data.cex))
plot.matrix.cex[1,1]= min(c(header.col.cex, header.row.cex, data.cex, title.cex))
plot.matrix.cex[1,-1] = min(c(header.col.cex))
plot.matrix.cex[-1,1] = min(c(header.row.cex))
plot.matrix.cex[-1,-1]= min(c(data.cex))
plot.matrix.cex[1,1]= min(c(title.cex))
}
return(plot.matrix.cex)
}
make.table <- function(nr, nc) {
savepar = par(mar = rep(1, 4))
plot(c(0.5, nc*2 + 0.5), c(-0.5, -(nr + 0.5)), xaxs = 'i', yaxs = 'i',
type = 'n', xlab = '', ylab = '', axes = FALSE)
savepar
}
trim <- function(s) {
s = sub(pattern = '^ +', replacement = '', x = s)
s = sub(pattern = ' +$', replacement = '', x = s)
return(s)
}
plot.table.param <- function(plot.matrix, smain = '', plot.matrix.cex, plot.matrix_bg.col, frame.cell = T, keep.all.same.cex = FALSE) {
n = nrow(plot.matrix)
pages = unique(c(seq(0, n, by = 120), n))
for(p in 1:(length(pages)-1)) {
rindex = (pages[p]+1) : pages[p+1]
temp.table = matrix('', nr = length(rindex)+1, nc = ncol(plot.matrix)+1)
temp.table[-1, -1] = plot.matrix[rindex,]
temp.table[1, -1] = colnames(plot.matrix)
temp.table[-1, 1] = rownames(plot.matrix)[rindex]
temp.table[1, 1] = smain
nr = nrow(temp.table)
nc = ncol(temp.table)
par(mar = c(0, 0, 0, 0), cex = 0.5)
oldpar = make.table(nr, nc)
text.cex = plot.matrix.cex[c(1, 1 + rindex), ]
text.cex = plot.table.helper.auto.adjust.cex(temp.table, keep.all.same.cex)
bg.col = plot.matrix_bg.col[c(1, 1 + rindex), ]
for(r in 1:nr) {
for(c in 1:nc) {
draw.cell( paste('', temp.table[r,c], '', sep=' '), r, c,
text.cex = text.cex[r,c], bg.col = bg.col[r,c], frame.cell = frame.cell)
}}
}
}
plot.table <- function(plot.matrix, smain="", text.cex=1, frame.cell=TRUE, highlight=FALSE, colorbar=FALSE, keep_all.same.cex=FALSE) {
if( is.null(rownames(plot.matrix)) & is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
if( ncol(temp.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[-1, -1, drop = FALSE]
colnames(plot.matrix) = temp.matrix[1, -1]
rownames(plot.matrix) = temp.matrix[-1, 1]
smain = temp.matrix[1, 1]
} else if( is.null(rownames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( ncol(plot.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[, -1, drop = FALSE]
colnames(plot.matrix) = colnames(temp.matrix)[-1]
rownames(plot.matrix) = temp.matrix[,1]
smain = colnames(temp.matrix)[1]
} else if( is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
plot.matrix = temp.matrix[-1, , drop = FALSE]
rownames(plot.matrix) = rownames(temp.matrix)[-1]
colnames(plot.matrix) = temp.matrix[1, ]
smain = rownames(temp.matrix)[1]
}
plot.matrix[which(trim(plot.matrix) == "NA")] = ""
plot.matrix[which(trim(plot.matrix) == "NA%")] = ""
plot.matrix[which(is.na(plot.matrix))] = ""
nr = nrow(plot.matrix) + 1
nc = ncol(plot.matrix) + 1
is_highlight = TRUE
if(is.logical(highlight)) {
is_highlight = highlight
if(highlight) highlight = plot.table.helper.color(plot.matrix)
}
if(!is_highlight) {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[seq(1, nr, 2), ] = "yellow"
plot.matrix_bg.col[1,] = "gray";
plot.table.param( plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
} else {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[1,] = "gray"
plot.matrix_bg.col[2:nr,2:nc] = highlight
plot.table.param(plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
}
}
plot.table.helper.color <- function (temp) {
temp = matrix(as.double(gsub("[%,$]", "", temp)), nrow(temp), ncol(temp))
highlight = as.vector(temp)
cols = rep(NA, length(highlight))
ncols = length(highlight[!is.na(highlight)])
cols[1:ncols] = rev(rainbow(ncols, start=0.5/6, end=3.5/6))
o = sort.list(highlight, na.last = TRUE, decreasing = FALSE)
o1 = sort.list(o, na.last = TRUE, decreasing = FALSE)
highlight = matrix(cols[o1], nrow = nrow(temp))
highlight[is.na(temp)] = NA
return(highlight)
}
ModelEst <- function(fit, df) {
# derive regression estimates from log(y) fit
mse <- rev(as.matrix(summary(fit)[[1]])[, "Mean Sq"])[1]
plpe <- predict(fit, newdata=df, se.fit=T)
m <- plpe$fit
v <- plpe$se.fit^2 + mse
exp(m + v/2)
}
myrange <- function(x) {
if(all(is.na(x))) r <- c(NA, NA) else r <- range(x, na.rm=TRUE)
return(r)
}
jackindex <- function(m) {
# m is a matrix of numbers (stream PEs) with observations (years) as rows and individuals (streams) as columns
if(any(is.na(m))) stop("The input matrix may not have any missing values.")
# calculate the index as the sum of the columns for each row
rowsum <- apply(m, 1, sum)
# calculate the mean of the index
avgind <- mean(rowsum)
# recalculate the index, leaving out one individual at a time
loo <- apply(m, 2, function(column) (rowsum - column))
# rescale the loo index, relative to mean
looscaled <- apply(loo, 2, function(x) x/mean(x))
# convert to original scale
looscaled2 <- looscaled * avgind
# calculate range
ranges <- t(apply(looscaled2, 1, range))
cbind(index=rowsum, lo=ranges[, 1], hi=ranges[, 2])
}
# selstreams <- index.streams[[1]]
# allstreamdf <- dat
# alllakedf <- lk
# min.nmr=2
# show=FALSE
index.est <- function(selstreams, allstreamdf, alllakedf, min.nmr=2, show=FALSE) {
# INDEX OF ADULT SEA LAMPREY ABUNDANCE
### INPUTS
# selstreams = vector of stream ids, e.g., 1.064 (lake + strcode/1000)
# allstreamdf = data frame of mark-recap estimates for all streams, with vars:  year lake ls Emr CVmr
# alllakedf = data frame of lake-wide PEs from Mullett et al. (2003) spawner model with vars:  lake year PE
# min.nmr = minimum number of mark-recapture estimates needed in a year to generate an index, default 2
# show = print out a brief summary of the results, default FALSE
### OUTPUTS
# indfit = simple model used to predict missing mark-recap estimates
# streamdf = original allstreamdf, subsetted by selstreams, with estimates for missing mark-recaps
# indxdf = original alllakedf, subsetted by lake, with annual index, including raw (indxraw), kept based on min.nmr (indxkeep, indxkeep.lo, indxkeep.hi)
# scaleup = conversion factor used to scale up annual index to spawner model PE
streamdf <- allstreamdf[allstreamdf$ls %in% selstreams, ]
# error checks
check1 <- var(streamdf$lake)
if(is.na(check1) | is.null(check1)) stop("Either no streams selected or critical data missing.") else if(check1 > 0) stop("Selected streams should be only from ONE lake.")
if(any(is.na(match(c("year", "lake", "ls", "Emr", "CVmr"), names(allstreamdf))))) stop("allstreamdf must include these variables: year lake ls Emr CVmr.")
if(any(is.na(match(c("year", "lake", "PE"), names(alllakedf))))) stop("alllakedf must include these variables: lake year PE.")
# fill in missing mark-recap data
indfit <- aov(log(Emr) ~ as.factor(ls) + as.factor(year), data=streamdf, weights=1/CVmr^2)
# figure out estimable years (those with at least 1 m-r estimate)
n.mr <- tapply(!is.na(streamdf$Emr), streamdf$year, sum)
eyrs <- as.numeric(names(n.mr)[n.mr > 0.5])
estimable <- streamdf$year %in% eyrs
streamdf$Pmr <- NA
streamdf$Pmr[estimable] <- ModelEst(fit=indfit, df=streamdf[estimable, ])
streamdf$COMBmr <- ifelse(is.na(streamdf$Emr), streamdf$Pmr, streamdf$Emr)
# annual index (sum across streams)
indxdf <- aggregate(COMBmr ~ year + lake, streamdf, sum, na.rm=TRUE, na.action=na.pass)
names(indxdf)[names(indxdf)=="COMBmr"] <- "indxraw"
indxdf$indxraw[indxdf$indxraw==0] <- NA
# only keep lake-wide index for years with at least min.nmr mark-recap estimates
indxdf$n.mr <- n.mr
indxdf$indxkeep <- ifelse(indxdf$n.mr > (min.nmr - 0.5), indxdf$indxraw, NA)
indxdf$indxkeep.lo <- NA
indxdf$indxkeep.hi <- NA
# matrix of stream estimates (rows = years, columns = index streams)
streamests <- with(streamdf, tapply(COMBmr, list(year, ls), mean))
# selection of only those streams with a keepable index
selkeep <- !is.na(indxdf$indxkeep)
jack <- jackindex(streamests[selkeep, ])
indxdf$indxkeep.lo[selkeep] <- jack[, "lo"]
indxdf$indxkeep.hi[selkeep] <- jack[, "hi"]
# scale up the index to the spawner model PE
lk1 <- lk[lk$lake == streamdf$lake[1], ]
indxdf2 <- merge(lk1, indxdf, all=TRUE)
scaleup <- median(indxdf2$PE / indxdf2$indxkeep, na.rm=TRUE)
if(show) {
cat("\nindfit\n")
print(summary(indfit))
cat("\nstreamdf\n")
print(tail(streamdf[, c("lake", "year", "ls", "Emr", "CVmr", "Pmr", "COMBmr")]))
cat("\nscaleup\n")
print(scaleup)
cat("\nindxdf\n")
print(tail(indxdf[, c("lake", "year", "n.mr", "indxraw", "indxkeep", "indxkeep.lo", "indxkeep.hi")]))
}
list(indfit=indfit, streamdf=streamdf, scaleup=scaleup, indxdf=indxdf)
}
calctarg <- function(lakenum, adults, year, targyears, adjust=c(1, 1, 0.25, 1, 1)) {
# lakenum = vector of lake numbers (1-5)
# adults = vector of lakewide adult sea lamprey estimates
# year = vector of years
# targyears = list (length 5) of selected years from which to calculate targets
# lake huron target is 25% of
targets <- data.frame(lake=1:5, target=rep(NA, 5), lo=rep(NA, 5), hi=rep(NA, 5))
for(i in 1:5) {
pick5 <- adults[lakenum==i & is.element(year, targyears[[i]]) & !is.na(adults)]
if(length(pick5) > 0) {
targets$target[i] <- mean(pick5)
n <- length(pick5)
ci <- qnorm(1 - 0.05/2) * sqrt(var(pick5)) / sqrt(n)
targets[i, c("lo", "hi")] <- mean(pick5) + c(-1, 1)*ci# using z dist (known variance)
targets[i, c("target", "lo", "hi")] <- adjust[i]*targets[i, c("target", "lo", "hi")]
} else {
targets[i, c("target", "lo", "hi")] <- c(NA, NA, NA)
}
}
targets
}
}
# bring in lake-wide spawner data
lk <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/LakePEdynamic.csv", as.is=T)
# bring in stream-specific data
dat <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/StreamPEdynamicALLCOLS.csv", as.is=T)
dat$ls <- dat$lscode
# 2014-04-09 Jess and Gale agreed that the East Au Gres (38) should be replaced with the Au Sable (36) in Lake Huron
# 2014-04-10 Jess thinks that we should just stick with the East Au Gres (38)
index.streams <- list(
Sup = c(1, 2, 9, 29, 31, 32, 62),
Mic = c(5, 6, 15, 24, 26, 35),
Hur = c(10, 16, 27, 32, 999, 38),
Eri = c(1, 2, 3, 7, 9),
Ont = c(5, 9, 22, 23, 36)
)
index.streams <- lapply(1:5, function(i) i + index.streams[[i]]/1000)
# estimate adult index of abundance for each lake using index streams
indices <- lapply(index.streams, index.est, dat, lk)
# combine index data for all lakes in one dataframe
indxall <- do.call(rbind, lapply(indices, "[[", "indxdf"))
# calculate targets
sptargyrz <- list(1994:1998, 1988:1992, 1989:1993, 1991:1995, 1999:2003)
targyrz <- apply(sapply(sptargyrz, range), 2, paste, collapse="-")
# spawner model
targets.sm <- calctarg(lakenum=lk$lake, adults=lk$PE, year=lk$year, targyears=sptargyrz)
# adult index
targets.ai <- calctarg(lakenum=indxall$lake, adults=indxall$indxkeep, year=indxall$year, targyears=sptargyrz)
# spawner model targets scaled down to adult index
targets.sm.su <- cbind(lake=targets.sm[, 1], (1/sapply(indices, "[[", "scaleup")) * targets.sm[, -1])
# adult index adjusted
targets.ai.adj <- targets.ai
targets.ai.adj[is.na(targets.ai$target), ] <- targets.sm.su[is.na(targets.ai$target), ]
YEAR1 <- 1984
ls()
targets.ai
targets.ai.adj
targets.sm
targets.sm.su
lakenum=indxall$lake
adults=indxall$indxkeep
year=indxall$year
targyears=sptargyrz
adjust=c(1, 1, 0.25, 1, 1)
targets <- data.frame(lake=1:5, target=rep(NA, 5), lo=rep(NA, 5), hi=rep(NA, 5))
targets
i <- 2
pick5 <- adults[lakenum==i & is.element(year, targyears[[i]]) & !is.na(adults)]
pick5
head(adults)
adults
lakenum
targyears[[i]]
year
cbind(year, adults, lakenum)
cbind(year, adults, lakenum)[lakenum==i, ]
targets.ai
# calculate targets
sptargyrz <- list(1994:1998, 1988:1992, 1989:1993, 1991:1995, 1999:2003)
targyrz <- apply(sapply(sptargyrz, range), 2, paste, collapse="-")
# spawner model
targets.sm <- calctarg(lakenum=lk$lake, adults=lk$PE, year=lk$year, targyears=sptargyrz)
# adult index
targets.ai <- calctarg(lakenum=indxall$lake, adults=indxall$indxkeep, year=indxall$year, targyears=sptargyrz)
# spawner model targets scaled down to adult index
targets.sm.su <- cbind(lake=targets.sm[, 1], (1/sapply(indices, "[[", "scaleup")) * targets.sm[, -1])
# adult index adjusted
targets.ai.adj <- targets.ai
targets.ai.adj[is.na(targets.ai$target), ] <- targets.sm.su[is.na(targets.ai$target), ]
targets.ai
targets.ai.adj
write.csv(targets.ai.adj, "C:/JVA/Lamprey/Adults/AdultIndex/2014/AdultIndexTargets.csv", row.names=FALSE)
cleanup()
q()
install.packages("broom")
library(broom)
lmfit <- lm(mpg ~ wt, mtcars)
lmfit
summary(lmfit)
tidy(lmfit)
head(augment(lmfit))
glance(lmfit)
lmfit <- lm(mpg ~ wt, mtcars)
tidy(lmfit)
glance(lmfit)
lmfit <- lm(mpg ~ wt, mtcars)
tidy(lmfit)
glance(lmfit)
cleanup()
q()
library(shiny)
shiny::runGitHub("hclust-shiny", "joyofdata")
# C:\JVA\Consult\Stapanian\Amphib\Model selection with AIC.r
# which environmental variables best predict this index of amphibian biotic integrity
# relevant emails:
# 15 May 2013 - https://mail.google.com/mail/u/0/?shva=1#search/amphibian/13ea801401e50a84
#  8 Aug 2013 - https://mail.google.com/mail/u/1/?shva=1#inbox/1405defbc5969b40
# 27 Aug 2013 - https://mail.google.com/mail/u/1/?shva=1#inbox/140c042c5ba851fc
wb <- loadWorkbook("C:/JVA/Consult/Stapanian/Amphib/amphibians_Jean Apr18.xlsx")
dat <- readWorksheet(wb, sheet="Jean")
names(dat) <- make.names(casefold(names(dat)), unique=T, allow_=F)
dimnames(dat)[[1]] <- dat$site.code
rm(wb)
# Analysis 1 should include the following (17) as potential predictors: 
varz1 <- c("metric1", "metric2", "metric3", "metric4", "metric5", "metric6", "vibi.score", "water", "forest", "wtld.forest", "wtld.emerg", 
"pasture", "row.crop", "suburban", "transitional", "rock", "urban")
varz1 <- c("metric1", "metric2", "metric3", "metric4", "metric5", "metric6", "vibi.score", "water", "forest", "wtld.forest", "wtld.emerg", 
"pasture", "row.crop", "suburban", "transitional", "rock", "urban")
### data exploration ###
attach(dat)
# several variables need to be log transformed
logk <- function(x) {
mx <- min(x, na.rm=TRUE)
if(mx<0) {
x <- x + abs(mx)
mx <- 0
}
k <- min(x[x>0], na.rm=TRUE)/2
print(k)
log(x + min(x[x>0], na.rm=TRUE)/2)
}
tranvar <- logk(as.vector(dat[, c("water", "forest", "wtld.forest", "wtld.emerg", "pasture", "row.crop", "suburban", "transitional", "rock", "urban")]))
names(tranvar) <- paste0("log", names(tranvar))
head(tranvar)
dat2 <- cbind(dat, tranvar)
rm(logk, tranvar)
detach(dat)
# Analysis 1 should include the following (17) as potential predictors: 
varz1 <- c("metric1", "metric2", "metric3", "metric4", "metric5", "metric6", "vibi.score", "logwater", "logforest", "logwtld.forest", "logwtld.emerg", 
"logpasture", "logrow.crop", "logsuburban", "logtransitional", "logrock", "logurban")
v1namz <- c("ORAM~metric~1", "ORAM~metric~2", "ORAM~metric~3", "ORAM~metric~4", "ORAM~metric~5", "ORAM~metric~6", "OVIBI", 
"LDI[water]", "LDI[forest]", "LDI[wetland~forest]", "LDI[wetland~emergent]", "LDI[pasture]", "LDI[crop]", "LDI[suburban]", "LDI[transitional]", 
"LDI[rock]", "LDI[urban]")
# AbbreviationDescription                                                                             
# LDIwaterProp. standing water                                                              
# LDIforestProp. upland (non-hydric soils) forest                                   
# LDIwetland forestProp. wetland (hydric soils) forest                                         
# LDIwetland emergentProp. wetland dominated by emergent vegetation                
# LDIpastureProp. pasture
# LDIcropProp. agricultural row-crop land
# LDIsuburbanProp. suburban residential
# LDIrockProp. exposed rock substrate
# LDItransitionalProp. land being transitioned to an undefined use
# LDIurbanProp. urban area         
# ORAM metric 1Area (6)                                                                                                            
# ORAM metric 2Upland buffers and surrounding land use (14)
# ORAM metric 3Hydrology (30)          
# ORAM metric 4Habitat Alteration and Development (20)
# ORAM metric 5Special wetlands (10)
# ORAM metric 6Plant communities, interspersion, and microtopography (20)            
# OVIBI10 metrics describing wetland vegetation quality (100)
# get rid of four variables with few unique values
# metric5 (with 3 unique values), logtransitional (with 4), and metric1 and logrock (each with 6).
rid <- c(5, 15, 1, 16)
varz1 <- varz1[-rid]
v1namz <- v1namz[-rid]
attach(dat2)
ct <- t(
sapply(varz1, function(x) {
ct <- cor.test(dat2[, x], amphibi)
ctp <- ct$p.value
ctr <- as.vector(ct$estimate)
c(p=ctp, r=ctr)
})
)
title <- ifelse(ct[, "p"] < 0.05/length(varz1), paste0("bold('*'~", v1namz, ")"), v1namz)
windows(h=8, w=5.5)
#par(mfcol=c(6, 3), mar=c(2.5, 2, 1.5, 1), oma=c(0, 2.5, 0, 0), las=1, cex=0.7)
par(mfcol=c(5, 3), mar=c(2.5, 2, 1.5, 1), oma=c(0, 2.5, 0, 0), las=1, cex=0.7)
for(i in rev(order(ct[, "r"]))) plot(dat2[, varz1[i]], amphibi, xlab="", ylab="", main=as.expression(parse(text=title[i])))
mtext("AmphIBI", side=2, outer=TRUE, las=0, line=1)
suv <- sort(unique(veg.class))
windows(h=6.5, w=6.5)
map("state", mar=c(1, 1, 1, 1), region= "ohio", col="darkgray", lwd=2)
for(i in seq(suv)) {
sel <- veg.class==suv[i]
points(lon.dd[sel], lat.dd[sel], cex=2, lwd=2, pch=c(2, 1)[i], col=c("black", "gray")[i])
}
legend("bottomright", capwords(suv), pch=c(2, 1), col=c("black", "gray"), pt.lwd=2, pt.cex=2, cex=1.15, title="Veg. Class")
locator()
?map.scale
map.scale(x=-81.5, y=40.2, ratio=FALSE, relwidth=0.2)
locator()
map.scale(x=-82, y=40, ratio=FALSE, relwidth=0.2)
map.scale(x=-82.5, y=40, ratio=FALSE, relwidth=0.2)
map.scale(x=-82.25, y=40, ratio=FALSE, relwidth=0.2)
map("state", mar=c(1, 1, 1, 1), region= "ohio", col="darkgray", lwd=2)
for(i in seq(suv)) {
sel <- veg.class==suv[i]
points(lon.dd[sel], lat.dd[sel], cex=2, lwd=2, pch=c(2, 1)[i], col=c("black", "gray")[i])
}
legend("bottomright", capwords(suv), pch=c(2, 1), col=c("black", "gray"), pt.lwd=2, pt.cex=2, cex=1.15, title="Veg. Class")
map.scale(x=-82.25, y=40, ratio=FALSE, relwidth=0.2)
map.scale(x=-82.25, y=40.1, ratio=FALSE, relwidth=0.2)
map("state", mar=c(1, 1, 1, 1), region= "ohio", col="darkgray", lwd=2)
for(i in seq(suv)) {
sel <- veg.class==suv[i]
points(lon.dd[sel], lat.dd[sel], cex=2, lwd=2, pch=c(2, 1)[i], col=c("black", "gray")[i])
}
legend("bottomright", capwords(suv), pch=c(2, 1), col=c("black", "gray"), pt.lwd=2, pt.cex=2, cex=1.15, title="Veg. Class")
map.scale(x=-82.25, y=40.2, ratio=FALSE, relwidth=0.2)
locator()
map.scale(x=-83.1, y=41.9, ratio=FALSE, relwidth=0.2)
suv <- sort(unique(veg.class))
windows(h=6.5, w=6.5)
map("state", mar=c(1, 1, 1, 1), region= "ohio", col="darkgray", lwd=2)
for(i in seq(suv)) {
sel <- veg.class==suv[i]
points(lon.dd[sel], lat.dd[sel], cex=2, lwd=2, pch=c(2, 1)[i], col=c("black", "gray")[i])
}
legend("bottomright", capwords(suv), pch=c(2, 1), col=c("black", "gray"), pt.lwd=2, pt.cex=2, cex=1.15, title="Veg. Class")
map.scale(x=-82.25, y=40.2, ratio=FALSE, relwidth=0.2)
map.scale(x=-83, y=42, ratio=FALSE, relwidth=0.2)
library(GISTools)
?map.scale
suv <- sort(unique(veg.class))
windows(h=6.5, w=6.5)
map("state", mar=c(1, 1, 1, 1), region= "ohio", col="darkgray", lwd=2)
for(i in seq(suv)) {
sel <- veg.class==suv[i]
points(lon.dd[sel], lat.dd[sel], cex=2, lwd=2, pch=c(2, 1)[i], col=c("black", "gray")[i])
}
legend("bottomright", capwords(suv), pch=c(2, 1), col=c("black", "gray"), pt.lwd=2, pt.cex=2, cex=1.15, title="Veg. Class")
map.scale(x=-83, y=42, ratio=FALSE, relwidth=0.2)
maps::map.scale(x=-83, y=42, ratio=FALSE, relwidth=0.2)
locator()
north.arrow(xb=-80.7, yb=39.2, len=0.05, lab="N")
suv <- sort(unique(veg.class))
windows(h=6.5, w=6.5)
map("state", mar=c(1, 1, 1, 1), region= "ohio", col="darkgray", lwd=2)
for(i in seq(suv)) {
sel <- veg.class==suv[i]
points(lon.dd[sel], lat.dd[sel], cex=2, lwd=2, pch=c(2, 1)[i], col=c("black", "gray")[i])
}
legend("bottomright", capwords(suv), pch=c(2, 1), col=c("black", "gray"), pt.lwd=2, pt.cex=2, cex=1.15, title="Veg. Class")
maps::map.scale(x=-83, y=42, ratio=FALSE, relwidth=0.2)
north.arrow(xb=-80.7, yb=39.2, len=0.05, lab="N")
par(usr=c(-126, 94, 21, 193), xpd=NA)
polygon(c(-128, -128, -64, -64, -128), c(22, 52, 52, 22, 22), col="white", lwd=2)
map("state", add=T, mar=c(0, 0, 0, 0)) 
map("state", region="ohio", fill=T, add=T) 
cleanup()
q()
# C:\JVA\Consult\Stapanian\Amphib\Next Subm 2\Three Group Approach 2.r
# which environmental variables best predict this index of amphibian biotic integrity
# relevant emails:
# 15 May 2013 - https://mail.google.com/mail/u/0/?shva=1#search/amphibian/13ea801401e50a84
#  8 Aug 2013 - https://mail.google.com/mail/u/1/?shva=1#inbox/1405defbc5969b40
# 27 Aug 2013 - https://mail.google.com/mail/u/1/?shva=1#inbox/140c042c5ba851fc
library(GISTools)
# bring in data and create initial figures
source("C:/JVA/Consult/Stapanian/Amphib/Next Subm 2/Explore Figs 2.r")
select.varz <- function(varnames, mydat, max.no.ind.var) {
# keep only those varnames that have at least two unique non-missing values
varnames <- varnames[apply(mydat[, varnames], 2, function(x) {
y <- var(x[!is.na(x)])
!is.na(y) & y>0
})]
m <- allcombs(length(varnames), 0, max.no.ind.var)
dimnames(m)[[2]] <- varnames
# right side of the formula
rightside <- apply(m, 1, function(row) paste(varnames[row==1], collapse=" + "))
# if no predictors, use 1 to represent intercept only model
rightside[rightside==""] <- "1"
form <- paste("amphibi ~", rightside)
fits <- lapply(form, function(f) lm(formula(f), dat=mydat))
# AIC table
aictab <- AICc(fits)
bigtab <- cbind(formula=rightside[aictab$model], aictab)
nmodzfit <- dim(bigtab)[1]
# top models
topmods <- bigtab[bigtab$daicc < 2, ]
# add coefficients to top model
coef <- lapply(fits[topmods$model], coef)
xmod <- unique(unlist(lapply(coef, names)))
topcoef <- t(sapply(coef, function(x) 
{
blank <- rep(0, length(xmod))
blank[match(names(x), xmod)] <- x
blank
}))
dimnames(topcoef)[[2]] <- xmod
topmods <- cbind(signif(topcoef, 3), round(topmods[, c("n", "p", "rmse", "aicc", "daicc", "aiccw")], 2))
# single best model
bestnum <- bigtab$model[1]
bestfit <- fits[[bestnum]]
xvarz <- varnames[m[bestnum, ]==1]
# output
out <- list(xvarz=xvarz, nmodzfit=nmodzfit, bestfit=bestfit, topmods=topmods, allfits=fits, allmods=bigtab, allpreds=m)
print(out[1:4])
out
}
assess.fit <- function(fit, newd) {
p <- predict(fit, newdata=newd)
y <- newd$amphibi
r <- p - y
rmse <- sqrt(mean(r^2))
r2 <- calcr2(fitted=p, observed=y, nparam=length(labels(terms(freshfita)))+1)
list(cbind(p=p, y=y, r=r), rmse=rmse, r2=r2)
}
# assign each observation to one of three groups
# ensure even distribution of groups across vegetation classes and latitudes
dat3 <- dat2[order(dat2$veg.class, dat2$lat.dd), ]
dat3$group <- rep(1:3, length.out=dim(dat2)[1])
df <- dat3
### map
attach(df)
suv <- sort(unique(veg.class))
windows(h=6.5, w=6.5)
map("state", mar=c(1, 1, 1, 1), region= "ohio", col="darkgray", lwd=2)
for(i in seq(suv)) {
sel <- veg.class==suv[i]
points(lon.dd[sel], lat.dd[sel], cex=2, lwd=2, pch=c(2, 1)[i], col=group[sel]+1)
}
maps::map.scale(x=-83, y=42, ratio=FALSE, relwidth=0.2)
north.arrow(xb=-80.7, yb=39.2, len=0.05, lab="N")
#legend("bottomright", capwords(suv), pch=c(2, 1), col=c("black", "gray"), pt.lwd=2, pt.cex=2, cex=1.15, title="Veg. Class")
par(usr=c(-126, 94, 21, 193), xpd=NA)
polygon(c(-128, -128, -64, -64, -128), c(22, 52, 52, 22, 22), col="white", lwd=2)
map("state", add=T, mar=c(0, 0, 0, 0)) 
map("state", region="ohio", fill=T, add=T) 
locator()
windows(h=6.5, w=6.5)
map("state", mar=c(1, 1, 1, 1), region= "ohio", col="darkgray", lwd=2)
for(i in seq(suv)) {
sel <- veg.class==suv[i]
points(lon.dd[sel], lat.dd[sel], cex=2, lwd=2, pch=c(2, 1)[i], col=group[sel]+1)
}
locator()
maps::map.scale(x=-81.9, y=38.7, ratio=FALSE, relwidth=0.2)
north.arrow(xb=-80.7, yb=39.2, len=0.05, lab="N")
locator()
map("state", mar=c(1, 1, 1, 1), region= "ohio", col="darkgray", lwd=2)
for(i in seq(suv)) {
sel <- veg.class==suv[i]
points(lon.dd[sel], lat.dd[sel], cex=2, lwd=2, pch=c(2, 1)[i], col=group[sel]+1)
}
maps::map.scale(x=-81.9, y=38.7, ratio=FALSE, relwidth=0.2)
north.arrow(xb=-81.2, yb=39, len=0.05, lab="N")
map("state", mar=c(1, 1, 1, 1), region= "ohio", col="darkgray", lwd=2)
for(i in seq(suv)) {
sel <- veg.class==suv[i]
points(lon.dd[sel], lat.dd[sel], cex=2, lwd=2, pch=c(2, 1)[i], col=group[sel]+1)
}
maps::map.scale(x=-81.8, y=38.7, ratio=FALSE, relwidth=0.2)
north.arrow(xb=-81.2, yb=39, len=0.05, lab="N")
map("state", mar=c(1, 1, 1, 1), region= "ohio", col="darkgray", lwd=2)
for(i in seq(suv)) {
sel <- veg.class==suv[i]
points(lon.dd[sel], lat.dd[sel], cex=2, lwd=2, pch=c(2, 1)[i], col=group[sel]+1)
}
par(xpd=NA)
maps::map.scale(x=-81.8, y=38.7, ratio=FALSE, relwidth=0.2)
north.arrow(xb=-81.2, yb=39, len=0.05, lab="N")
par(usr=c(-126, 94, 21, 193), xpd=NA)
polygon(c(-128, -128, -64, -64, -128), c(22, 52, 52, 22, 22), col="white", lwd=2)
map("state", add=T, mar=c(0, 0, 0, 0)) 
map("state", region="ohio", fill=T, add=T) 
graphics.off()
map("state", region= "ohio")
locator()
maps::map.scale(x=-84, y=40, ratio=FALSE, relwidth=0.2)
locator()
north.arrow(xb=-83.4, yb=40.2, len=0.05, lab="N")
north.arrow(xb=-83.4, yb=41, len=0.05, lab="N")
map("state", region= "ohio")
q()
?cheat
cleanup()
ls()
wb <- loadWorkbook("C:/JVA/Consult/Lantry/Wounding model/Mort funct2.xlsx")
raw <- readWorksheet(wb, sheet="StrainCPUE")
full <- readWorksheet(wb, sheet="SAS data")
warnings()
head(full)
head(full)
dim(full)
full[, 34:35]
full[, 34:36]
dim(full)
full[, 1:3]
dim(raw)
head(raw)
attach(raw)
summary(log(CPUE) - LnCPUE)
jvanames
jvanames(name(raw))
jvanames(names(raw))
names(raw) <- jvanames(names(raw))
names(full) <- jvanames(names(full))
head(raw)
search()
detach()
wb <- loadWorkbook("C:/JVA/Consult/Lantry/Wounding model/Mort funct2.xlsx")
raw <- readWorksheet(wb, sheet="StrainCPUE")
full <- readWorksheet(wb, sheet="SAS data")
names(raw) <- jvanames(names(raw))
names(full) <- jvanames(names(full))
head(raw)
  # xstrain strain2 year xyrcls age    lncpue       cpue
# 1     ONT SENlike 1990   1983   7 -2.768675 0.06274510
# 2     ONT SENlike 1991   1983   8 -2.610070 0.07352941
# 3     ONT SENlike 1992   1983   9 -3.396743 0.03348214
# 4     ONT SENlike 1993   1983  10 -4.158883 0.01562500
# 5     ONT SENlike 1991   1984   7 -0.255525 0.77450980
# 6     ONT SENlike 1992   1984   8 -1.142772 0.31893382
attach(raw)
summary(log(cpue) - lncpue)
raw1 <- raw
raw1$year1 <- year
raw1$year2 <- year + 1
raw1$age1 <- age
raw1$age2 <- age + 1
raw1$cpue1 <- cpue
raw2 <- raw
raw1$year1 <- year - 1
raw1$year2 <- year
raw1$age1 <- age - 1
raw1$age2 <- age
raw1$cpue2 <- cpue
names(raw1)
names(raw2)
raw1 <- raw
raw1$year1 <- year
raw1$year2 <- year + 1
raw1$age1 <- age
raw1$age2 <- age + 1
raw1$cpue1 <- cpue
raw2 <- raw
raw2$year1 <- year - 1
raw2$year2 <- year
raw2$age1 <- age - 1
raw2$age2 <- age
raw2$cpue2 <- cpue
names(raw1)
names(raw2)
dput(names(raw2))
rawpair <- merge(
raw1[, c("xstrain", "strain2", "xyrcls", "year1", "year2", "age1", "age2", "cpue1")],
raw2[, c("xstrain", "strain2", "xyrcls", "year1", "year2", "age1", "age2", "cpue2")]
all=TRUE
)
rawpair <- merge(
raw1[, c("xstrain", "strain2", "xyrcls", "year1", "year2", "age1", "age2", "cpue1")],
raw2[, c("xstrain", "strain2", "xyrcls", "year1", "year2", "age1", "age2", "cpue2")],
all=TRUE
)
dim(raw)
dim(rawpair)
head(rawpair)
rawpair <- rawpair[!is.na(rawpair$cpue1) & !is.na(rawpair$cpue2), ]
dim(rawpair)
rawpair
rawpair <- merge(
raw1[, c("year1", "year2", "strain2", "xstrain", "xyrcls", "age1", "age2", "cpue1")],
raw2[, c("year1", "year2", "strain2", "xstrain", "xyrcls", "age1", "age2", "cpue2")],
all=TRUE
)
rawpair <- rawpair[!is.na(rawpair$cpue1) & !is.na(rawpair$cpue2), ]
rawpair
rawpair$mort <- 1 - cpue2/cpue1
rawpair$mort <- 1 - rawpair$cpue2/rawpair$cpue1
rawpair
rawpair
detach(raw)
ls()
detach(raw)
rm(raw1, raw2)
raw[raw$year==1987, ]
rawpair[rawpair$year1==1987 | rawpair$year2==1987, ]
raw[raw$year %in% 1986:1988, ]
head(rawpair)
plotdf(raw)
raw[raw$lncpue < -5, ]
sort(raw$cpue)
plotdf(rawpair)
rawpair$mort0 <- ifelse(rawpair$mort < 0, 0, rawpair$mort)
plotdf(rawpair)
rawpair$year1f <- as.factor(rawpair$year1)
rawpair$strain2f <- as.factor(rawpair$strain2)
rawpair$xstrainf <- as.factor(rawpair$xstrain)
rawpair$xyrclsf <- as.factor(rawpair$xyrcls)
rawpair$age1f <- as.factor(rawpair$age1)
rawpair$mort0 <- ifelse(rawpair$mort < 0, 0, rawpair$mort)
fit3a <- glm(mort0 ~ year1f + xstrainf + xyrclsf, data=rawpair)
fit3b <- glm(mort0 ~ year1f + strain2f + xyrclsf, data=rawpair)
fit3c <- glm(mort0 ~ year1f + xstrainf + age1f, data=rawpair)
fit3d <- glm(mort0 ~ year1f + strain2f + age1f, data=rawpair)
fit2a <- glm(mort0 ~ year1f + xstrainf, data=rawpair)
fit2b <- glm(mort0 ~ year1f + strain2f, data=rawpair)
fit2c <- glm(mort0 ~ year1f + xstrainf, data=rawpair)
fit2d <- glm(mort0 ~ year1f + strain2f, data=rawpair)
fit2e <- glm(mort0 ~ year1f + xyrclsf, data=rawpair)
fit2f <- glm(mort0 ~ year1f + xyrclsf, data=rawpair)
fit2g <- glm(mort0 ~ year1f + age1f, data=rawpair)
fit2h <- glm(mort0 ~ year1f + age1f, data=rawpair)
fit1 <- glm(mort0 ~ year1f, data=rawpair)
fit0 <- glm(mort0 ~ 1, data=rawpair)
AICc(list(fit3a, fit3b, fit3c, fit3d, fit2a, fit2b, fit2c, fit2d, fit2e, fit2f, fit2g, fit2h, fit1, fit0))
?AICc
fit3a <- glm(mort0 ~ year1f + xstrainf + xyrclsf, data=rawpair)
fit3b <- glm(mort0 ~ year1f + strain2f + xyrclsf, data=rawpair)
fit3c <- glm(mort0 ~ year1f + xstrainf + age1f, data=rawpair)
fit3d <- glm(mort0 ~ year1f + strain2f + age1f, data=rawpair)
fit2a <- glm(mort0 ~ year1f + xstrainf, data=rawpair)
fit2b <- glm(mort0 ~ year1f + strain2f, data=rawpair)
fit2c <- glm(mort0 ~ year1f + xyrclsf, data=rawpair)
fit2d <- glm(mort0 ~ year1f + age1f, data=rawpair)
fit1 <- glm(mort0 ~ year1f, data=rawpair)
fit0 <- glm(mort0 ~ 1, data=rawpair)
AICc(list(fit3a, fit3b, fit3c, fit3d, fit2a, fit2b, fit2c, fit2d, fit1, fit0))
fit <- glm(mort0 ~ year1f + strain2f, data=rawpair)#### best model
?cheat
library(broom)
?broom
??broom
fit <- glm(mort0 ~ year1f + strain2f, data=rawpair)#### best model
fit
summary(fit)
tidy(fit)
augment(fit)
glance(fit)
fit <- aov(mort0 ~ year1f + strain2f, data=rawpair)#### best model
augment(fit)
fit
summary(fit)
tidy(fit)
glance(fit)
fit <- aov(mort0 ~ year1f + strain2f, data=rawpair)#### best model
augment(fit)
fit
summary(fit)
tidy(fit)
glance(fit)
?glance
?glance.aov
?glance.glm
fit <- aov(mort0 ~ year1f + strain2f, data=rawpair)#### best model
fit
summary(fit)
fit <- lm(mort0 ~ year1f + strain2f, data=rawpair)#### best model
fit
summary(fit)
plot(fit)
search()
attach(rawpair)
plot(year1, mort0, col=strain2f)
plot(year1, mort0, col=strain2f, las=1)
plot(jitter(year1), mort0, col=strain2f, xlab="Year 1", ylab="Annual mortality")
par(mar=c(4, 4, 1, 1), las=1)
plot(jitter(year1), mort0, col=strain2f, xlab="Year 1", ylab="Annual mortality")
fit <- aov(mort0 ~ year1f + strain2f, data=rawpair)#### best model
fit
summary(fit)
p <- augment(fit)
fit <- lm(mort0 ~ year1f + strain2f, data=rawpair)#### best model
fit
summary(fit)
p2 <- augment(fit)
p1
p
p
head(p)
head(p2)
sus <- sort(unique(strain2f))
seq_along(sus)
sus
search()
detach()
rawpair2 <- augment(fit)
attach(rawpair2)
sus <- sort(unique(strain2f))
windows()
par(mar=c(4, 4, 1, 1), las=1)
plot(jitter(year1), mort0, col=strain2f, xlab="Year 1", ylab="Annual mortality")
for(i in seq_along(sus)) {
sel <- strain2f == sus[i]
lines(year1[sel], mort0[sel], col=i)
}
par(mar=c(4, 4, 1, 1), las=1)
plot(jitter(year1f), mort0, col=strain2f, xlab="Year 1", ylab="Annual mortality")
for(i in seq_along(sus)) {
sel <- strain2f == sus[i]
lines(year1f[sel], mort0[sel], col=i)
}
rawpair2 <- cbind(rawpair, augment(fit))
rawpair2
detach()
attach(rawpair2)
sus <- sort(unique(strain2))
windows()
par(mar=c(4, 4, 1, 1), las=1)
plot(jitter(year1), mort0, col=strain2, xlab="Year 1", ylab="Annual mortality")
for(i in seq_along(sus)) {
sel <- strain2 == sus[i]
lines(year1[sel], mort0[sel], col=i)
}
par(mar=c(4, 4, 1, 1), las=1)
plot(jitter(year1), mort0, col=strain2f + 1, xlab="Year 1", ylab="Annual mortality")
for(i in seq_along(sus)) {
sel <- strain2 == sus[i]
lines(year1[sel], mort0[sel], col=i+1)
}
par(mar=c(4, 4, 1, 1), las=1)
plot(jitter(year1), mort0, col=as.numeric(strain2f) + 1, xlab="Year 1", ylab="Annual mortality")
for(i in seq_along(sus)) {
sel <- strain2 == sus[i]
lines(year1[sel], mort0[sel], col=i+1)
}
par(mar=c(4, 4, 1, 1), las=1)
plot(jitter(year1), mort0, col=as.numeric(strain2f) + 1, xlab="Year 1", ylab="Annual mortality")
for(i in seq_along(sus)) {
sel <- strain2 == sus[i]
lines(spline(year1[sel], mort0[sel]), col=i+1)
}
head(rawpair2)
par(mar=c(4, 4, 1, 1), las=1)
plot(jitter(year1), mort0, col=as.numeric(strain2f) + 1, xlab="Year 1", ylab="Annual mortality")
for(i in seq_along(sus)) {
sel <- strain2 == sus[i]
lines(spline(year1[sel], .fitted[sel]), col=i+1)
}
search()
detach()
attach(rawpair)
suy <- sort(unique(year1f))
sus <- sort(unique(strain2f))
newdata <- expand.grid(year1f=suy, strain2f=sus)
predict(fit, newdata=newdata)
predict(fit, newdata=newdata, se.fit=TRUE)
?predict
predict(fit, newdata=newdata, interval="confidence")
p <- predict(fit, newdata=newdata, interval="confidence")
class(p)
suy <- sort(unique(year1f))
sus <- sort(unique(strain2f))
newdata <- expand.grid(year1f=suy, strain2f=sus)
p <- as.data.frame(predict(fit, newdata=newdata, interval="confidence"))
windows()
par(mar=c(4, 4, 1, 1), las=1)
plot(jitter(year1), mort0, col=as.numeric(strain2f) + 1, xlab="Year 1", ylab="Annual mortality")
for(i in seq_along(sus)) {
sel <- newdata$strain2f == sus[i]
lines(spline(newdata$year1f[sel], p$fit[sel]), col=i+1)
}
newdata$year1f[sel]
p$fit[sel]
spline(newdata$year1f[sel], p$fit[sel])
as.numeric(newdata$year1f)
?factor
as.numeric(as.character(newdata$year1f))[sel]
par(mar=c(4, 4, 1, 1), las=1)
plot(jitter(year1), mort0, col=as.numeric(strain2f) + 1, xlab="Year 1", ylab="Annual mortality")
for(i in seq_along(sus)) {
sel <- newdata$strain2f == sus[i]
lines(spline(as.numeric(as.character(newdata$year1f))[sel], p$fit[sel]), col=i+1)
}
windows(w=9, h=3)
par(mar=c(4, 4, 1, 1), las=1)
plot(jitter(year1), mort0, col=as.numeric(strain2f) + 1, xlab="Year 1", ylab="Annual mortality")
for(i in seq_along(sus)) {
sel <- newdata$strain2f == sus[i]
lines(spline(as.numeric(as.character(newdata$year1f))[sel], p$fit[sel]), col=i+1)
}
args(spline)
par(mar=c(4, 4, 1, 1), las=1)
plot(jitter(year1), mort0, col=as.numeric(strain2f) + 1, xlab="Year 1", ylab="Annual mortality")
for(i in seq_along(sus)) {
sel <- newdata$strain2f == sus[i]
lines(spline(as.numeric(as.character(newdata$year1f))[sel], p$fit[sel], n=1000), col=i+1)
}
par(mar=c(4, 4, 1, 1), las=1)
plot(jitter(year1), mort0, col=as.numeric(strain2f) + 1, xlab="Year t", ylab="Annual mortality (from year t to year t+1)")
for(i in seq_along(sus)) {
sel <- newdata$strain2f == sus[i]
lines(spline(as.numeric(as.character(newdata$year1f))[sel], p$fit[sel], n=1000), col=i+1)
}
par(mar=c(4, 4, 1, 1), las=1)
plot(jitter(year1), mort0, col=as.numeric(strain2f) + 1, xlab="Year t", ylab="Annual mortality (from year t to t+1)")
for(i in seq_along(sus)) {
sel <- newdata$strain2f == sus[i]
lines(spline(as.numeric(as.character(newdata$year1f))[sel], p$fit[sel], n=1000), col=i+1)
}
par(mar=c(4, 4, 1, 1), las=1)
plot(jitter(year1), mort0, col=as.numeric(strain2f) + 1, xlab="Year t", ylab="Annual mortality (from t to t+1)")
for(i in seq_along(sus)) {
sel <- newdata$strain2f == sus[i]
lines(spline(as.numeric(as.character(newdata$year1f))[sel], p$fit[sel], n=1000), col=i+1)
}
par(mar=c(4, 4, 1, 1), las=1)
plot(jitter(year1), mort0, col=as.numeric(strain2f) + 1, pch=as.numeric(strain2f), xlab="Year t", ylab="Annual mortality  (from t to t+1)")
for(i in seq_along(sus)) {
sel <- newdata$strain2f == sus[i]
lines(spline(as.numeric(as.character(newdata$year1f))[sel], p$fit[sel], n=1000), col=i+1)
}
par(mar=c(4, 4, 1, 1), las=1)
plot(jitter(year1), mort0, col=blindcolz[as.numeric(strain2f)], pch=as.numeric(strain2f), xlab="Year t", ylab="Annual mortality  (from t to t+1)")
for(i in seq_along(sus)) {
sel <- newdata$strain2f == sus[i]
lines(spline(as.numeric(as.character(newdata$year1f))[sel], p$fit[sel], n=1000), col=i+1)
}
par(mar=c(4, 4, 1, 1), las=1)
plot(jitter(year1), mort0, col=blindcolz[as.numeric(strain2f)+1], pch=as.numeric(strain2f), xlab="Year t", ylab="Annual mortality  (from t to t+1)")
for(i in seq_along(sus)) {
sel <- newdata$strain2f == sus[i]
lines(spline(as.numeric(as.character(newdata$year1f))[sel], p$fit[sel], n=1000), col=i+1)
}
par(mar=c(4, 4, 1, 1), las=1)
plot(jitter(year1), mort0, col=blindcolz[as.numeric(strain2f)+1], pch=as.numeric(strain2f), xlab="Year t", ylab="Annual mortality  (from t to t+1)")
for(i in seq_along(sus)) {
sel <- newdata$strain2f == sus[i]
lines(spline(as.numeric(as.character(newdata$year1f))[sel], p$fit[sel], n=1000), col=blindcolz[i+1])
}
sus
par(mar=c(4, 4, 1, 1), las=1)
plot(jitter(year1), mort0, col=blindcolz[as.numeric(strain2f)+1], pch=substring(strain2f, 3, 1), xlab="Year t", ylab="Annual mortality  (from t to t+1)")
for(i in seq_along(sus)) {
sel <- newdata$strain2f == sus[i]
lines(spline(as.numeric(as.character(newdata$year1f))[sel], p$fit[sel], n=1000), col=blindcolz[i+1])
}
substring(strain2f, 3, 1)
substring(strain2, 3, 1)
strain2
substring(strain2, 3, 4)
substring(strain2, 3)
substring(strain2, 3, 3)
substring(strain2f, 3, 3)
windows(w=9, h=3)
par(mar=c(4, 4, 1, 1), las=1)
plot(jitter(year1), mort0, col=blindcolz[as.numeric(strain2f)+1], pch=substring(strain2f, 3, 3), xlab="Year t", ylab="Annual mortality  (from t to t+1)")
for(i in seq_along(sus)) {
sel <- newdata$strain2f == sus[i]
lines(spline(as.numeric(as.character(newdata$year1f))[sel], p$fit[sel], n=1000), col=blindcolz[i+1])
}
par(mar=c(4, 4, 1, 1), las=1)
plot(year1, mort0, type="n", xlab="Year t", ylab="Annual mortality  (from t to t+1)")
text(jitter(year1), mort0, substring(strain2f, 3, 3), col=blindcolz[as.numeric(strain2f)+1], cex=0.8)
for(i in seq_along(sus)) {
sel <- newdata$strain2f == sus[i]
lines(spline(as.numeric(as.character(newdata$year1f))[sel], p$fit[sel], n=1000), col=blindcolz[i+1])
}
par(mar=c(4, 4, 1, 1), las=1)
plot(year1, mort0, type="n", ylim=0:1, xlab="Year t", ylab="Annual mortality  (from t to t+1)")
text(jitter(year1), mort0, substring(strain2f, 3, 3), col=blindcolz[as.numeric(strain2f)+1], cex=0.8)
for(i in seq_along(sus)) {
sel <- newdata$strain2f == sus[i]
lines(spline(as.numeric(as.character(newdata$year1f))[sel], p$fit[sel], n=1000), col=blindcolz[i+1])
}
par(mar=c(4, 4, 1, 1), las=1)
plot(year1, mort0, type="n", ylim=0:1, xlab="Year t", ylab="Annual mortality  (from t to t+1)")
text(jitter(year1), mort0, substring(strain2f, 3, 3), col=blindcolz[as.numeric(strain2f)+1], cex=0.8)
for(i in seq_along(sus)) {
sel <- newdata$strain2f == sus[i]
lines(spline(as.numeric(as.character(newdata$year1f))[sel], p$fit[sel], n=1000), col=blindcolz[i+1], lwd=2)
}
search()
ls(5)
?shadepoly
x <- 1:10
y <- sample(10)
noise <- abs(rnorm(10))
plot(x, y, ylim=range(y-noise, y+noise), type="n")
shadepoly(x, y, y-noise, y+noise)
head(p)
for(i in seq_along(sus)) {
windows(w=9, h=3)
par(mar=c(4, 4, 1, 1), las=1)
plot(year1, mort0, type="n", ylim=0:1, xlab="Year t", ylab="Annual mortality  (from t to t+1)")
sel <- newdata$strain2f == sus[i]
shadepoly(as.numeric(as.character(newdata$year1f)), p$fit, p$lwr, p$upr, subsel=sel, kol=blindcolz[i+1])
}
windows(w=9, h=3)
par(mar=c(4, 4, 1, 1), las=1)
plot(year1, mort0, type="n", ylim=0:1, xlab="Year t", ylab="Annual mortality  (from t to t+1)")
for(i in seq_along(sus)) {
sel <- newdata$strain2f == sus[i]
shadepoly(as.numeric(as.character(newdata$year1f)), p$fit, p$lwr, p$upr, subsel=sel, kol=blindcolz[i+1])
}
head(raw)
head(rawpair)
dput(names(rawpair))
aggregate(rawpair[, c("cpue1", "cpue2")] ~ rawpair[, c("year1", "year2", "strain2", "xyrcls", "age1", "age2", "year1f", "strain2f", "xyrclsf", "age1f")])
?aggregate
aggregate(cbind(cpue1, cpue2) ~ year1 + year2 + strain2 + xyrcls + age1 + age2 + year1f + strain2f + xyrclsf + age1f, rawpair)
aggregate(cbind(cpue1, cpue2) ~ year1 + year2 + strain2 + xyrcls + age1 + age2 + year1f + strain2f + xyrclsf + age1f, rawpair, sum)
ssum <- aggregate(cbind(cpue1, cpue2) ~ year1 + year2 + strain2 + xyrcls + age1 + age2 + year1f + strain2f + xyrclsf + age1f, rawpair, sum)
ssum
dim(ssum)
ssum <- aggregate(cbind(cpue1, cpue2) ~ year1 + year2 + strain2 + xyrcls + age1 + age2 + year1f + strain2f + xyrclsf + age1f, rawpair, sum)
ssum$mort <- 1 - ssum$cpue2/ssum$cpue1
ssum$mort0 <- ifelse(ssum$mort < 0, 0, ssum$mort)
head(ssum)
# summarize data across strains within strain groups
ssum <- aggregate(cbind(cpue1, cpue2) ~ year1 + year2 + strain2 + xyrcls + age1 + age2 + year1f + strain2f + xyrclsf + age1f, rawpair, sum)
ssum$mort <- 1 - ssum$cpue2/ssum$cpue1
ssum$mort0 <- ifelse(ssum$mort < 0, 0, ssum$mort)
head(ssum)
fit <- aov(mort0 ~ year1f + strain2f, data=ssum)
fit
summary(fit)
fit <- lm(mort0 ~ year1f + strain2f, data=ssum)
fit
summary(fit)
?summary(lm)
?summary.lm
search()
detach()
detach()
search()
attach(ssum)
suy <- sort(unique(year1f))
sus <- sort(unique(strain2f))
newdata <- expand.grid(year1f=suy, strain2f=sus)
p <- as.data.frame(predict(fit, newdata=newdata, interval="confidence"))
p
windows(w=9, h=3)
par(mar=c(4, 4, 1, 1), las=1)
plot(year1, mort0, type="n", ylim=0:1, xlab="Year t", ylab="Annual mortality  (from t to t+1)")
text(jitter(year1), mort0, substring(strain2f, 3, 3), col=blindcolz[as.numeric(strain2f)+1], cex=0.8)
for(i in seq_along(sus)) {
sel <- newdata$strain2f == sus[i]
lines(spline(as.numeric(as.character(newdata$year1f))[sel], p$fit[sel], n=1000), col=blindcolz[i+1], lwd=2)
}
dim(ssum)
dim(p)
dim(newdata)
p
newdata
a <- cbind(newdata, predict(fit, newdata=newdata, interval="confidence"))
class(a)
a
newdata <- expand.grid(year1f=suy, strain2f=sus)
p <- cbind(newdata, predict(fit, newdata=newdata, interval="confidence"))
windows(w=9, h=3)
par(mar=c(4, 4, 1, 1), las=1)
plot(year1, mort0, type="n", ylim=0:1, xlab="Year t", ylab="Annual mortality  (from t to t+1)")
text(jitter(year1), mort0, substring(strain2f, 3, 3), col=blindcolz[as.numeric(strain2f)+1], cex=0.8)
for(i in seq_along(sus)) {
sel <- p$strain2f == sus[i]
lines(spline(as.numeric(as.character(p$year1f))[sel], p$fit[sel], n=1000), col=blindcolz[i+1], lwd=2)
}
windows(w=9, h=3)
par(mar=c(4, 4, 1, 1), las=1)
plot(year1, mort0, type="n", ylim=0:1, xlab="Year t", ylab="Annual mortality  (from t to t+1)")
for(i in seq_along(sus)) {
sel <- p$strain2f == sus[i]
shadepoly(as.numeric(as.character(p$year1f)), p$fit, p$lwr, p$upr, subsel=sel, kol=blindcolz[i+1])
}
search()
graphics.off()
suy <- sort(unique(year1f))
sus <- sort(unique(strain2f))
newdata <- expand.grid(year1f=suy, strain2f=sus)
p <- cbind(newdata, predict(fit, newdata=newdata, interval="confidence"))
windows(w=9, h=3)
par(mar=c(4, 4, 1, 1), las=1)
plot(year1, mort0, type="n", ylim=0:1, xlab="Year t", ylab="Annual mortality  (from t to t+1)")
text(jitter(year1), mort0, substring(strain2f, 3, 3), col=blindcolz[as.numeric(strain2f)+1], cex=0.8)
for(i in seq_along(sus)) {
sel <- p$strain2f == sus[i]
lines(spline(as.numeric(as.character(p$year1f))[sel], p$fit[sel], n=1000), col=blindcolz[i+1], lwd=2)
}
for(i in seq_along(sus)) {
windows(w=9, h=3)
par(mar=c(4, 4, 1, 1), las=1)
plot(year1, mort0, type="n", ylim=0:1, xlab="Year t", ylab="Annual mortality  (from t to t+1)")
sel <- p$strain2f == sus[i]
shadepoly(as.numeric(as.character(p$year1f)), p$fit, p$lwr, p$upr, subsel=sel, kol=blindcolz[i+1])
}
head(p)
p[sel, ]
dim(p[sel, ])
1985+27
sub$fit[-dim(sub)[1]]
sub <- p[sel, ]
sub$fit[-dim(sub)[1]]
sub$fit[-1]
windows()
plot(sub$fit[-dim(sub)[1]], sub$fit[-1])
par(mar=c(4, 4, 1, 1), las=1)
plot(sub$fit[-dim(sub)[1]], sub$fit[-1], xlab="Predicted mortality in year t", ylab="Predicted mortality in year t+1")
abline(lsfit(sub$fit[-dim(sub)[1]], sub$fit[-1]))
par(mar=c(4, 4, 1, 1), las=1, cex=1.5)
plot(sub$fit[-dim(sub)[1]], sub$fit[-1], xlab="Predicted mortality in year t", ylab="Predicted mortality in year t+1")
abline(lsfit(sub$fit[-dim(sub)[1]], sub$fit[-1]))
par(mar=c(4, 4, 1, 1), las=1, cex=1.5)
plot(sub$fit[-dim(sub)[1]], sub$fit[-1], xlab="Predicted mortality in year t", ylab="Predicted mortality in year t+1")
abline(lsfit(sub$fit[-dim(sub)[1]], sub$fit[-1]), lwd=2)
x <- sub$fit[-dim(sub)[1]]
y <- sub$fit[-1]
cor.test(x, y)
cor.test(x, y)$cor
names(cor.test(x, y))
cor.test(x, y)$statistic
cor.test(x, y)$parameter
cor.test(x, y)$estimate
sub <- p[sel, ]
x <- sub$fit[-dim(sub)[1]]
y <- sub$fit[-1]
cor.test(x, y)
windows()
par(mar=c(4, 4, 1, 1), las=1, cex=1.5)
plot(x, y, xlab="Predicted mortality in year t", ylab="Predicted mortality in year t+1")
abline(lsfit(x, y), lwd=2)
text("topright", round(cor.test(x, y)$estimate, 2))
?xy.coords
xy.coords("topright")
?legend
legend
sub <- p[sel, ]
x <- sub$fit[-dim(sub)[1]]
y <- sub$fit[-1]
cor.test(x, y)
windows()
par(mar=c(4, 4, 1, 1), las=1, cex=1.5)
plot(x, y, xlab="Predicted mortality in year t", ylab="Predicted mortality in year t+1")
abline(lsfit(x, y), lwd=2)
text(0.8, 0.8, round(cor.test(x, y)$estimate, 2))
par(mar=c(4, 4, 1, 1), las=1, cex=1.5)
plot(x, y, xlab="Predicted mortality in year t", ylab="Predicted mortality in year t+1")
abline(lsfit(x, y), lwd=2)
text(0.8, 0.8, paste("r =", round(cor.test(x, y)$estimate, 2)))
par(mar=c(4, 4, 1, 1), las=1, cex=1.5)
eqscplot(x, y, xlab="Predicted mortality in year t", ylab="Predicted mortality in year t+1")
abline(lsfit(x, y), lwd=2)
text(0.8, 0.8, paste("r =", round(cor.test(x, y)$estimate, 2)))
par(mar=c(4, 4, 1, 1), las=1, cex=1.5)
eqscplot(x, y, xlim=0:1, ylim=0:1, xlab="Predicted mortality in year t", ylab="Predicted mortality in year t+1")
abline(lsfit(x, y), lwd=2)
text(0.8, 0.8, paste("r =", round(cor.test(x, y)$estimate, 2)))
par(mar=c(4, 4, 1, 1), las=1, cex=1.5, xaxs="i", yaxs="i")
eqscplot(x, y, xlim=0:1, ylim=0:1, xlab="Predicted mortality in year t", ylab="Predicted mortality in year t+1")
abline(lsfit(x, y), lwd=2)
text(0.8, 0.8, paste("r =", round(cor.test(x, y)$estimate, 2)))
windows()
par(mar=c(4, 4, 1, 1), las=1, cex=1.5, xaxs="i", yaxs="i")
eqscplot(x, y, xlim=0:1, ylim=0:1, xlab="Predicted mortality in year t", ylab="Predicted mortality in year t+1")
abline(lsfit(x, y), lwd=2)
text(0.8, 0.8, paste("r =", round(cor.test(x, y)$estimate, 2)))
?par
windows()
par(mar=c(4, 4, 1, 1), las=1, cex=1.5, xaxs="i", yaxs="i", pty="s")
plot(x, y, xlim=0:1, ylim=0:1, xlab="Predicted mortality in year t", ylab="Predicted mortality in year t+1")
abline(lsfit(x, y), lwd=2)
text(0.8, 0.8, paste("r =", round(cor.test(x, y)$estimate, 2)))
sub
windows()
par(mar=c(4, 4, 2, 1), las=1, cex=1.5, xaxs="i", yaxs="i", pty="s")
plot(x, y, xlim=0:1, ylim=0:1, xlab="Predicted mortality in year t", ylab="Predicted mortality in year t+1", main="Superior-like Strains")
abline(lsfit(x, y), lwd=2)
text(0.8, 0.8, paste("r =", round(cor.test(x, y)$estimate, 2)))
windows(w=6.5, h=7)
par(mar=c(4, 4, 2, 1), las=1, cex=1.5, xaxs="i", yaxs="i", pty="s")
plot(x, y, xlim=0:1, ylim=0:1, xlab="Predicted mortality in year t", ylab="Predicted mortality in year t+1", main="Superior-like Strains")
abline(lsfit(x, y), lwd=2)
text(0.8, 0.8, paste("r =", round(cor.test(x, y)$estimate, 2)))
windows()
p
head(full)
head(full)
search()
ls(4)
stringin
stringin("mort", names(full))
?stringin
txt <- c("The", "licenses", "for", "most", "software", "are", "designed",
"to", "take", "away", "your", "freedom", "to", "share", "and", "change",
"it.", "", "By", "contrast,", "the", "GNU", "General", "Public", "License",
"is", "intended", "to", "guarantee", "your", "freedom", "to", "share", "and",
"change", "free", "software", "--", "to", "make", "sure", "the", "software",
"is", "free", "for", "all", "its", "users.")
stringin("b", txt)
stringin("ar", txt)
stringin <- function(pattern, x, igncase=TRUE, value=TRUE, fixed=TRUE, ...) {
grep(pattern, x, ignore.case=igncase, value=value, fixed=fixed, ...)
}
stringin("b", txt)
stringin("ar", txt)
?grep
grep
stringin <- function(pattern, x, ignore.case=TRUE, value=TRUE, fixed=TRUE, ...) {
grep(pattern, x, ignore.case, value, fixed, ...)
}
stringin("b", txt)
stringin("ar", txt)
stringin <- function(pattern, x, ignore.case=TRUE, value=TRUE, fixed=TRUE, ...) {
grep(pattern, x, ignore.case, value, fixed, ...)
}
?stringin
txt <- c("The", "licenses", "for", "most", "software", "are", "designed",
"to", "take", "away", "your", "freedom", "to", "share", "and", "change",
"it.", "", "By", "contrast,", "the", "GNU", "General", "Public", "License",
"is", "intended", "to", "guarantee", "your", "freedom", "to", "share", "and",
"change", "free", "software", "--", "to", "make", "sure", "the", "software",
"is", "free", "for", "all", "its", "users.")
stringin("b", txt)
stringin("ar", txt)
stringin("mort", names(full))
?cheat
pkgup("jvamisc")
q()
