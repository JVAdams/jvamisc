dat[obs %in% obs[duplicated(obs)], ]
search()
detach()
dat <- read.csv("C:/JVA/Consult/Kraus/Gill net walleye/GLIMMIX_alldata_commonmeshes (1).txt", sep="",
header=FALSE, col.names=c("year", "type", "mesh", "we", "holes", "catch", "secchi", "site", "serial"))
# site is a "block" effect representing the "pair" ... both location and year information
# mesh is a covariate
# type is a factor
dat <- dat[order(dat$year, dat$site, dat$type, dat$mesh), ]
attach(dat)
obs <- interaction(year, site, type, mesh)
dat[obs %in% obs[duplicated(obs)], ]
head(dat)
dat[obs %in% obs[duplicated(obs)], c("year", "site", "type", "mesh", "serial", "secchi", "catch", "holes", "we")]
table(site, year)
a <- table(site, year)
apply(a>0, 1, sum)
sort(apply(a>0, 1, sum))
dat$accum <- 100*catch/holes
dat$water <- cut(secchi, c(0, 1, 2, 4), right=FALSE, labels=FALSE)
dat$typef <- as.factor(type)
dat$sitef <- as.factor(site)
fit <- gam(we ~ typef + sitef + s(mesh, k=5) + s(secchi, k=5), data=dat)
summary(fit)
plot(fit, all.terms=TRUE)
fit <- glm(we ~ typef + sitef + poly(mesh, 2) + secchi, data=dat)
summary(fit)
fit <- aov(we ~ typef + sitef + poly(mesh, 2) + secchi, data=dat)
summary(fit)
fit <- aov(we ~ sitef + poly(mesh, 2) + secchi*typef, data=dat)
summary(fit)
fit <- aov(we ~ sitef + poly(mesh, 2) + secchi + typef, data=dat)
summary(fit)
plot(fit)
summary(we)
fit <- aov(sqrt(we) ~ sitef + poly(mesh, 2) + secchi + typef, data=dat)
summary(fit)
plot(fit)
plot(predict(fit), resid(fit))
windows()
par(mfrow=c(3, 2))
plot(predict(fit), resid(fit))
plot(sitef, resid(fit))
plot(mesh, resid(fit))
plot(secchi, resid(fit))
plot(typef, resid(fit))
detach(dat)
attach(dat)
windows()
par(mfrow=c(3, 2))
plot(predict(fit), resid(fit))
plot(sitef, resid(fit))
plot(mesh, resid(fit))
plot(secchi, resid(fit))
plot(typef, resid(fit))
windows()
par(mfrow=c(3, 2), mar=c(4, 4, 1, 1))
plot(predict(fit), predict(fit))
plot(sitef, predict(fit))
plot(mesh, predict(fit))
plot(secchi, predict(fit))
plot(typef, predict(fit))
par(mfrow=c(3, 2), mar=c(4, 4, 1, 1))
plot(predict(fit), predict(fit))
plot(sitef, predict(fit))
plot(jitter(mesh), predict(fit))
plot(jitter(secchi), predict(fit))
plot(typef, predict(fit))
par(mfrow=c(2, 3), mar=c(4, 4, 1, 1))
plot(sqrt(we), predict(fit))
plot(sitef, predict(fit))
plot(jitter(mesh), predict(fit))
plot(jitter(secchi), predict(fit))
plot(typef, predict(fit))
par(mfrow=c(2, 3), mar=c(4, 4, 1, 1))
plot(sqrt(we), predict(fit))
lines(loess.smooth(sqrt(we), predict(fit)))
plot(sitef, predict(fit))
plot(jitter(mesh), predict(fit))
lines(loess.smooth(mesh, predict(fit)))
plot(jitter(secchi), predict(fit))
lines(loess.smooth(secchi, predict(fit)))
plot(typef, predict(fit))
par(mfrow=c(2, 3), mar=c(4, 4, 1, 1))
plot(sqrt(we), predict(fit))
lines(loess.smooth(sqrt(we), predict(fit)), lwd=2, col="red")
plot(sitef, predict(fit))
plot(jitter(mesh), predict(fit))
lines(loess.smooth(mesh, predict(fit)), lwd=2, col="red")
plot(jitter(secchi), predict(fit))
lines(loess.smooth(secchi, predict(fit)), lwd=2, col="red")
plot(typef, predict(fit))
fit <- aov(sqrt(we) ~ sitef + poly(mesh, 2) + poly(secchi, 2) + typef, data=dat)
summary(fit)
windows()
par(mfrow=c(2, 3), mar=c(4, 4, 1, 1))
plot(predict(fit), resid(fit))
plot(sitef, resid(fit))
plot(mesh, resid(fit))
plot(secchi, resid(fit))
plot(typef, resid(fit))
graphics.off()
windows()
par(mfrow=c(2, 3), mar=c(4, 4, 1, 1))
plot(predict(fit), resid(fit))
abline(h=0, lwd=2, col="red")
plot(sitef, resid(fit))
abline(h=0, lwd=2, col="red")
plot(jitter(mesh), resid(fit))
abline(h=0, lwd=2, col="red")
plot(jitter(secchi), resid(fit))
abline(h=0, lwd=2, col="red")
plot(typef, resid(fit))
abline(h=0, lwd=2, col="red")
windows()
par(mfrow=c(2, 3), mar=c(4, 4, 1, 1))
plot(sqrt(we), predict(fit))
lines(loess.smooth(sqrt(we), predict(fit)), lwd=2, col="red")
plot(sitef, predict(fit))
plot(jitter(mesh), predict(fit))
lines(loess.smooth(mesh, predict(fit)), lwd=2, col="red")
plot(jitter(secchi), predict(fit))
lines(loess.smooth(secchi, predict(fit)), lwd=2, col="red")
plot(typef, predict(fit))
head(dat)
windows()
par(mfrow=c(2, 3), mar=c(4, 4, 1, 1))
plot(as.factor(year), resid(fit))
plot(sqrt(catch), resid(fit))
plot(serial, resid(fit))
plot(accum, resid(fit))
par(mfrow=c(2, 2), mar=c(4, 4, 1, 1))
plot(as.factor(year), resid(fit))
abline(h=0, lwd=2, col="red")
plot(sqrt(catch), resid(fit))
abline(h=0, lwd=2, col="red")
plot(sqrt(accum), resid(fit))
abline(h=0, lwd=2, col="red")
par(mfrow=c(2, 2), mar=c(4, 4, 1, 1))
plot(as.factor(year), resid(fit))
abline(h=0, lwd=2, col="red")
plot(sqrt(catch), resid(fit))
lines(loess.smooth(sqrt(catch), resid(fit)), lwd=2, col="cyan")
abline(h=0, lwd=2, col="red")
plot(sqrt(accum), resid(fit))
lines(loess.smooth(sqrt(accum), resid(fit)), lwd=2, col="cyan")
abline(h=0, lwd=2, col="red")
windows()
par(mfrow=c(2, 3), mar=c(4, 4, 1, 1))
plot(predict(fit), resid(fit))
abline(h=0, lwd=2, col="red")
plot(sqrt(we), resid(fit))
lines(loess.smooth(sqrt(we), resid(fit)), lwd=2, col="cyan")
abline(h=0, lwd=2, col="red")
plot(sitef, resid(fit))
abline(h=0, lwd=2, col="red")
plot(jitter(mesh), resid(fit))
abline(h=0, lwd=2, col="red")
plot(jitter(secchi), resid(fit))
abline(h=0, lwd=2, col="red")
plot(typef, resid(fit))
abline(h=0, lwd=2, col="red")
q()
# C:\JVA\Lamprey\Adults\AdultIndex\2014\AdultIndex v2.r
{ # functions
# the following seven plot.table related function are from the Systmatic Investor Toolbox
# load Systematic Investor Toolbox
# require(RCurl)
# sit = getURLContent("https://github.com/systematicinvestor/SIT/raw/master/sit.gz", binary=TRUE, followlocation=TRUE, ssl.verifypeer=FALSE)
# con = gzcon(rawConnection(sit, "rb"))
# source(con)
# close(con)
draw.cell <- function(title, r, c, text.cex = 1, bg.col = 'white', frame.cell = T) {
if(!frame.cell) bcol = bg.col else bcol = 'black'
rect((2*(c - 1) + .5), -(r - .5), (2*c + .5), -(r + .5), col = bg.col, border = bcol)
if( c == 1) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else if( r == 1 ) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else {
text((2*c + .5), -r, title, adj = 1, cex = text.cex)
}
}
plot.table.helper.auto.adjust.cex <- function(temp.table, keep.all.same.cex = FALSE) {
nr = nrow(temp.table)
nc = ncol(temp.table)
all.xrange = diff(par()$usr[1:2]) / nc
xrange = matrix( strwidth(paste('  ', temp.table), units = 'user', cex = 1), nc = nc)
all.yrange = diff(par()$usr[3:4]) / nr
yrange = matrix( 5/3 * strheight(temp.table, units = 'user', cex = 1), nc = nc)
plot.matrix.cex = pmin( round(all.yrange / yrange, 2) , round(all.xrange / xrange, 2) )
header.col.cex = min(plot.matrix.cex[1,-1])
header.row.cex = min(plot.matrix.cex[-1,1])
title.cex = plot.matrix.cex[1, 1]
data.cex = min(plot.matrix.cex[-1, -1])
if ( keep.all.same.cex ) {
plot.matrix.cex[] = min(plot.matrix.cex)
} else {
plot.matrix.cex[1,-1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,-1]= min(c(header.col.cex, header.row.cex, data.cex))
plot.matrix.cex[1,1]= min(c(header.col.cex, header.row.cex, data.cex, title.cex))
plot.matrix.cex[1,-1] = min(c(header.col.cex))
plot.matrix.cex[-1,1] = min(c(header.row.cex))
plot.matrix.cex[-1,-1]= min(c(data.cex))
plot.matrix.cex[1,1]= min(c(title.cex))
}
return(plot.matrix.cex)
}
make.table <- function(nr, nc) {
savepar = par(mar = rep(1, 4))
plot(c(0.5, nc*2 + 0.5), c(-0.5, -(nr + 0.5)), xaxs = 'i', yaxs = 'i',
type = 'n', xlab = '', ylab = '', axes = FALSE)
savepar
}
trim <- function(s) {
s = sub(pattern = '^ +', replacement = '', x = s)
s = sub(pattern = ' +$', replacement = '', x = s)
return(s)
}
plot.table.param <- function(plot.matrix, smain = '', plot.matrix.cex, plot.matrix_bg.col, frame.cell = T, keep.all.same.cex = FALSE) {
n = nrow(plot.matrix)
pages = unique(c(seq(0, n, by = 120), n))
for(p in 1:(length(pages)-1)) {
rindex = (pages[p]+1) : pages[p+1]
temp.table = matrix('', nr = length(rindex)+1, nc = ncol(plot.matrix)+1)
temp.table[-1, -1] = plot.matrix[rindex,]
temp.table[1, -1] = colnames(plot.matrix)
temp.table[-1, 1] = rownames(plot.matrix)[rindex]
temp.table[1, 1] = smain
nr = nrow(temp.table)
nc = ncol(temp.table)
par(mar = c(0, 0, 0, 0), cex = 0.5)
oldpar = make.table(nr, nc)
text.cex = plot.matrix.cex[c(1, 1 + rindex), ]
text.cex = plot.table.helper.auto.adjust.cex(temp.table, keep.all.same.cex)
bg.col = plot.matrix_bg.col[c(1, 1 + rindex), ]
for(r in 1:nr) {
for(c in 1:nc) {
draw.cell( paste('', temp.table[r,c], '', sep=' '), r, c,
text.cex = text.cex[r,c], bg.col = bg.col[r,c], frame.cell = frame.cell)
}}
}
}
plot.table <- function(plot.matrix, smain="", text.cex=1, frame.cell=TRUE, highlight=FALSE, colorbar=FALSE, keep_all.same.cex=FALSE) {
if( is.null(rownames(plot.matrix)) & is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
if( ncol(temp.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[-1, -1, drop = FALSE]
colnames(plot.matrix) = temp.matrix[1, -1]
rownames(plot.matrix) = temp.matrix[-1, 1]
smain = temp.matrix[1, 1]
} else if( is.null(rownames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( ncol(plot.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[, -1, drop = FALSE]
colnames(plot.matrix) = colnames(temp.matrix)[-1]
rownames(plot.matrix) = temp.matrix[,1]
smain = colnames(temp.matrix)[1]
} else if( is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
plot.matrix = temp.matrix[-1, , drop = FALSE]
rownames(plot.matrix) = rownames(temp.matrix)[-1]
colnames(plot.matrix) = temp.matrix[1, ]
smain = rownames(temp.matrix)[1]
}
plot.matrix[which(trim(plot.matrix) == "NA")] = ""
plot.matrix[which(trim(plot.matrix) == "NA%")] = ""
plot.matrix[which(is.na(plot.matrix))] = ""
nr = nrow(plot.matrix) + 1
nc = ncol(plot.matrix) + 1
is_highlight = TRUE
if(is.logical(highlight)) {
is_highlight = highlight
if(highlight) highlight = plot.table.helper.color(plot.matrix)
}
if(!is_highlight) {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[seq(1, nr, 2), ] = "yellow"
plot.matrix_bg.col[1,] = "gray";
plot.table.param( plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
} else {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[1,] = "gray"
plot.matrix_bg.col[2:nr,2:nc] = highlight
plot.table.param(plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
}
}
plot.table.helper.color <- function (temp) {
temp = matrix(as.double(gsub("[%,$]", "", temp)), nrow(temp), ncol(temp))
highlight = as.vector(temp)
cols = rep(NA, length(highlight))
ncols = length(highlight[!is.na(highlight)])
cols[1:ncols] = rev(rainbow(ncols, start=0.5/6, end=3.5/6))
o = sort.list(highlight, na.last = TRUE, decreasing = FALSE)
o1 = sort.list(o, na.last = TRUE, decreasing = FALSE)
highlight = matrix(cols[o1], nrow = nrow(temp))
highlight[is.na(temp)] = NA
return(highlight)
}
ModelEst <- function(fit, df) {
# derive regression estimates from log(y) fit
mse <- rev(as.matrix(summary(fit)[[1]])[, "Mean Sq"])[1]
plpe <- predict(fit, newdata=df, se.fit=T)
m <- plpe$fit
v <- plpe$se.fit^2 + mse
exp(m + v/2)
}
myrange <- function(x) {
if(all(is.na(x))) r <- c(NA, NA) else r <- range(x, na.rm=TRUE)
return(r)
}
jackindex <- function(m) {
# m is a matrix of numbers (stream PEs) with observations (years) as rows and individuals (streams) as columns
if(any(is.na(m))) stop("The input matrix may not have any missing values.")
# calculate the index as the sum of the columns for each row
rowsum <- apply(m, 1, sum)
# calculate the mean of the index
avgind <- mean(rowsum)
# recalculate the index, leaving out one individual at a time
loo <- apply(m, 2, function(column) (rowsum - column))
# rescale the loo index, relative to mean
looscaled <- apply(loo, 2, function(x) x/mean(x))
# convert to original scale
looscaled2 <- looscaled * avgind
# calculate range
ranges <- t(apply(looscaled2, 1, range))
cbind(index=rowsum, lo=ranges[, 1], hi=ranges[, 2])
}
# selstreams <- index.streams[[1]]
# allstreamdf <- dat
# alllakedf <- lk
# min.nmr=2
# show=FALSE
index.est <- function(selstreams, allstreamdf, alllakedf, min.nmr=2, show=FALSE) {
# INDEX OF ADULT SEA LAMPREY ABUNDANCE
### INPUTS
# selstreams = vector of stream ids, e.g., 1.064 (lake + strcode/1000)
# allstreamdf = data frame of mark-recap estimates for all streams, with vars:  year lake ls Emr CVmr
# alllakedf = data frame of lake-wide PEs from Mullett et al. (2003) spawner model with vars:  lake year PE
# min.nmr = minimum number of mark-recapture estimates needed in a year to generate an index, default 2
# show = print out a brief summary of the results, default FALSE
### OUTPUTS
# indfit = simple model used to predict missing mark-recap estimates
# streamdf = original allstreamdf, subsetted by selstreams, with estimates for missing mark-recaps
# indxdf = original alllakedf, subsetted by lake, with annual index, including raw (indxraw), kept based on min.nmr (indxkeep, indxkeep.lo, indxkeep.hi)
# scaleup = conversion factor used to scale up annual index to spawner model PE
streamdf <- allstreamdf[allstreamdf$ls %in% selstreams, ]
# error checks
check1 <- var(streamdf$lake)
if(is.na(check1) | is.null(check1)) stop("Either no streams selected or critical data missing.") else if(check1 > 0) stop("Selected streams should be only from ONE lake.")
if(any(is.na(match(c("year", "lake", "ls", "Emr", "CVmr"), names(allstreamdf))))) stop("allstreamdf must include these variables: year lake ls Emr CVmr.")
if(any(is.na(match(c("year", "lake", "PE"), names(alllakedf))))) stop("alllakedf must include these variables: lake year PE.")
# fill in missing mark-recap data
indfit <- aov(log(Emr) ~ as.factor(ls) + as.factor(year), data=streamdf, weights=1/CVmr^2)
# figure out estimable years (those with at least 1 m-r estimate)
n.mr <- tapply(!is.na(streamdf$Emr), streamdf$year, sum)
eyrs <- as.numeric(names(n.mr)[n.mr > 0.5])
estimable <- streamdf$year %in% eyrs
streamdf$Pmr <- NA
streamdf$Pmr[estimable] <- ModelEst(fit=indfit, df=streamdf[estimable, ])
streamdf$COMBmr <- ifelse(is.na(streamdf$Emr), streamdf$Pmr, streamdf$Emr)
# annual index (sum across streams)
indxdf <- aggregate(COMBmr ~ year + lake, streamdf, sum, na.rm=TRUE, na.action=na.pass)
names(indxdf)[names(indxdf)=="COMBmr"] <- "indxraw"
indxdf$indxraw[indxdf$indxraw==0] <- NA
# only keep lake-wide index for years with at least min.nmr mark-recap estimates
indxdf$n.mr <- n.mr
indxdf$indxkeep <- ifelse(indxdf$n.mr > (min.nmr - 0.5), indxdf$indxraw, NA)
indxdf$indxkeep.lo <- NA
indxdf$indxkeep.hi <- NA
# matrix of stream estimates (rows = years, columns = index streams)
streamests <- with(streamdf, tapply(COMBmr, list(year, ls), mean))
# selection of only those streams with a keepable index
selkeep <- !is.na(indxdf$indxkeep)
jack <- jackindex(streamests[selkeep, ])
indxdf$indxkeep.lo[selkeep] <- jack[, "lo"]
indxdf$indxkeep.hi[selkeep] <- jack[, "hi"]
# scale up the index to the spawner model PE
lk1 <- lk[lk$lake == streamdf$lake[1], ]
indxdf2 <- merge(lk1, indxdf, all=TRUE)
scaleup <- median(indxdf2$PE / indxdf2$indxkeep, na.rm=TRUE)
if(show) {
cat("\nindfit\n")
print(summary(indfit))
cat("\nstreamdf\n")
print(tail(streamdf[, c("lake", "year", "ls", "Emr", "CVmr", "Pmr", "COMBmr")]))
cat("\nscaleup\n")
print(scaleup)
cat("\nindxdf\n")
print(tail(indxdf[, c("lake", "year", "n.mr", "indxraw", "indxkeep", "indxkeep.lo", "indxkeep.hi")]))
}
list(indfit=indfit, streamdf=streamdf, scaleup=scaleup, indxdf=indxdf)
}
calctarg <- function(lakenum, adults, year, targyears, adjust=c(1, 1, 0.25, 1, 1)) {
# lakenum = vector of lake numbers (1-5)
# adults = vector of lakewide adult sea lamprey estimates
# year = vector of years
# targyears = list (length 5) of selected years from which to calculate targets
# lake huron target is 25% of
targets <- data.frame(lake=1:5, target=rep(NA, 5), lo=rep(NA, 5), hi=rep(NA, 5))
for(i in 1:5) {
pick5 <- adults[lakenum==i & is.element(year, targyears[[i]]) & !is.na(adults)]
if(length(pick5) > 0) {
targets$target[i] <- mean(pick5)
n <- length(pick5)
ci <- qnorm(1 - 0.05/2) * sqrt(var(pick5)) / sqrt(n)
targets[i, c("lo", "hi")] <- mean(pick5) + c(-1, 1)*ci# using z dist (known variance)
targets[i, c("target", "lo", "hi")] <- adjust[i]*targets[i, c("target", "lo", "hi")]
} else {
targets[i, c("target", "lo", "hi")] <- c(NA, NA, NA)
}
}
targets
}
}
# bring in lake-wide spawner data
lk <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/LakePEdynamic.csv", as.is=T)
# bring in stream-specific data
dat <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/StreamPEdynamicALLCOLS.csv", as.is=T)
dat$ls <- dat$lscode
# 2014-04-09 Jess and Gale agreed that the East Au Gres (38) should be replaced with the Au Sable (36) in Lake Huron
# 2014-04-10 Jess thinks that we should just stick with the East Au Gres (38)
index.streams <- list(
Sup = c(1, 2, 9, 29, 31, 32, 62),
Mic = c(5, 6, 15, 24, 26, 35),
Hur = c(10, 16, 27, 32, 999, 38),
Eri = c(1, 2, 3, 7, 9),
Ont = c(5, 9, 22, 23, 36)
)
index.streams <- lapply(1:5, function(i) i + index.streams[[i]]/1000)
# estimate adult index of abundance for each lake using index streams
indices <- lapply(index.streams, index.est, dat, lk)
# combine index data for all lakes in one dataframe
indxall <- do.call(rbind, lapply(indices, "[[", "indxdf"))
# calculate targets
sptargyrz <- list(1994:1998, 1988:1992, 1989:1993, 1991:1995, 1999:2003)
targyrz <- apply(sapply(sptargyrz, range), 2, paste, collapse="-")
# spawner model
targets.sm <- calctarg(lakenum=lk$lake, adults=lk$PE, year=lk$year, targyears=sptargyrz)
# adult index
targets.ai <- calctarg(lakenum=indxall$lake, adults=indxall$indxkeep, year=indxall$year, targyears=sptargyrz)
# spawner model targets scaled down to adult index
targets.sm.su <- cbind(lake=targets.sm[, 1], (1/sapply(indices, "[[", "scaleup")) * targets.sm[, -1])
# adult index adjusted
targets.ai.adj <- targets.ai
targets.ai.adj[is.na(targets.ai$target), ] <- targets.sm.su[is.na(targets.ai$target), ]
YEAR1 <- 1984
ls()
targets.ai
targets.ai.adj
targets.sm
targets.sm.su
lakenum=indxall$lake
adults=indxall$indxkeep
year=indxall$year
targyears=sptargyrz
adjust=c(1, 1, 0.25, 1, 1)
targets <- data.frame(lake=1:5, target=rep(NA, 5), lo=rep(NA, 5), hi=rep(NA, 5))
targets
i <- 2
pick5 <- adults[lakenum==i & is.element(year, targyears[[i]]) & !is.na(adults)]
pick5
head(adults)
adults
lakenum
targyears[[i]]
year
cbind(year, adults, lakenum)
cbind(year, adults, lakenum)[lakenum==i, ]
targets.ai
# calculate targets
sptargyrz <- list(1994:1998, 1988:1992, 1989:1993, 1991:1995, 1999:2003)
targyrz <- apply(sapply(sptargyrz, range), 2, paste, collapse="-")
# spawner model
targets.sm <- calctarg(lakenum=lk$lake, adults=lk$PE, year=lk$year, targyears=sptargyrz)
# adult index
targets.ai <- calctarg(lakenum=indxall$lake, adults=indxall$indxkeep, year=indxall$year, targyears=sptargyrz)
# spawner model targets scaled down to adult index
targets.sm.su <- cbind(lake=targets.sm[, 1], (1/sapply(indices, "[[", "scaleup")) * targets.sm[, -1])
# adult index adjusted
targets.ai.adj <- targets.ai
targets.ai.adj[is.na(targets.ai$target), ] <- targets.sm.su[is.na(targets.ai$target), ]
targets.ai
targets.ai.adj
write.csv(targets.ai.adj, "C:/JVA/Lamprey/Adults/AdultIndex/2014/AdultIndexTargets.csv", row.names=FALSE)
cleanup()
q()
install.packages("broom")
library(broom)
lmfit <- lm(mpg ~ wt, mtcars)
lmfit
summary(lmfit)
tidy(lmfit)
head(augment(lmfit))
glance(lmfit)
lmfit <- lm(mpg ~ wt, mtcars)
tidy(lmfit)
glance(lmfit)
lmfit <- lm(mpg ~ wt, mtcars)
tidy(lmfit)
glance(lmfit)
cleanup()
q()
library(shiny)
shiny::runGitHub("hclust-shiny", "joyofdata")
# C:\JVA\Consult\Stapanian\Amphib\Model selection with AIC.r
# which environmental variables best predict this index of amphibian biotic integrity
# relevant emails:
# 15 May 2013 - https://mail.google.com/mail/u/0/?shva=1#search/amphibian/13ea801401e50a84
#  8 Aug 2013 - https://mail.google.com/mail/u/1/?shva=1#inbox/1405defbc5969b40
# 27 Aug 2013 - https://mail.google.com/mail/u/1/?shva=1#inbox/140c042c5ba851fc
wb <- loadWorkbook("C:/JVA/Consult/Stapanian/Amphib/amphibians_Jean Apr18.xlsx")
dat <- readWorksheet(wb, sheet="Jean")
names(dat) <- make.names(casefold(names(dat)), unique=T, allow_=F)
dimnames(dat)[[1]] <- dat$site.code
rm(wb)
# Analysis 1 should include the following (17) as potential predictors: 
varz1 <- c("metric1", "metric2", "metric3", "metric4", "metric5", "metric6", "vibi.score", "water", "forest", "wtld.forest", "wtld.emerg", 
"pasture", "row.crop", "suburban", "transitional", "rock", "urban")
varz1 <- c("metric1", "metric2", "metric3", "metric4", "metric5", "metric6", "vibi.score", "water", "forest", "wtld.forest", "wtld.emerg", 
"pasture", "row.crop", "suburban", "transitional", "rock", "urban")
### data exploration ###
attach(dat)
# several variables need to be log transformed
logk <- function(x) {
mx <- min(x, na.rm=TRUE)
if(mx<0) {
x <- x + abs(mx)
mx <- 0
}
k <- min(x[x>0], na.rm=TRUE)/2
print(k)
log(x + min(x[x>0], na.rm=TRUE)/2)
}
tranvar <- logk(as.vector(dat[, c("water", "forest", "wtld.forest", "wtld.emerg", "pasture", "row.crop", "suburban", "transitional", "rock", "urban")]))
names(tranvar) <- paste0("log", names(tranvar))
head(tranvar)
dat2 <- cbind(dat, tranvar)
rm(logk, tranvar)
detach(dat)
# Analysis 1 should include the following (17) as potential predictors: 
varz1 <- c("metric1", "metric2", "metric3", "metric4", "metric5", "metric6", "vibi.score", "logwater", "logforest", "logwtld.forest", "logwtld.emerg", 
"logpasture", "logrow.crop", "logsuburban", "logtransitional", "logrock", "logurban")
v1namz <- c("ORAM~metric~1", "ORAM~metric~2", "ORAM~metric~3", "ORAM~metric~4", "ORAM~metric~5", "ORAM~metric~6", "OVIBI", 
"LDI[water]", "LDI[forest]", "LDI[wetland~forest]", "LDI[wetland~emergent]", "LDI[pasture]", "LDI[crop]", "LDI[suburban]", "LDI[transitional]", 
"LDI[rock]", "LDI[urban]")
# AbbreviationDescription                                                                             
# LDIwaterProp. standing water                                                              
# LDIforestProp. upland (non-hydric soils) forest                                   
# LDIwetland forestProp. wetland (hydric soils) forest                                         
# LDIwetland emergentProp. wetland dominated by emergent vegetation                
# LDIpastureProp. pasture
# LDIcropProp. agricultural row-crop land
# LDIsuburbanProp. suburban residential
# LDIrockProp. exposed rock substrate
# LDItransitionalProp. land being transitioned to an undefined use
# LDIurbanProp. urban area         
# ORAM metric 1Area (6)                                                                                                            
# ORAM metric 2Upland buffers and surrounding land use (14)
# ORAM metric 3Hydrology (30)          
# ORAM metric 4Habitat Alteration and Development (20)
# ORAM metric 5Special wetlands (10)
# ORAM metric 6Plant communities, interspersion, and microtopography (20)            
# OVIBI10 metrics describing wetland vegetation quality (100)
# get rid of four variables with few unique values
# metric5 (with 3 unique values), logtransitional (with 4), and metric1 and logrock (each with 6).
rid <- c(5, 15, 1, 16)
varz1 <- varz1[-rid]
v1namz <- v1namz[-rid]
attach(dat2)
ct <- t(
sapply(varz1, function(x) {
ct <- cor.test(dat2[, x], amphibi)
ctp <- ct$p.value
ctr <- as.vector(ct$estimate)
c(p=ctp, r=ctr)
})
)
title <- ifelse(ct[, "p"] < 0.05/length(varz1), paste0("bold('*'~", v1namz, ")"), v1namz)
windows(h=8, w=5.5)
#par(mfcol=c(6, 3), mar=c(2.5, 2, 1.5, 1), oma=c(0, 2.5, 0, 0), las=1, cex=0.7)
par(mfcol=c(5, 3), mar=c(2.5, 2, 1.5, 1), oma=c(0, 2.5, 0, 0), las=1, cex=0.7)
for(i in rev(order(ct[, "r"]))) plot(dat2[, varz1[i]], amphibi, xlab="", ylab="", main=as.expression(parse(text=title[i])))
mtext("AmphIBI", side=2, outer=TRUE, las=0, line=1)
suv <- sort(unique(veg.class))
windows(h=6.5, w=6.5)
map("state", mar=c(1, 1, 1, 1), region= "ohio", col="darkgray", lwd=2)
for(i in seq(suv)) {
sel <- veg.class==suv[i]
points(lon.dd[sel], lat.dd[sel], cex=2, lwd=2, pch=c(2, 1)[i], col=c("black", "gray")[i])
}
legend("bottomright", capwords(suv), pch=c(2, 1), col=c("black", "gray"), pt.lwd=2, pt.cex=2, cex=1.15, title="Veg. Class")
locator()
?map.scale
map.scale(x=-81.5, y=40.2, ratio=FALSE, relwidth=0.2)
locator()
map.scale(x=-82, y=40, ratio=FALSE, relwidth=0.2)
map.scale(x=-82.5, y=40, ratio=FALSE, relwidth=0.2)
map.scale(x=-82.25, y=40, ratio=FALSE, relwidth=0.2)
map("state", mar=c(1, 1, 1, 1), region= "ohio", col="darkgray", lwd=2)
for(i in seq(suv)) {
sel <- veg.class==suv[i]
points(lon.dd[sel], lat.dd[sel], cex=2, lwd=2, pch=c(2, 1)[i], col=c("black", "gray")[i])
}
legend("bottomright", capwords(suv), pch=c(2, 1), col=c("black", "gray"), pt.lwd=2, pt.cex=2, cex=1.15, title="Veg. Class")
map.scale(x=-82.25, y=40, ratio=FALSE, relwidth=0.2)
map.scale(x=-82.25, y=40.1, ratio=FALSE, relwidth=0.2)
map("state", mar=c(1, 1, 1, 1), region= "ohio", col="darkgray", lwd=2)
for(i in seq(suv)) {
sel <- veg.class==suv[i]
points(lon.dd[sel], lat.dd[sel], cex=2, lwd=2, pch=c(2, 1)[i], col=c("black", "gray")[i])
}
legend("bottomright", capwords(suv), pch=c(2, 1), col=c("black", "gray"), pt.lwd=2, pt.cex=2, cex=1.15, title="Veg. Class")
map.scale(x=-82.25, y=40.2, ratio=FALSE, relwidth=0.2)
locator()
map.scale(x=-83.1, y=41.9, ratio=FALSE, relwidth=0.2)
suv <- sort(unique(veg.class))
windows(h=6.5, w=6.5)
map("state", mar=c(1, 1, 1, 1), region= "ohio", col="darkgray", lwd=2)
for(i in seq(suv)) {
sel <- veg.class==suv[i]
points(lon.dd[sel], lat.dd[sel], cex=2, lwd=2, pch=c(2, 1)[i], col=c("black", "gray")[i])
}
legend("bottomright", capwords(suv), pch=c(2, 1), col=c("black", "gray"), pt.lwd=2, pt.cex=2, cex=1.15, title="Veg. Class")
map.scale(x=-82.25, y=40.2, ratio=FALSE, relwidth=0.2)
map.scale(x=-83, y=42, ratio=FALSE, relwidth=0.2)
library(GISTools)
?map.scale
suv <- sort(unique(veg.class))
windows(h=6.5, w=6.5)
map("state", mar=c(1, 1, 1, 1), region= "ohio", col="darkgray", lwd=2)
for(i in seq(suv)) {
sel <- veg.class==suv[i]
points(lon.dd[sel], lat.dd[sel], cex=2, lwd=2, pch=c(2, 1)[i], col=c("black", "gray")[i])
}
legend("bottomright", capwords(suv), pch=c(2, 1), col=c("black", "gray"), pt.lwd=2, pt.cex=2, cex=1.15, title="Veg. Class")
map.scale(x=-83, y=42, ratio=FALSE, relwidth=0.2)
maps::map.scale(x=-83, y=42, ratio=FALSE, relwidth=0.2)
locator()
north.arrow(xb=-80.7, yb=39.2, len=0.05, lab="N")
suv <- sort(unique(veg.class))
windows(h=6.5, w=6.5)
map("state", mar=c(1, 1, 1, 1), region= "ohio", col="darkgray", lwd=2)
for(i in seq(suv)) {
sel <- veg.class==suv[i]
points(lon.dd[sel], lat.dd[sel], cex=2, lwd=2, pch=c(2, 1)[i], col=c("black", "gray")[i])
}
legend("bottomright", capwords(suv), pch=c(2, 1), col=c("black", "gray"), pt.lwd=2, pt.cex=2, cex=1.15, title="Veg. Class")
maps::map.scale(x=-83, y=42, ratio=FALSE, relwidth=0.2)
north.arrow(xb=-80.7, yb=39.2, len=0.05, lab="N")
par(usr=c(-126, 94, 21, 193), xpd=NA)
polygon(c(-128, -128, -64, -64, -128), c(22, 52, 52, 22, 22), col="white", lwd=2)
map("state", add=T, mar=c(0, 0, 0, 0)) 
map("state", region="ohio", fill=T, add=T) 
cleanup()
q()
# C:\JVA\Consult\Stapanian\Amphib\Next Subm 2\Three Group Approach 2.r
# which environmental variables best predict this index of amphibian biotic integrity
# relevant emails:
# 15 May 2013 - https://mail.google.com/mail/u/0/?shva=1#search/amphibian/13ea801401e50a84
#  8 Aug 2013 - https://mail.google.com/mail/u/1/?shva=1#inbox/1405defbc5969b40
# 27 Aug 2013 - https://mail.google.com/mail/u/1/?shva=1#inbox/140c042c5ba851fc
library(GISTools)
# bring in data and create initial figures
source("C:/JVA/Consult/Stapanian/Amphib/Next Subm 2/Explore Figs 2.r")
select.varz <- function(varnames, mydat, max.no.ind.var) {
# keep only those varnames that have at least two unique non-missing values
varnames <- varnames[apply(mydat[, varnames], 2, function(x) {
y <- var(x[!is.na(x)])
!is.na(y) & y>0
})]
m <- allcombs(length(varnames), 0, max.no.ind.var)
dimnames(m)[[2]] <- varnames
# right side of the formula
rightside <- apply(m, 1, function(row) paste(varnames[row==1], collapse=" + "))
# if no predictors, use 1 to represent intercept only model
rightside[rightside==""] <- "1"
form <- paste("amphibi ~", rightside)
fits <- lapply(form, function(f) lm(formula(f), dat=mydat))
# AIC table
aictab <- AICc(fits)
bigtab <- cbind(formula=rightside[aictab$model], aictab)
nmodzfit <- dim(bigtab)[1]
# top models
topmods <- bigtab[bigtab$daicc < 2, ]
# add coefficients to top model
coef <- lapply(fits[topmods$model], coef)
xmod <- unique(unlist(lapply(coef, names)))
topcoef <- t(sapply(coef, function(x) 
{
blank <- rep(0, length(xmod))
blank[match(names(x), xmod)] <- x
blank
}))
dimnames(topcoef)[[2]] <- xmod
topmods <- cbind(signif(topcoef, 3), round(topmods[, c("n", "p", "rmse", "aicc", "daicc", "aiccw")], 2))
# single best model
bestnum <- bigtab$model[1]
bestfit <- fits[[bestnum]]
xvarz <- varnames[m[bestnum, ]==1]
# output
out <- list(xvarz=xvarz, nmodzfit=nmodzfit, bestfit=bestfit, topmods=topmods, allfits=fits, allmods=bigtab, allpreds=m)
print(out[1:4])
out
}
assess.fit <- function(fit, newd) {
p <- predict(fit, newdata=newd)
y <- newd$amphibi
r <- p - y
rmse <- sqrt(mean(r^2))
r2 <- calcr2(fitted=p, observed=y, nparam=length(labels(terms(freshfita)))+1)
list(cbind(p=p, y=y, r=r), rmse=rmse, r2=r2)
}
# assign each observation to one of three groups
# ensure even distribution of groups across vegetation classes and latitudes
dat3 <- dat2[order(dat2$veg.class, dat2$lat.dd), ]
dat3$group <- rep(1:3, length.out=dim(dat2)[1])
df <- dat3
### map
attach(df)
suv <- sort(unique(veg.class))
windows(h=6.5, w=6.5)
map("state", mar=c(1, 1, 1, 1), region= "ohio", col="darkgray", lwd=2)
for(i in seq(suv)) {
sel <- veg.class==suv[i]
points(lon.dd[sel], lat.dd[sel], cex=2, lwd=2, pch=c(2, 1)[i], col=group[sel]+1)
}
maps::map.scale(x=-83, y=42, ratio=FALSE, relwidth=0.2)
north.arrow(xb=-80.7, yb=39.2, len=0.05, lab="N")
#legend("bottomright", capwords(suv), pch=c(2, 1), col=c("black", "gray"), pt.lwd=2, pt.cex=2, cex=1.15, title="Veg. Class")
par(usr=c(-126, 94, 21, 193), xpd=NA)
polygon(c(-128, -128, -64, -64, -128), c(22, 52, 52, 22, 22), col="white", lwd=2)
map("state", add=T, mar=c(0, 0, 0, 0)) 
map("state", region="ohio", fill=T, add=T) 
locator()
windows(h=6.5, w=6.5)
map("state", mar=c(1, 1, 1, 1), region= "ohio", col="darkgray", lwd=2)
for(i in seq(suv)) {
sel <- veg.class==suv[i]
points(lon.dd[sel], lat.dd[sel], cex=2, lwd=2, pch=c(2, 1)[i], col=group[sel]+1)
}
locator()
maps::map.scale(x=-81.9, y=38.7, ratio=FALSE, relwidth=0.2)
north.arrow(xb=-80.7, yb=39.2, len=0.05, lab="N")
locator()
map("state", mar=c(1, 1, 1, 1), region= "ohio", col="darkgray", lwd=2)
for(i in seq(suv)) {
sel <- veg.class==suv[i]
points(lon.dd[sel], lat.dd[sel], cex=2, lwd=2, pch=c(2, 1)[i], col=group[sel]+1)
}
maps::map.scale(x=-81.9, y=38.7, ratio=FALSE, relwidth=0.2)
north.arrow(xb=-81.2, yb=39, len=0.05, lab="N")
map("state", mar=c(1, 1, 1, 1), region= "ohio", col="darkgray", lwd=2)
for(i in seq(suv)) {
sel <- veg.class==suv[i]
points(lon.dd[sel], lat.dd[sel], cex=2, lwd=2, pch=c(2, 1)[i], col=group[sel]+1)
}
maps::map.scale(x=-81.8, y=38.7, ratio=FALSE, relwidth=0.2)
north.arrow(xb=-81.2, yb=39, len=0.05, lab="N")
map("state", mar=c(1, 1, 1, 1), region= "ohio", col="darkgray", lwd=2)
for(i in seq(suv)) {
sel <- veg.class==suv[i]
points(lon.dd[sel], lat.dd[sel], cex=2, lwd=2, pch=c(2, 1)[i], col=group[sel]+1)
}
par(xpd=NA)
maps::map.scale(x=-81.8, y=38.7, ratio=FALSE, relwidth=0.2)
north.arrow(xb=-81.2, yb=39, len=0.05, lab="N")
par(usr=c(-126, 94, 21, 193), xpd=NA)
polygon(c(-128, -128, -64, -64, -128), c(22, 52, 52, 22, 22), col="white", lwd=2)
map("state", add=T, mar=c(0, 0, 0, 0)) 
map("state", region="ohio", fill=T, add=T) 
graphics.off()
map("state", region= "ohio")
locator()
maps::map.scale(x=-84, y=40, ratio=FALSE, relwidth=0.2)
locator()
north.arrow(xb=-83.4, yb=40.2, len=0.05, lab="N")
north.arrow(xb=-83.4, yb=41, len=0.05, lab="N")
map("state", region= "ohio")
q()
cleanup()
# C:\JVA\Consult\Lantry\Wounding model\Explore.r
# read in data
wb <- loadWorkbook("C:/JVA/Consult/Lantry/Wounding model/Mort funct2.xlsx")
raw <- readWorksheet(wb, sheet="StrainCPUE")
names(raw) <- jvanames(names(raw))
full <- readWorksheet(wb, sheet="SAS data")
names(full) <- jvanames(names(full))
head(raw)
  # xstrain strain2 year xyrcls age    lncpue       cpue
# 1     ONT SENlike 1990   1983   7 -2.768675 0.06274510
# 2     ONT SENlike 1991   1983   8 -2.610070 0.07352941
# 3     ONT SENlike 1992   1983   9 -3.396743 0.03348214
# 4     ONT SENlike 1993   1983  10 -4.158883 0.01562500
# 5     ONT SENlike 1991   1984   7 -0.255525 0.77450980
# 6     ONT SENlike 1992   1984   8 -1.142772 0.31893382
# rearrange data to calculate annual mortalities
attach(raw)
summary(log(cpue) - lncpue)
raw1 <- raw
raw1$year1 <- year
raw1$year2 <- year + 1
raw1$age1 <- age
raw1$age2 <- age + 1
raw1$cpue1 <- cpue
raw2 <- raw
raw2$year1 <- year - 1
raw2$year2 <- year
raw2$age1 <- age - 1
raw2$age2 <- age
raw2$cpue2 <- cpue
detach(raw)
rawpair <- merge(
raw1[, c("year1", "year2", "strain2", "xstrain", "xyrcls", "age1", "age2", "cpue1")],
raw2[, c("year1", "year2", "strain2", "xstrain", "xyrcls", "age1", "age2", "cpue2")],
all=TRUE
)
rawpair <- rawpair[!is.na(rawpair$cpue1) & !is.na(rawpair$cpue2), ]
rawpair$mort <- 1 - rawpair$cpue2/rawpair$cpue1
rm(raw1, raw2)
head(rawpair)
   # year1 year2 strain2 xstrain xyrcls age1 age2      cpue1      cpue2       mort
# 4   1986  1987 SUPlike     SUP   1979    7    8 0.87700321 0.38799895  0.5575855
# 6   1987  1988 SENlike     SEN   1979    8    9 0.03033088 0.09336623 -2.0782562
# 7   1987  1988 SENlike     SEN   1980    7    8 0.12132353 0.25844298 -1.1301967
# 9   1987  1988 SUPlike     SUP   1979    8    9 0.38799895 0.12438127  0.6794289
# 10  1987  1988 SUPlike     SUP   1980    7    8 1.57484244 0.68446898  0.5653730
# 12  1988  1989 SENlike     SEN   1979    9   10 0.09336623 0.04503676  0.5176332
# use AIC to determine best model predicting mortality from year, strain, and age/yrclass
rawpair$year1f <- as.factor(rawpair$year1)
rawpair$strain2f <- as.factor(rawpair$strain2)
rawpair$xstrainf <- as.factor(rawpair$xstrain)
rawpair$xyrclsf <- as.factor(rawpair$xyrcls)
rawpair$age1f <- as.factor(rawpair$age1)
rawpair$mort0 <- ifelse(rawpair$mort < 0, 0, rawpair$mort)
fit3a <- glm(mort0 ~ year1f + xstrainf + xyrclsf, data=rawpair)
fit3b <- glm(mort0 ~ year1f + strain2f + xyrclsf, data=rawpair)
fit3c <- glm(mort0 ~ year1f + xstrainf + age1f, data=rawpair)
fit3d <- glm(mort0 ~ year1f + strain2f + age1f, data=rawpair)
fit2a <- glm(mort0 ~ year1f + xstrainf, data=rawpair)
fit2b <- glm(mort0 ~ year1f + strain2f, data=rawpair)#### best model
fit2c <- glm(mort0 ~ year1f + xyrclsf, data=rawpair)
fit2d <- glm(mort0 ~ year1f + age1f, data=rawpair)
fit1 <- glm(mort0 ~ year1f, data=rawpair)
fit0 <- glm(mort0 ~ 1, data=rawpair)
AICc(list(fit3a, fit3b, fit3c, fit3d, fit2a, fit2b, fit2c, fit2d, fit1, fit0))
# summarize data across strains within strain groups
ssum <- aggregate(cbind(cpue1, cpue2) ~ year1 + year2 + strain2 + xyrcls + age1 + age2 + year1f + strain2f + xyrclsf + age1f, rawpair, sum)
ssum$mort <- 1 - ssum$cpue2/ssum$cpue1
ssum$mort0 <- ifelse(ssum$mort < 0, 0, ssum$mort)
head(ssum)
fit <- aov(mort0 ~ year1f + strain2f, data=ssum)
summary(fit)
fit <- lm(mort0 ~ year1f + strain2f, data=ssum)
summary(fit)
attach(ssum)
suy <- sort(unique(year1f))
sus <- sort(unique(strain2f))
newdata <- expand.grid(year1f=suy, strain2f=sus)
p <- cbind(newdata, predict(fit, newdata=newdata, interval="confidence"))
windows(w=9, h=3)
par(mar=c(4, 4, 1, 1), las=1)
plot(year1, mort0, type="n", ylim=0:1, xlab="Year t", ylab="Annual mortality  (from t to t+1)")
text(jitter(year1), mort0, substring(strain2f, 3, 3), col=blindcolz[as.numeric(strain2f)+1], cex=0.8)
for(i in seq_along(sus)) {
sel <- p$strain2f == sus[i]
lines(spline(as.numeric(as.character(p$year1f))[sel], p$fit[sel], n=1000), col=blindcolz[i+1], lwd=2)
}
for(i in seq_along(sus)) {
windows(w=9, h=3)
par(mar=c(4, 4, 1, 1), las=1)
plot(year1, mort0, type="n", ylim=0:1, xlab="Year t", ylab="Annual mortality  (from t to t+1)")
sel <- p$strain2f == sus[i]
shadepoly(as.numeric(as.character(p$year1f)), p$fit, p$lwr, p$upr, subsel=sel, kol=blindcolz[i+1])
}
sub <- p[sel, ]
x <- sub$fit[-dim(sub)[1]]
y <- sub$fit[-1]
cor.test(x, y)
windows(w=6.5, h=7)
par(mar=c(4, 4, 2, 1), las=1, cex=1.5, xaxs="i", yaxs="i", pty="s")
plot(x, y, xlim=0:1, ylim=0:1, xlab="Predicted mortality in year t", ylab="Predicted mortality in year t+1", main="Superior-like Strains")
abline(lsfit(x, y), lwd=2)
text(0.8, 0.8, paste("r =", round(cor.test(x, y)$estimate, 2)))
full[, 1:2]
full[1:2, ]
full[1:2, ]
dim(full)
dim(ssum)
dim(p)
sub
dim(sub)
look <- merge(full, sub, by.x="year.1.sept.", by.y="year1")
full$year.1.sept.
sub$year1 <- as.numeric(as.character(sub$year1f))
look <- merge(full, sub, by.x="year.1.sept.", by.y="year1")
dim(look)
sub$year1 <- as.numeric(as.character(sub$year1f))
look <- merge(full, sub, by.x="year.1.sept.", by.y="year1", all=TRUE)
dim(look)
look
names(look)
look[, c(1, 2, 4, 47, 49)]
windows()
plot(look$suplike.mort, look$fit)
attach(look)
windows()
plot(year1, fit, ylim=0:1, type="n", xlab="Year t", ylab="Predicted mortality in year t+1", main="Superior-like Strains")
lines(year1, suplike.mort, type="b", col="blue")
lines(year1, fit, type="b", pch=2, col="red")
year1
fit
rm(fit)
plot(year1, fit, ylim=0:1, type="n", xlab="Year t", ylab="Predicted mortality in year t+1", main="Superior-like Strains")
lines(year1, suplike.mort, type="b", col="blue")
lines(year1, fit, type="b", pch=2, col="red")
year1
fit
search()
dim(look)
dim(ssum)
look$year1
detach(ssum)
plot(year1, fit)
search()
look
search()
detach()
sub$year1 <- as.numeric(as.character(sub$year1f))
look <- merge(full, sub, by.x="year.1.sept.", by.y="year1", all=TRUE)
attach(look)
windows()
plot(year1f, fit, ylim=0:1, type="n", xlab="Year t", ylab="Predicted mortality in year t+1", main="Superior-like Strains")
lines(year1f, suplike.mort, type="b", col="blue")
lines(year1f, fit, type="b", pch=2, col="red")
windows()
plot(year1f, fit, type="n", ylim=0:1, xlab="Year t", ylab="Predicted mortality in year t+1", main="Superior-like Strains")
plot(year1, fit, type="n", ylim=0:1, xlab="Year t", ylab="Predicted mortality in year t+1", main="Superior-like Strains")
lines(year1, suplike.mort, type="o", col="blue")
lines(year1, fit, type="o", pch=2, col="red")
look
search()
detach()
sub$year1 <- as.numeric(as.character(sub$year1f))
look <- merge(sub, full, by.x="year1", by.y="year.1.sept.", all=TRUE)
attach(look)
windows()
plot(year1, fit, type="n", ylim=0:1, xlab="Year t", ylab="Predicted mortality in year t+1", main="Superior-like Strains")
lines(year1, suplike.mort, type="o", col="blue")
lines(year1, fit, type="o", pch=2, col="red")
par(mar=c(4, 4, 2, 1), las=1)
plot(year1, fit, type="n", ylim=0:1, xlab="Year t", ylab="Predicted mortality in year t+1", main="Superior-like Strains")
lines(year1, suplike.mort, type="o", col="blue")
lines(year1, fit, type="o", pch=2, col="red")
windows()
par(mar=c(4, 4, 2, 1), las=1)
plot(year1, fit, type="n", ylim=0:1, xlab="Year t", ylab="Predicted mortality in year t+1", main="Superior-like Strains")
lines(year1, suplike.mort, type="o", col=blindcolz[4])
lines(year1, fit, type="o", pch=2, col=blindcolz[2])
blindcolz
windows(w=9, h=3)
par(mar=c(4, 4, 2, 1), las=1)
plot(year1, fit, type="n", ylim=0:1, xlab="Year t", ylab="Predicted mortality in year t+1", main="Superior-like Strains")
lines(year1, suplike.mort, type="o", col=blindcolz[7], lwd=2)
lines(year1, fit, type="o", pch=2, col=blindcolz[3])
par(mar=c(4, 4, 2, 1), las=1)
plot(year1, fit, type="n", ylim=0:1, xlab="Year t", ylab="Predicted mortality in year t+1", main="Superior-like Strains")
lines(year1, suplike.mort, type="o", col=blindcolz[7], lwd=2)
lines(year1, fit, type="o", pch=2, col=blindcolz[3], lwd=2)
windows(w=9, h=3.5)
par(mar=c(4, 4, 2, 1), las=1)
plot(year1, fit, type="n", ylim=0:1, xlab="Year t", ylab="Predicted mortality in year t+1", main="Superior-like Strains")
lines(year1, suplike.mort, type="o", col=blindcolz[7], lwd=2)
lines(year1, fit, type="o", pch=2, col=blindcolz[3], lwd=2)
cleanup()
q()
# C:\JVA\Consult\Lantry\Wounding model\Explore.r
# read in data
wb <- loadWorkbook("C:/JVA/Consult/Lantry/Wounding model/Mort funct2.xlsx")
raw <- readWorksheet(wb, sheet="StrainCPUE")
names(raw) <- jvanames(names(raw))
full <- readWorksheet(wb, sheet="SAS data")
warnings()
names(full) <- jvanames(names(full))
head(raw)
  # xstrain strain2 year xyrcls age    lncpue       cpue
# 1     ONT SENlike 1990   1983   7 -2.768675 0.06274510
# 2     ONT SENlike 1991   1983   8 -2.610070 0.07352941
# 3     ONT SENlike 1992   1983   9 -3.396743 0.03348214
# 4     ONT SENlike 1993   1983  10 -4.158883 0.01562500
# 5     ONT SENlike 1991   1984   7 -0.255525 0.77450980
# 6     ONT SENlike 1992   1984   8 -1.142772 0.31893382
# rearrange data to calculate annual mortalities
attach(raw)
summary(log(cpue) - lncpue)
raw1 <- raw
raw1$year1 <- year
raw1$year2 <- year + 1
raw1$age1 <- age
raw1$age2 <- age + 1
raw1$cpue1 <- cpue
raw2 <- raw
raw2$year1 <- year - 1
raw2$year2 <- year
raw2$age1 <- age - 1
raw2$age2 <- age
raw2$cpue2 <- cpue
detach(raw)
rawpair <- merge(
raw1[, c("year1", "year2", "strain2", "xstrain", "xyrcls", "age1", "age2", "cpue1")],
raw2[, c("year1", "year2", "strain2", "xstrain", "xyrcls", "age1", "age2", "cpue2")],
all=TRUE
)
rawpair <- rawpair[!is.na(rawpair$cpue1) & !is.na(rawpair$cpue2), ]
rawpair$mort <- 1 - rawpair$cpue2/rawpair$cpue1
rm(raw1, raw2)
head(rawpair)
   # year1 year2 strain2 xstrain xyrcls age1 age2      cpue1      cpue2       mort
# 4   1986  1987 SUPlike     SUP   1979    7    8 0.87700321 0.38799895  0.5575855
# 6   1987  1988 SENlike     SEN   1979    8    9 0.03033088 0.09336623 -2.0782562
# 7   1987  1988 SENlike     SEN   1980    7    8 0.12132353 0.25844298 -1.1301967
# 9   1987  1988 SUPlike     SUP   1979    8    9 0.38799895 0.12438127  0.6794289
# 10  1987  1988 SUPlike     SUP   1980    7    8 1.57484244 0.68446898  0.5653730
# 12  1988  1989 SENlike     SEN   1979    9   10 0.09336623 0.04503676  0.5176332
# use AIC to determine best model predicting mortality from year, strain, and age/yrclass
rawpair$year1f <- as.factor(rawpair$year1)
rawpair$strain2f <- as.factor(rawpair$strain2)
rawpair$xstrainf <- as.factor(rawpair$xstrain)
rawpair$xyrclsf <- as.factor(rawpair$xyrcls)
rawpair$age1f <- as.factor(rawpair$age1)
rawpair$mort0 <- ifelse(rawpair$mort < 0, 0, rawpair$mort)
fit3a <- glm(mort0 ~ year1f + xstrainf + xyrclsf, data=rawpair)
fit3b <- glm(mort0 ~ year1f + strain2f + xyrclsf, data=rawpair)
fit3c <- glm(mort0 ~ year1f + xstrainf + age1f, data=rawpair)
fit3d <- glm(mort0 ~ year1f + strain2f + age1f, data=rawpair)
fit2a <- glm(mort0 ~ year1f + xstrainf, data=rawpair)
fit2b <- glm(mort0 ~ year1f + strain2f, data=rawpair)#### best model
fit2c <- glm(mort0 ~ year1f + xyrclsf, data=rawpair)
fit2d <- glm(mort0 ~ year1f + age1f, data=rawpair)
fit1 <- glm(mort0 ~ year1f, data=rawpair)
fit0 <- glm(mort0 ~ 1, data=rawpair)
AICc(list(fit3a, fit3b, fit3c, fit3d, fit2a, fit2b, fit2c, fit2d, fit1, fit0))
# summarize data across strains within strain groups
ssum <- aggregate(cbind(cpue1, cpue2) ~ year1 + year2 + strain2 + xyrcls + age1 + age2 + year1f + strain2f + xyrclsf + age1f, rawpair, sum)
ssum$mort <- 1 - ssum$cpue2/ssum$cpue1
ssum$mort0 <- ifelse(ssum$mort < 0, 0, ssum$mort)
head(ssum)
myfit <- aov(mort0 ~ year1f + strain2f, data=ssum)
summary(myfit)
myfit <- lm(mort0 ~ year1f + strain2f, data=ssum)
summary(myfit)
attach(ssum)
suy <- sort(unique(year1f))
sus <- sort(unique(strain2f))
newdata <- expand.grid(year1f=suy, strain2f=sus)
p <- cbind(newdata, predict(myfit, newdata=newdata, interval="confidence"))
windows(w=9, h=3.5)
par(mar=c(4, 4, 2, 1), las=1)
plot(year1, mort0, type="n", ylim=0:1, xlab="Year t", ylab="Annual mortality  (from t to t+1)", main="P = Superior-, N = Seneca-like Strain")
text(jitter(year1), mort0, substring(strain2f, 3, 3), col=blindcolz[as.numeric(strain2f)+1], cex=0.8)
for(i in seq_along(sus)) {
sel <- p$strain2f == sus[i]
lines(spline(as.numeric(as.character(p$year1f))[sel], p$fit[sel], n=1000), col=blindcolz[i+1], lwd=2)
points(as.numeric(as.character(p$year1f))[sel], p$fit[sel], col=blindcolz[i+1], pch=16)
}
for(i in seq_along(sus)) {
windows(w=9, h=3)
par(mar=c(4, 4, 1, 1), las=1)
plot(year1, mort0, type="n", ylim=0:1, xlab="Year t", ylab="Annual mortality  (from t to t+1)")
sel <- p$strain2f == sus[i]
shadepoly(as.numeric(as.character(p$year1f)), p$fit, p$lwr, p$upr, subsel=sel, kol=blindcolz[i+1])
}
detach(ssum)
sub <- p[sel, ]
x <- sub$fit[-dim(sub)[1]]
y <- sub$fit[-1]
cor.test(x, y)
windows(w=6.5, h=7)
par(mar=c(4, 4, 2, 1), las=1, cex=1.5, xaxs="i", yaxs="i", pty="s")
plot(x, y, xlim=0:1, ylim=0:1, xlab="Predicted mortality in year t", ylab="Predicted mortality in year t+1", main="Superior-like Strains")
abline(lsfit(x, y), lwd=2)
text(0.8, 0.8, paste("r =", round(cor.test(x, y)$estimate, 2)))
sub$year1 <- as.numeric(as.character(sub$year1f))
look <- merge(sub, full, by.x="year1", by.y="year.1.sept.", all=TRUE)
attach(look)
windows(w=9, h=3.5)
par(mar=c(4, 4, 2, 1), las=1)
plot(year1, fit, type="n", ylim=0:1, xlab="Year t", ylab="Predicted mortality in year t+1", main="Superior-like Strains")
lines(year1, suplike.mort, type="o", col=blindcolz[7], lwd=2)
lines(year1, fit, type="o", pch=2, col=blindcolz[3], lwd=2)
detach(look)
# C:\JVA\Consult\Lantry\Wounding model\Explore.r
# read in data
wb <- loadWorkbook("C:/JVA/Consult/Lantry/Wounding model/Mort funct2.xlsx")
raw <- readWorksheet(wb, sheet="StrainCPUE")
names(raw) <- jvanames(names(raw))
full <- readWorksheet(wb, sheet="SAS data")
warnings()
names(full) <- jvanames(names(full))
head(raw)
  # xstrain strain2 year xyrcls age    lncpue       cpue
# 1     ONT SENlike 1990   1983   7 -2.768675 0.06274510
# 2     ONT SENlike 1991   1983   8 -2.610070 0.07352941
# 3     ONT SENlike 1992   1983   9 -3.396743 0.03348214
# 4     ONT SENlike 1993   1983  10 -4.158883 0.01562500
# 5     ONT SENlike 1991   1984   7 -0.255525 0.77450980
# 6     ONT SENlike 1992   1984   8 -1.142772 0.31893382
# rearrange data to calculate annual mortalities
attach(raw)
summary(log(cpue) - lncpue)
raw1 <- raw
raw1$year1 <- year
raw1$year2 <- year + 1
raw1$age1 <- age
raw1$age2 <- age + 1
raw1$cpue1 <- cpue
raw2 <- raw
raw2$year1 <- year - 1
raw2$year2 <- year
raw2$age1 <- age - 1
raw2$age2 <- age
raw2$cpue2 <- cpue
detach(raw)
rawpair <- merge(
raw1[, c("year1", "year2", "strain2", "xstrain", "xyrcls", "age1", "age2", "cpue1")],
raw2[, c("year1", "year2", "strain2", "xstrain", "xyrcls", "age1", "age2", "cpue2")],
all=TRUE
)
rawpair <- rawpair[!is.na(rawpair$cpue1) & !is.na(rawpair$cpue2), ]
rawpair$mort <- 1 - rawpair$cpue2/rawpair$cpue1
rm(raw1, raw2)
head(rawpair)
   # year1 year2 strain2 xstrain xyrcls age1 age2      cpue1      cpue2       mort
# 4   1986  1987 SUPlike     SUP   1979    7    8 0.87700321 0.38799895  0.5575855
# 6   1987  1988 SENlike     SEN   1979    8    9 0.03033088 0.09336623 -2.0782562
# 7   1987  1988 SENlike     SEN   1980    7    8 0.12132353 0.25844298 -1.1301967
# 9   1987  1988 SUPlike     SUP   1979    8    9 0.38799895 0.12438127  0.6794289
# 10  1987  1988 SUPlike     SUP   1980    7    8 1.57484244 0.68446898  0.5653730
# 12  1988  1989 SENlike     SEN   1979    9   10 0.09336623 0.04503676  0.5176332
# use AIC to determine best model predicting mortality from year, strain, and age/yrclass
rawpair$year1f <- as.factor(rawpair$year1)
rawpair$strain2f <- as.factor(rawpair$strain2)
rawpair$xstrainf <- as.factor(rawpair$xstrain)
rawpair$xyrclsf <- as.factor(rawpair$xyrcls)
rawpair$age1f <- as.factor(rawpair$age1)
rawpair$mort0 <- ifelse(rawpair$mort < 0, 0, rawpair$mort)
fit3a <- glm(mort0 ~ year1f + xstrainf + xyrclsf, data=rawpair)
fit3b <- glm(mort0 ~ year1f + strain2f + xyrclsf, data=rawpair)
fit3c <- glm(mort0 ~ year1f + xstrainf + age1f, data=rawpair)
fit3d <- glm(mort0 ~ year1f + strain2f + age1f, data=rawpair)
fit2a <- glm(mort0 ~ year1f + xstrainf, data=rawpair)
fit2b <- glm(mort0 ~ year1f + strain2f, data=rawpair)#### best model
fit2c <- glm(mort0 ~ year1f + xyrclsf, data=rawpair)
fit2d <- glm(mort0 ~ year1f + age1f, data=rawpair)
fit1 <- glm(mort0 ~ year1f, data=rawpair)
fit0 <- glm(mort0 ~ 1, data=rawpair)
AICc(list(fit3a, fit3b, fit3c, fit3d, fit2a, fit2b, fit2c, fit2d, fit1, fit0))
# summarize data across strains within strain groups
ssum <- aggregate(cbind(cpue1, cpue2) ~ year1 + year2 + strain2 + xyrcls + age1 + age2 + year1f + strain2f + xyrclsf + age1f, rawpair, sum)
ssum$mort <- 1 - ssum$cpue2/ssum$cpue1
ssum$mort0 <- ifelse(ssum$mort < 0, 0, ssum$mort)
head(ssum)
myfit <- aov(mort0 ~ year1f + strain2f, data=ssum)
summary(myfit)
myfit <- lm(mort0 ~ year1f + strain2f, data=ssum)
summary(myfit)
attach(ssum)
suy <- sort(unique(year1f))
sus <- sort(unique(strain2f))
newdata <- expand.grid(year1f=suy, strain2f=sus)
p <- cbind(newdata, predict(myfit, newdata=newdata, interval="confidence"))
windows(w=9, h=3.5)
par(mar=c(4, 4, 2, 1), las=1)
plot(year1, mort0, type="n", ylim=0:1, xlab="Year t", ylab="Annual mortality  (from t to t+1)", main="P = Superior-, N = Seneca-like Strains")
text(jitter(year1), mort0, substring(strain2f, 3, 3), col=blindcolz[as.numeric(strain2f)+1], cex=0.8)
for(i in seq_along(sus)) {
sel <- p$strain2f == sus[i]
lines(spline(as.numeric(as.character(p$year1f))[sel], p$fit[sel], n=1000), col=blindcolz[i+1], lwd=2)
points(as.numeric(as.character(p$year1f))[sel], p$fit[sel], col=blindcolz[i+1], pch=16)
}
for(i in seq_along(sus)) {
windows(w=9, h=3)
par(mar=c(4, 4, 1, 1), las=1)
plot(year1, mort0, type="n", ylim=0:1, xlab="Year t", ylab="Annual mortality  (from t to t+1)")
sel <- p$strain2f == sus[i]
shadepoly(as.numeric(as.character(p$year1f)), p$fit, p$lwr, p$upr, subsel=sel, kol=blindcolz[i+1])
}
detach(ssum)
sub <- p[sel, ]
x <- sub$fit[-dim(sub)[1]]
y <- sub$fit[-1]
cor.test(x, y)
windows(w=6.5, h=7)
par(mar=c(4, 4, 2, 1), las=1, cex=1.5, xaxs="i", yaxs="i", pty="s")
plot(x, y, xlim=0:1, ylim=0:1, xlab="Predicted mortality in year t", ylab="Predicted mortality in year t+1", main="Superior-like Strains")
abline(lsfit(x, y), lwd=2)
text(0.8, 0.8, paste("r =", round(cor.test(x, y)$estimate, 2)))
sub$year1 <- as.numeric(as.character(sub$year1f))
look <- merge(sub, full, by.x="year1", by.y="year.1.sept.", all=TRUE)
attach(look)
windows(w=9, h=3.5)
par(mar=c(4, 4, 2, 1), las=1)
plot(year1, fit, type="n", ylim=0:1, xlab="Year t", ylab="Predicted mortality in year t+1", main="Superior-like Strains")
lines(year1, suplike.mort, type="o", pch=2, col=blindcolz[7], lwd=2)
lines(year1, fit, type="o", pch=16, col=blindcolz[3], lwd=2)
detach(look)
fit4a <- glm(mort0 ~ year1f*xstrainf + xyrclsf, data=rawpair)
fit4b <- glm(mort0 ~ year1f*strain2f + xyrclsf, data=rawpair)
fit4c <- glm(mort0 ~ year1f*xstrainf + age1f, data=rawpair)
fit4d <- glm(mort0 ~ year1f*strain2f + age1f, data=rawpair)
fit3a <- glm(mort0 ~ year1f + xstrainf + xyrclsf, data=rawpair)
fit3b <- glm(mort0 ~ year1f + strain2f + xyrclsf, data=rawpair)
fit3c <- glm(mort0 ~ year1f + xstrainf + age1f, data=rawpair)
fit3d <- glm(mort0 ~ year1f + strain2f + age1f, data=rawpair)
fit2a <- glm(mort0 ~ year1f + xstrainf, data=rawpair)
fit2b <- glm(mort0 ~ year1f + strain2f, data=rawpair)#### best model
fit2c <- glm(mort0 ~ year1f + xyrclsf, data=rawpair)
fit2d <- glm(mort0 ~ year1f + age1f, data=rawpair)
fit1 <- glm(mort0 ~ year1f, data=rawpair)
fit0 <- glm(mort0 ~ 1, data=rawpair)
AICc(list(fit4a, fit4b, fit4c, fit4d, fit3a, fit3b, fit3c, fit3d, fit2a, fit2b, fit2c, fit2d, fit1, fit0))
?cheat
wb <- loadWorkbook("C:/JVA/Consult/Shively/Snowmelt.xlsx")
dat <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1)
dim(dat)
head(dat)
graphics.off()
plotdf(dat)
with(dat, table(Event, EventTime, Site, Replicate))
with(dat, table(Event, EventTime, paste(Site, Replicate)))
3*8*3*3
dim(dat)
3*7*3*3
216-189
head(dat)
table(dat$Date)
with(dat, table(Event, EventTime, paste(Site, Replicate)), Date)
with(dat, table(Event, EventTime, paste(Site, Replicate), Date))
with(dat, table(paste(Event, EventTime, Date), paste(Site, Replicate)))
head(dat)
lapply(dat, class)
attach(dat)
# look at design
table(paste(Event, EventTime, Date), paste(Site, Replicate))
plot(Date, lgEC, pch=as.factor(Site))
plot(Date, LgEC, pch=as.factor(Site))
as.factor(Site)
plot(Date, LgEC, pch=as.numeric(as.factor(Site)))
windows(h=4, w=9)
par(mar=c(4, 4, 1, 1), las=1)
plot(Date, LgEC, pch=as.numeric(as.factor(Site)))
sitecode <- as.numeric(as.factor(Site))
windows(h=4, w=9)
par(mar=c(4, 4, 1, 1), las=1)
plot(Date, LgEC, pch=sitecode, col=sitecode+1)
aggregate(LgEC ~ Date + Site, dat, mean)
# look at design
table(paste(Event, EventTime, Date), paste(Site, Replicate))
sitecode <- as.numeric(as.factor(Site))
sus <- sort(unique(sitecode))
sue <- sort(unique(Event))
meanz <- aggregate(LgEC ~ Date + Site, dat, mean)
windows(h=4, w=9)
par(mar=c(4, 4, 1, 1), las=1)
plot(Date, LgEC, pch=sitecode, col=sitecode+1)
for(i in seq(sus)) {
for(j in seq(sue)) {
sel <- sitecode==sus[i] & Event==sue[j]
lines(Date[sel], LgEC[sel], col=i+1)
}}
meanz
meanz <- aggregate(LgEC ~ Date + Site + Event, dat, mean)
head(meanz)
search()
detach()
cleanup()
wb <- loadWorkbook("C:/JVA/Consult/Shively/Snowmelt.xlsx")
dat <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1)
head(dat)
        # Date Event EventTime Site Replicate     LgEC
# 1 2014-02-18     1         1   DC         1 1.462398
# 2 2014-02-18     1         1   DC         2 1.690196
# 3 2014-02-18     1         1   DC         3 1.662758
# 4 2014-02-19     1         2   DC         1 1.785330
# 5 2014-02-19     1         2   DC         2 1.785330
# 6 2014-02-19     1         2   DC         3 1.707570
dat$sitecode <- as.numeric(as.factor(dat$Site))
attach(dat)
# look at design
table(paste(Event, EventTime, Date), paste(Site, Replicate))
sus <- sort(unique(sitecode))
sue <- sort(unique(Event))
meanz <- aggregate(LgEC ~ Date + sitecode + Event, dat, mean)
meanz
windows(h=4, w=9)
par(mar=c(4, 4, 1, 1), las=1)
plot(Date, LgEC, pch=sitecode, col=sitecode+1)
for(i in seq(sus)) {
for(j in seq(sue)) {
sel <- meanz$sitecode==sus[i] & meanz$Event==sue[j]
lines(meanz$Date[sel], meanz$LgEC[sel], col=i+1)
}}
par(mar=c(4, 4, 1, 1), las=1)
plot(Date, LgEC, pch=sitecode, col=sitecode+1)
for(i in seq(sus)) {
for(j in seq(sue)) {
sel <- meanz$sitecode==sus[i] & meanz$Event==sue[j]
lines(spline(meanz$Date[sel], meanz$LgEC[sel], 1000), col=i+1, lwd=2)
}}
par(mar=c(4, 4, 1, 1), las=1)
plot(Date, LgEC, pch=sitecode, col=sitecode+1)
for(i in seq(sus)) {
for(j in seq(sue)) {
sel <- meanz$sitecode==sus[i] & meanz$Event==sue[j]
lines(meanz$Date[sel], meanz$LgEC[sel], col=i+1, lwd=2)
#lines(spline(meanz$Date[sel], meanz$LgEC[sel], 1000), col=i+1, lwd=2)
}}
windows(h=4, w=9)
par(mar=c(4, 4, 1, 1), las=1)
for(j in seq(sue)) {
sel <- Event==sue[j]
plot(Date[sel], LgEC[sel], pch=sitecode, col=sitecode+1)
for(i in seq(sus)) {
sel <- meanz$sitecode==sus[i] & meanz$Event==sue[j]
lines(meanz$Date[sel], meanz$LgEC[sel], col=i+1, lwd=2)
#lines(spline(meanz$Date[sel], meanz$LgEC[sel], 1000), col=i+1, lwd=2)
}
}
windows()
par(mar=c(4, 4, 1, 1), mfrow=c(3, 1), las=1)
for(j in seq(sue)) {
sel <- Event==sue[j]
plot(Date[sel], LgEC[sel], pch=sitecode, col=sitecode+1)
for(i in seq(sus)) {
sel <- meanz$sitecode==sus[i] & meanz$Event==sue[j]
lines(meanz$Date[sel], meanz$LgEC[sel], col=i+1, lwd=2)
#lines(spline(meanz$Date[sel], meanz$LgEC[sel], 1000), col=i+1, lwd=2)
}
}
windows(h=9, w=6.5)
par(mar=c(4, 4, 1, 1), mfrow=c(3, 1), las=1)
for(j in seq(sue)) {
sel <- Event==sue[j]
plot(Date[sel], LgEC[sel], pch=sitecode, col=sitecode+1)
for(i in seq(sus)) {
sel <- meanz$sitecode==sus[i] & meanz$Event==sue[j]
lines(meanz$Date[sel], meanz$LgEC[sel], col=i+1, lwd=2)
#lines(spline(meanz$Date[sel], meanz$LgEC[sel], 1000), col=i+1, lwd=2)
}
}
par(mar=c(4, 4, 1, 1), mfrow=c(3, 1), las=1)
for(j in seq(sue)) {
sel <- Event==sue[j]
plot(Date[sel], LgEC[sel], pch=sitecode, ylim=range(LgEC), col=sitecode+1)
for(i in seq(sus)) {
sel <- meanz$sitecode==sus[i] & meanz$Event==sue[j]
lines(meanz$Date[sel], meanz$LgEC[sel], col=i+1, lwd=2)
#lines(spline(meanz$Date[sel], meanz$LgEC[sel], 1000), col=i+1, lwd=2)
}
}
axislogk
search()
ls(4)
stringin("log", ls(4))
prettylog
?prettylog
vals <- rlnorm(100, 6)
summary(vals)
prettylog(vals, 1, 0)
prettylog(vals, 1)
prettylog(vals, c(1, 2, 5))
x <- 10^LgEC
x
prettylog(x)
prettylog(x, extra=0)
prettylog(x, lead=1, extra=0)
pl <- prettylog(10^LgEC, lead=1, extra=0)
axis(4, at=log10(pl), pl)
windows(h=9, w=6.5)
par(mar=c(3, 3, 1, 1), mfrow=c(3, 1), las=1, oma=c(2, 2, 0, 2))
for(j in seq(sue)) {
sel <- Event==sue[j]
plot(Date[sel], LgEC[sel], pch=sitecode, ylim=range(LgEC), col=sitecode+1, xlab="", ylab="")
for(i in seq(sus)) {
sel <- meanz$sitecode==sus[i] & meanz$Event==sue[j]
lines(meanz$Date[sel], meanz$LgEC[sel], col=i+1, lwd=2)
#lines(spline(meanz$Date[sel], meanz$LgEC[sel], 1000), col=i+1, lwd=2)
}
}
mtext("Date", side=1, outer=TRUE)
mtext("E. coli concentration", side=2, outer=TRUE)
pl <- prettylog(10^LgEC, lead=1, extra=0)
axis(4, at=log10(pl), pl)
windows(h=9, w=6.5)
par(mar=c(3, 3, 1, 1), mfrow=c(3, 1), oma=c(2, 2, 0, 2))
for(j in seq(sue)) {
sel <- Event==sue[j]
plot(Date[sel], LgEC[sel], pch=sitecode, ylim=range(LgEC), col=sitecode+1, las=1, xlab="", ylab="")
for(i in seq(sus)) {
sel <- meanz$sitecode==sus[i] & meanz$Event==sue[j]
lines(meanz$Date[sel], meanz$LgEC[sel], col=i+1, lwd=2)
#lines(spline(meanz$Date[sel], meanz$LgEC[sel], 1000), col=i+1, lwd=2)
}
}
mtext("Date", side=1, outer=TRUE)
mtext("E. coli concentration", side=2, outer=TRUE)
pl <- prettylog(10^LgEC, lead=1, extra=0)
axis(4, at=log10(pl), pl)
windows(h=9, w=6.5)
par(mar=c(3, 3, 1, 1), mfrow=c(3, 1), oma=c(2, 2, 0, 2))
for(j in seq(sue)) {
sel <- Event==sue[j]
plot(Date[sel], LgEC[sel], pch=sitecode, ylim=range(LgEC), col=sitecode+1, las=1, xlab="", ylab="")
axis(4, at=log10(pl), pl, las=1)
for(i in seq(sus)) {
sel <- meanz$sitecode==sus[i] & meanz$Event==sue[j]
lines(meanz$Date[sel], meanz$LgEC[sel], col=i+1, lwd=2)
#lines(spline(meanz$Date[sel], meanz$LgEC[sel], 1000), col=i+1, lwd=2)
}
}
mtext("Date", side=1, outer=TRUE)
mtext("E. coli concentration  (log scale)", side=2, outer=TRUE)
mtext("E. coli concentration  (artithmetic scale)", side=2, outer=TRUE)
par(mar=c(3, 3, 1, 1), mfrow=c(3, 1), oma=c(2, 2, 0, 2))
for(j in seq(sue)) {
sel <- Event==sue[j]
plot(Date[sel], LgEC[sel], pch=sitecode, ylim=range(LgEC), col=sitecode+1, las=1, xlab="", ylab="")
axis(4, at=log10(pl), pl, las=1)
for(i in seq(sus)) {
sel <- meanz$sitecode==sus[i] & meanz$Event==sue[j]
lines(meanz$Date[sel], meanz$LgEC[sel], col=i+1, lwd=2)
#lines(spline(meanz$Date[sel], meanz$LgEC[sel], 1000), col=i+1, lwd=2)
}
}
mtext("Date", side=1, outer=TRUE)
mtext("E. coli concentration  (log scale)", side=2, outer=TRUE)
mtext("E. coli concentration  (artithmetic scale)", side=4, outer=TRUE)
windows(h=9, w=6.5)
par(mar=c(3, 3, 1, 3), mfrow=c(3, 1), oma=c(2, 2, 0, 2))
for(j in seq(sue)) {
sel <- Event==sue[j]
plot(Date[sel], LgEC[sel], pch=sitecode, ylim=range(LgEC), col=sitecode+1, las=1, xlab="", ylab="")
axis(4, at=log10(pl), pl, las=1)
for(i in seq(sus)) {
sel <- meanz$sitecode==sus[i] & meanz$Event==sue[j]
lines(meanz$Date[sel], meanz$LgEC[sel], col=i+1, lwd=2)
#lines(spline(meanz$Date[sel], meanz$LgEC[sel], 1000), col=i+1, lwd=2)
}
}
mtext("Date", side=1, outer=TRUE)
mtext("E. coli concentration  (log scale)", side=2, outer=TRUE)
mtext("E. coli concentration  (artithmetic scale)", side=4, outer=TRUE)
# look at design
table(paste(Event, EventTime, Date), paste(Site, Replicate))
sus <- sort(unique(sitecode))
sue <- sort(unique(Event))
meanz <- aggregate(LgEC ~ Date + sitecode + Event, dat, mean)
pl <- prettylog(10^LgEC, lead=1, extra=0)
windows(h=9, w=6.5)
par(mar=c(3, 3, 1, 3), mfrow=c(3, 1), oma=c(2, 2, 0, 2))
for(j in seq(sue)) {
sel <- Event==sue[j]
plot(Date[sel], LgEC[sel], pch=sitecode, ylim=range(LgEC), col=sitecode+1, las=1, xlab="", ylab="")
axis(4, at=log10(pl), pl, las=1)
for(i in seq(sus)) {
sel2 <- meanz$sitecode==sus[i] & meanz$Event==sue[j]
lines(meanz$Date[sel2], meanz$LgEC[sel2], col=i+1, lwd=2)
}
}
mtext("Date", side=1, outer=TRUE)
mtext("E. coli concentration  (log scale)", side=2, outer=TRUE)
mtext("E. coli concentration  (artithmetic scale)", side=4, outer=TRUE)
meanz
j
i <- 1
sel2 <- meanz$sitecode==sus[i] & meanz$Event==sue[j]
meanz[sel2, ]
dat[Event==sue[j] & sitecode==sus[i], ]
windows(h=9, w=6.5)
par(mar=c(3, 3, 1, 3), mfrow=c(3, 1), oma=c(2, 2, 0, 2))
for(j in seq(sue)) {
sel <- Event==sue[j]
plot(Date[sel], LgEC[sel], pch=sitecode[sel], ylim=range(LgEC), col=sitecode+1, las=1, xlab="", ylab="")
axis(4, at=log10(pl), pl, las=1)
for(i in seq(sus)) {
sel2 <- meanz$sitecode==sus[i] & meanz$Event==sue[j]
lines(meanz$Date[sel2], meanz$LgEC[sel2], col=i+1, lwd=2)
}
}
mtext("Date", side=1, outer=TRUE)
mtext("E. coli concentration  (log scale)", side=2, outer=TRUE)
mtext("E. coli concentration  (artithmetic scale)", side=4, outer=TRUE)
windows(h=9, w=6.5)
par(mar=c(3, 3, 1, 3), mfrow=c(3, 1), oma=c(2, 2, 0, 2))
for(j in seq(sue)) {
sel <- Event==sue[j]
plot(Date[sel], LgEC[sel], pch=sitecode[sel], col=sitecode[sel]+1, ylim=range(LgEC), las=1, xlab="", ylab="")
axis(4, at=log10(pl), pl, las=1)
for(i in seq(sus)) {
sel2 <- meanz$sitecode==sus[i] & meanz$Event==sue[j]
lines(meanz$Date[sel2], meanz$LgEC[sel2], col=i+1, lwd=2)
}
}
mtext("Date", side=1, outer=TRUE)
mtext("E. coli concentration  (log scale)", side=2, outer=TRUE)
mtext("E. coli concentration  (artithmetic scale)", side=4, outer=TRUE)
par(mar=c(3, 3, 1, 3), mfrow=c(3, 1), oma=c(2, 2, 2, 2))
for(j in seq(sue)) {
sel <- Event==sue[j]
plot(Date[sel], LgEC[sel], pch=sitecode[sel], col=sitecode[sel]+1, ylim=range(LgEC), las=1, xlab="", ylab="")
axis(4, at=log10(pl), pl, las=1)
for(i in seq(sus)) {
sel2 <- meanz$sitecode==sus[i] & meanz$Event==sue[j]
lines(meanz$Date[sel2], meanz$LgEC[sel2], col=i+1, lwd=2)
}
}
mtext("Date", side=1, outer=TRUE)
mtext("E. coli concentration", side=2, outer=TRUE)
mtext("(log scale)", side=2, outer=TRUE)
mtext("(artithmetic scale)", side=4, outer=TRUE)
par(mar=c(3, 3, 1, 3), mfrow=c(3, 1), oma=c(2, 2, 2, 2))
for(j in seq(sue)) {
sel <- Event==sue[j]
plot(Date[sel], LgEC[sel], pch=sitecode[sel], col=sitecode[sel]+1, ylim=range(LgEC), las=1, xlab="", ylab="")
axis(4, at=log10(pl), pl, las=1)
for(i in seq(sus)) {
sel2 <- meanz$sitecode==sus[i] & meanz$Event==sue[j]
lines(meanz$Date[sel2], meanz$LgEC[sel2], col=i+1, lwd=2)
}
}
mtext("Date", side=1, outer=TRUE)
mtext("E. coli concentration", side=3, outer=TRUE)
mtext("(log scale)", side=2, outer=TRUE)
mtext("(artithmetic scale)", side=4, outer=TRUE)
sus <- sort(unique(sitecode))
sue <- sort(unique(Event))
meanz <- aggregate(LgEC ~ Date + sitecode + Event, dat, mean)
pl <- prettylog(10^LgEC, lead=c(1, 5) extra=0)
windows(h=9, w=6.5)
par(mar=c(3, 3, 1, 3), mfrow=c(3, 1), oma=c(2, 2, 2, 2))
for(j in seq(sue)) {
sel <- Event==sue[j]
plot(Date[sel], LgEC[sel], pch=sitecode[sel], col=sitecode[sel]+1, ylim=range(LgEC), las=1, xlab="", ylab="")
axis(4, at=log10(pl), pl, las=1)
for(i in seq(sus)) {
sel2 <- meanz$sitecode==sus[i] & meanz$Event==sue[j]
lines(meanz$Date[sel2], meanz$LgEC[sel2], col=i+1, lwd=2)
}
}
mtext("Date", side=1, outer=TRUE)
mtext("E. coli concentration", side=3, outer=TRUE)
mtext("(log scale)", side=2, outer=TRUE)
mtext("(artithmetic scale)", side=4, outer=TRUE)
# look at design
table(paste(Event, EventTime, Date), paste(Site, Replicate))
sus <- sort(unique(sitecode))
sue <- sort(unique(Event))
meanz <- aggregate(LgEC ~ Date + sitecode + Event, dat, mean)
pl <- prettylog(10^LgEC, lead=c(1, 5), extra=0)
windows(h=9, w=6.5)
par(mar=c(3, 3, 1, 3), mfrow=c(3, 1), oma=c(2, 2, 2, 2))
for(j in seq(sue)) {
sel <- Event==sue[j]
plot(Date[sel], LgEC[sel], pch=sitecode[sel], col=sitecode[sel]+1, ylim=range(LgEC), las=1, xlab="", ylab="")
axis(4, at=log10(pl), pl, las=1)
for(i in seq(sus)) {
sel2 <- meanz$sitecode==sus[i] & meanz$Event==sue[j]
lines(meanz$Date[sel2], meanz$LgEC[sel2], col=i+1, lwd=2)
}
}
mtext("Date", side=1, outer=TRUE)
mtext("E. coli concentration", side=3, outer=TRUE)
mtext("(log scale)", side=2, outer=TRUE)
mtext("(artithmetic scale)", side=4, outer=TRUE)
sus <- sort(unique(sitecode))
sue <- sort(unique(Event))
meanz <- aggregate(LgEC ~ Date + sitecode + Event, dat, mean)
pl <- prettylog(10^LgEC, lead=c(1, 3, 5), extra=0)
windows(h=9, w=6.5)
par(mar=c(3, 3, 1, 3), mfrow=c(3, 1), oma=c(2, 2, 2, 2))
for(j in seq(sue)) {
sel <- Event==sue[j]
plot(Date[sel], LgEC[sel], pch=sitecode[sel], col=sitecode[sel]+1, ylim=range(LgEC), las=1, xlab="", ylab="")
axis(4, at=log10(pl), pl, las=1)
for(i in seq(sus)) {
sel2 <- meanz$sitecode==sus[i] & meanz$Event==sue[j]
lines(meanz$Date[sel2], meanz$LgEC[sel2], col=i+1, lwd=2)
}
}
mtext("Date", side=1, outer=TRUE)
mtext("E. coli concentration", side=3, outer=TRUE)
mtext("(log scale)", side=2, outer=TRUE)
mtext("(artithmetic scale)", side=4, outer=TRUE)
sus <- sort(unique(sitecode))
sue <- sort(unique(Event))
meanz <- aggregate(LgEC ~ Date + sitecode + Event, dat, mean)
pl <- prettylog(10^LgEC, lead=c(1, 2, 5), extra=0)
windows(h=9, w=6.5)
par(mar=c(3, 3, 1, 3), mfrow=c(3, 1), oma=c(2, 2, 2, 2))
for(j in seq(sue)) {
sel <- Event==sue[j]
plot(Date[sel], LgEC[sel], pch=sitecode[sel], col=sitecode[sel]+1, ylim=range(LgEC), las=1, xlab="", ylab="")
axis(4, at=log10(pl), pl, las=1)
for(i in seq(sus)) {
sel2 <- meanz$sitecode==sus[i] & meanz$Event==sue[j]
lines(meanz$Date[sel2], meanz$LgEC[sel2], col=i+1, lwd=2)
}
}
mtext("Date", side=1, outer=TRUE)
mtext("E. coli concentration", side=3, outer=TRUE)
mtext("(log scale)", side=2, outer=TRUE)
mtext("(artithmetic scale)", side=4, outer=TRUE)
windows(h=9, w=6.5)
par(mar=c(3, 3, 1, 3), mfrow=c(3, 1), oma=c(2, 2, 2, 2))
for(j in seq(sue)) {
sel <- Event==sue[j]
plot(Date[sel], LgEC[sel], pch=sitecode[sel], col=sitecode[sel]+1, ylim=range(LgEC), las=1, xlab="", ylab="")
axis(4, at=log10(pl), pl, las=1)
mtext(paste("Event", j), side=3, line=-2, adj=0.9)
for(i in seq(sus)) {
sel2 <- meanz$sitecode==sus[i] & meanz$Event==sue[j]
lines(meanz$Date[sel2], meanz$LgEC[sel2], col=i+1, lwd=2)
}
}
mtext("Date", side=1, outer=TRUE)
mtext("E. coli concentration", side=3, outer=TRUE)
mtext("(log scale)", side=2, outer=TRUE)
mtext("(artithmetic scale)", side=4, outer=TRUE)
windows(h=9, w=6.5)
par(mar=c(3, 3, 1, 3), mfrow=c(3, 1), oma=c(2, 2, 2, 2))
for(j in seq(sue)) {
sel <- Event==sue[j]
plot(Date[sel], LgEC[sel], pch=sitecode[sel], col=sitecode[sel]+1, ylim=range(LgEC), las=1, xlab="", ylab="")
axis(4, at=log10(pl), pl, las=1)
mtext(paste("Event", j), side=3, line=-2, adj=0.98)
for(i in seq(sus)) {
sel2 <- meanz$sitecode==sus[i] & meanz$Event==sue[j]
lines(meanz$Date[sel2], meanz$LgEC[sel2], col=i+1, lwd=2)
}
}
mtext("Date", side=1, outer=TRUE)
mtext("E. coli concentration", side=3, outer=TRUE)
mtext("(log scale)", side=2, outer=TRUE)
mtext("(artithmetic scale)", side=4, outer=TRUE)
sort(unique(Site))
head(dat)
dat
windows(h=9, w=6.5)
par(mar=c(3, 3, 1, 3), mfrow=c(3, 1), oma=c(2, 2, 2, 2))
for(j in seq(sue)) {
sel <- Event==sue[j]
plot(Date[sel], LgEC[sel], type="n", ylim=range(LgEC), las=1, xlab="", ylab="")
text(Date[sel], LgEC[sel], c("C", "D", "K")[sitecode[sel]], col=sitecode[sel]+1)
axis(4, at=log10(pl), pl, las=1)
mtext(paste("Event", j), side=3, line=-2, adj=0.98)
for(i in seq(sus)) {
sel2 <- meanz$sitecode==sus[i] & meanz$Event==sue[j]
lines(meanz$Date[sel2], meanz$LgEC[sel2], col=i+1, lwd=2)
}
if(j==3) {
legend("bottom", 
}
}
mtext("Date", side=1, outer=TRUE)
mtext("E. coli concentration", side=3, outer=TRUE)
mtext("(log scale)", side=2, outer=TRUE)
mtext("(artithmetic scale)", side=4, outer=TRUE)
windows(h=9, w=6.5)
par(mar=c(3, 3, 1, 3), mfrow=c(3, 1), oma=c(2, 2, 2, 2))
for(j in seq(sue)) {
sel <- Event==sue[j]
plot(Date[sel], LgEC[sel], type="n", ylim=range(LgEC), las=1, xlab="", ylab="")
text(Date[sel], LgEC[sel], c("C", "D", "K")[sitecode[sel]], col=sitecode[sel]+1)
axis(4, at=log10(pl), pl, las=1)
mtext(paste("Event", j), side=3, line=-2, adj=0.98)
for(i in seq(sus)) {
sel2 <- meanz$sitecode==sus[i] & meanz$Event==sue[j]
lines(meanz$Date[sel2], meanz$LgEC[sel2], col=i+1, lwd=2)
}
}
mtext("Date", side=1, outer=TRUE)
mtext("E. coli concentration", side=3, outer=TRUE)
mtext("(log scale)", side=2, outer=TRUE)
mtext("(artithmetic scale)", side=4, outer=TRUE)
table(paste(Event, EventTime, Date), paste(Site, Replicate))
par(mar=c(3, 3, 1, 3), mfrow=c(3, 1), oma=c(2, 2, 2, 2))
for(j in seq(sue)) {
sel <- Event==sue[j]
plot(Date[sel], LgEC[sel], type="n", ylim=range(LgEC), las=1, xlab="", ylab="")
text(Date[sel], LgEC[sel], c("C", "D", "K")[sitecode[sel]], col=sitecode[sel]+1)
axis(4, at=log10(pl), pl, las=1)
mtext(paste("Event", j), side=3, line=-2, adj=0.98)
for(i in seq(sus)) {
sel2 <- meanz$sitecode==sus[i] & meanz$Event==sue[j]
lines(meanz$Date[sel2], meanz$LgEC[sel2], col=i+1, lwd=2)
}
}
mtext("Date", side=1, outer=TRUE)
mtext("E. coli Density", side=3, outer=TRUE)
mtext("(log scale)", side=2, outer=TRUE)
mtext("(artithmetic scale)", side=4, outer=TRUE)
dim(meanz)
fit <- glm(LgEC ~ as.factor(Date) + as.factor(Site), data=meanz)
head(meanz)
fit <- glm(LgEC ~ as.factor(Date) + as.factor(sitecode), data=meanz)
summary(fit)
fit <- aov(LgEC ~ as.factor(Date) + as.factor(sitecode), data=meanz)
summary(fit)
meanz$p <- fit$fitted
head(meanz)
meanz$Date + 1
meanz$Date + 1000
meanz$Date + 60*60*24
meanz$Date2 <- meanz$Date + 60*60*24
head(meanz)
meanz$r <- fit$resid
fit <- aov(LgEC ~ as.factor(Date) + as.factor(sitecode), data=meanz)
meanz$r1 <- fit$resid
meanz$r2 <- fit$resid
meanz$Date2 <- meanz$Date + 60*60*24
dat1 <- meanz[, c("Date", "Date2", "sitecode", "r1")]
dat2 <- meanz[, c("Date", "sitecode", "r2")]
merge(dat1, dat2, by.x=c("Date2", "sitecode"), by.y=c("Date", "sitecode"))
dat1 <- meanz[, c("Date", "Date2", "sitecode", "r1")]
dat2 <- meanz[, c("Date", "sitecode", "r2")]
dat12 <- merge(dat1, dat2, by.x=c("Date2", "sitecode"), by.y=c("Date", "sitecode"))
windows()
plot(dat12$r1, dat12$r2)
cor.texcor.test(dat12$r1, dat12$r2)
cor.test(dat12$r1, dat12$r2)
meanz
head(meanz)
meanz <- aggregate(LgEC ~ Date + Site + sitecode + Event, dat, mean)
write.csv(meanz[, c("Date", "Site", "Event", "LgEC")], "C:/JVA/Consult/Shively/SnowmeltMeans.csv")
write.csv(meanz[, c("Date", "Site", "Event", "LgEC")], "C:/JVA/Consult/Shively/SnowmeltMeans.csv", row.names=FALSE)
unique(dat$Site)
cleanup()
q()
?cheat
?startrtf
Date()
sysdate
SysDate
Sysdate
date
date()
??sysdate
Sys.date
Sys.Date
Sys.Date()
?heading
date()
?readJPEG
library(jpeg)
plotno
noplot
ls()
search()
ls(4)
?plotblank
plotblank()
pusr <- par("usr")
rasterImage(readJPEG("C:/JVA/Consult/Yule/Superior Coreg/FishBoundary.jpg"), pusr[1], pusr[3], pusr[2], pusr[4])
?rasterImage
?readJPEG
img <- readJPEG("C:/JVA/Consult/Yule/Superior Coreg/FishBoundary.jpg")
im
img
dim(img)
img <- readJPEG("C:/JVA/Consult/Yule/Superior Coreg/FishBoundary.jpg")
eqscplot(1, 1, xlim=c(1, dim(img)[1]), ylim=c(1, dim(img)[2]), type="n", xlab="", ylab="", axes=FALSE)
pusr <- par("usr")
rasterImage(img, pusr[1], pusr[3], pusr[2], pusr[4])
img <- readJPEG("C:/JVA/Consult/Yule/Superior Coreg/FishBoundary.jpg")
eqscplot(1, 1, xlim=c(1, dim(img)[1]), ylim=c(1, dim(img)[2]), type="n", xlab="", ylab="", axes=FALSE)
pusr <- par("usr")
rasterImage(img, pusr[1], pusr[3], pusr[2], pusr[4])
?par
dim(img)
dim(img)[1]/dim(img)[2]
dim(img)[1]/dim(img)[2]*6.5
img <- readJPEG("C:/JVA/Consult/Yule/Superior Coreg/FishBoundary.jpg")
par(fin=c(6.5, dim(img)[1]/dim(img)[2]*6.5)
plotblank()
pusr <- par("usr")
rasterImage(img, pusr[1], pusr[3], pusr[2], pusr[4])
img <- readJPEG("C:/JVA/Consult/Yule/Superior Coreg/FishBoundary.jpg")
par(fin=c(6.5, dim(img)[1]/dim(img)[2]*6.5))
plotblank()
pusr <- par("usr")
rasterImage(img, pusr[1], pusr[3], pusr[2], pusr[4])
img <- readJPEG("C:/JVA/Consult/Yule/Superior Coreg/FishBoundary.jpg")
par(fin=c(6.5, dim(img)[1]/dim(img)[2]*6.5), mar=rep(0, 4))
plotblank(axes=FALSE)
pusr <- par("usr")
rasterImage(img, pusr[1], pusr[3], pusr[2], pusr[4])
img <- readJPEG("C:/JVA/Consult/Yule/Superior Coreg/FishBoundary.jpg")
par(fig=c(6.5, dim(img)[1]/dim(img)[2]*6.5), mar=rep(0, 4))
plotblank(axes=FALSE)
pusr <- par("usr")
rasterImage(img, pusr[1], pusr[3], pusr[2], pusr[4])
img <- readJPEG("C:/JVA/Consult/Yule/Superior Coreg/FishBoundary.jpg")
par(fig=c(6.5, dim(img)[1]/dim(img)[2]*6.5), mar=rep(0, 4))
plotblank(axes=FALSE)
pusr <- par("usr")
rasterImage(img, pusr[1], pusr[3], pusr[2], pusr[4])
?par
img <- readJPEG("C:/JVA/Consult/Yule/Superior Coreg/FishBoundary.jpg")
windows(w=6.5, h=dim(img)[1]/dim(img)[2]*6.5)
par(mar=rep(0, 4))
plotblank(axes=FALSE)
pusr <- par("usr")
rasterImage(img, pusr[1], pusr[3], pusr[2], pusr[4])
figu
library(jpeg)
# read in the data
wb <- loadWorkbook("C:/JVA/Consult/Yule/Superior Coreg/2014 Caliper and SigmaScan Correction Data JVA.xlsx")
ydat <- readWorksheet(wb, sheet="Caliper & Sigma for Analyses", startRow=1)
kdat <- readWorksheet(wb, sheet="Koelz Superior Data", startRow=1)
dim(ydat)
head(ydat)
names(ydat)
stringin("sigma", names(ydat))
stringin("caliper", names(ydat))
Ptruss <- sort(stringin("sigma", names(ydat)))
Ctruss <- sort(stringin("caliper", names(ydat)))
cbind(Ptruss, Ctruss)
substring(Ptruss, 7)
truss
Ptruss <- sort(stringin("sigma", names(ydat)))
Ctruss <- sort(stringin("caliper", names(ydat)))
truss <- substring(Ptruss, 7)
truss
names(ydat)
Ptruss <- sort(stringin("sigma", names(ydat)))
Ctruss <- sort(stringin("caliper", names(ydat)))
truss <- substring(Ptruss, 7)
i <- 1
P <- ydat[, Ptruss[i]]
C <- ydat[, Ctruss[i]]
L <- ydat[, "CALIPER.L"]
S <- as.factor(ydat$SPECIES)
G <- as.factor(ydat$GROUP)
Y <- sqrt(P^2 - C^2)
P
C
P <- ydat[, Ptruss[i]]
C <- ydat[, Ctruss[i]]
L <- ydat[, "CALIPER.L"]
S <- as.factor(ydat$SPECIES)
G <- as.factor(ydat$GROUP)
Y <- P^2 - C^2
fit1i <- lm(Y ~ poly(L, 2)*S)
fit2i <- lm(Y ~ poly(L, 2)*G)
fit1 <- lm(Y ~ poly(L, 2) + S)
fit2 <- lm(Y ~ poly(L, 2) + G)
fit3 <- lm(Y ~ poly(L, 2))
fit4 <- lm(Y ~ 1)
G
G
G <- as.factor(ydat$TYPE)
fit1i <- lm(Y ~ poly(L, 2)*S)
fit2i <- lm(Y ~ poly(L, 2)*G)
fit1 <- lm(Y ~ poly(L, 2) + S)
fit2 <- lm(Y ~ poly(L, 2) + G)
fit3 <- lm(Y ~ poly(L, 2))
fit4 <- lm(Y ~ 1)
AICc(list(fit1i, fit2i, fit1, fit2, fit3, fit4))
?AICc
fit1 <- lm(Y ~ poly(L, 2)*S)
fit2 <- lm(Y ~ poly(L, 2) + S)
fit3 <- lm(Y ~ poly(L, 2)*G)
fit4 <- lm(Y ~ poly(L, 2) + G)
fit5 <- lm(Y ~ poly(L, 2))
fit6 <- lm(Y ~ 1)
res <- AICc(list(fit1, fit2, fit3, fit4, fit5, fit6))
res
res[res$daicc<2, ]
min(model[res$daicc<2]
)
min(res$model[res$daicc<2]
)
min(res$model[res$daicc<2])
Ptruss <- sort(stringin("sigma", names(ydat)))
Ctruss <- sort(stringin("caliper", names(ydat)))
truss <- substring(Ptruss, 7)
bestmodel <- rep(NA, length(truss))
for(i in seq_along(truss)) {
P <- ydat[, Ptruss[i]]
C <- ydat[, Ctruss[i]]
L <- ydat[, "CALIPER.L"]
S <- as.factor(ydat$SPECIES)
G <- as.factor(ydat$TYPE)
Y <- P^2 - C^2
if(truss[i]=="L") {
fit7 <- lm(Y ~ S)
fit8 <- lm(Y ~ G)
fit9 <- lm(Y ~ 1)
aic <- AICc(list(fit7, fit8, fit9))
bestmodel[i] <- max(res$model[res$daicc<2]) + 6
} else {
fit1 <- lm(Y ~ poly(L, 2)*S)
fit2 <- lm(Y ~ poly(L, 2) + S)
fit3 <- lm(Y ~ poly(L, 2)*G)
fit4 <- lm(Y ~ poly(L, 2) + G)
fit5 <- lm(Y ~ poly(L, 2))
fit6 <- lm(Y ~ 1)
aic <- AICc(list(fit1, fit2, fit3, fit4, fit5, fit6))
bestmodel[i] <- max(res$model[res$daicc<2])
}
}
cbind(truss, bestmodel)
data.frame(truss, bestmodel)
for(i in seq_along(truss)) {
P <- ydat[, Ptruss[i]]
C <- ydat[, Ctruss[i]]
L <- ydat[, "CALIPER.L"]
S <- as.factor(ydat$SPECIES)
G <- as.factor(ydat$TYPE)
Y <- P^2 - C^2
if(truss[i]=="L") {
fit7 <- lm(Y ~ S)
fit8 <- lm(Y ~ G)###
fit9 <- lm(Y ~ 1)
aic <- AICc(list(fit7, fit8, fit9))
print(truss[i])
print(aic)
bestmodel[i] <- max(res$model[res$daicc<2]) + 6
} else {
fit1 <- lm(Y ~ poly(L, 2)*S)
fit2 <- lm(Y ~ poly(L, 2) + S)###
fit3 <- lm(Y ~ poly(L, 2)*G)
fit4 <- lm(Y ~ poly(L, 2) + G)
fit5 <- lm(Y ~ poly(L, 2))
fit6 <- lm(Y ~ 1)
aic <- AICc(list(fit1, fit2, fit3, fit4, fit5, fit6))
print(truss[i])
print(aic)
bestmodel[i] <- max(res$model[res$daicc<2])
}
}
data.frame(truss, bestmodel)
rm(res)
Ptruss <- sort(stringin("sigma", names(ydat)))
Ctruss <- sort(stringin("caliper", names(ydat)))
truss <- substring(Ptruss, 7)
bestmodel <- rep(NA, length(truss))
for(i in seq_along(truss)) {
P <- ydat[, Ptruss[i]]
C <- ydat[, Ctruss[i]]
L <- ydat[, "CALIPER.L"]
S <- as.factor(ydat$SPECIES)
G <- as.factor(ydat$TYPE)
Y <- P^2 - C^2
if(truss[i]=="L") {
fit7 <- lm(Y ~ S)
fit8 <- lm(Y ~ G)###
fit9 <- lm(Y ~ 1)
aic <- AICc(list(fit7, fit8, fit9))
print(truss[i])
print(aic)
bestmodel[i] <- max(aic$model[aic$daicc<2]) + 6
} else {
fit1 <- lm(Y ~ poly(L, 2)*S)
fit2 <- lm(Y ~ poly(L, 2) + S)###
fit3 <- lm(Y ~ poly(L, 2)*G)
fit4 <- lm(Y ~ poly(L, 2) + G)
fit5 <- lm(Y ~ poly(L, 2))
fit6 <- lm(Y ~ 1)
aic <- AICc(list(fit1, fit2, fit3, fit4, fit5, fit6))
print(truss[i])
print(aic)
bestmodel[i] <- max(aic$model[aic$daicc<2])
}
}
data.frame(truss, bestmodel)
res <- data.frame(truss, bestmodel)
res[order(-res$bestmodel), ]
dfclip
dfclip()
dput(dfclip())
dput(dfclip())
dput(dfclip())
exp.none <- c("O", "SD", "SA", "D", "DH", "DB", "DA", "AH", "AB", "AD")
exp.some <- c("S", "H", "E", "V", "AV", "P", "PV")
exp.unkn <- c("AV.V", "PV.P")
match(exp.none, truss)
match(exp.some, truss)
match(exp.unkn, truss)
truss[12]
exp.none <- c("L", "O", "SD", "SA", "D", "DH", "DB", "DA", "AH", "AB", "AD")
exp.some <- c("M", "S", "H", "E", "V", "AV", "P", "PV")
exp.unkn <- c("AV.V", "PV.P")
match(exp.none, truss)
match(exp.some, truss)
match(exp.unkn, truss)
length(truss)
expect <- rep("none", length(truss))
expect[truss %in% exp.some] <- "some"
expect[truss %in% exp.unkn] <- "unkn"
expect
res <- data.frame(truss, expect, bestmodel)
res[order(-res$bestmodel, res$expect), ]
Ptruss <- sort(stringin("sigma", names(ydat)))
Ctruss <- sort(stringin("caliper", names(ydat)))
truss <- substring(Ptruss, 7)
bestmodel <- rep(NA, length(truss))
for(i in seq_along(truss)) {
P <- ydat[, Ptruss[i]]
C <- ydat[, Ctruss[i]]
L <- ydat[, "CALIPER.L"]
S <- as.factor(ydat$SPECIES)
G <- as.factor(ydat$TYPE)
Y <- P^2 - C^2
if(truss[i]=="L") {
fit7 <- lm(Y ~ S)
fit8 <- lm(Y ~ G)###
fit9 <- lm(Y ~ 1)
aic <- AICc(list(fit7, fit8, fit9))
print(truss[i])
print(aic)
bestmodel[i] <- c(2.5, 4.5, 6)[max(aic$model[aic$daicc<2])]
} else {
fit1 <- lm(Y ~ poly(L, 2)*S)
fit2 <- lm(Y ~ poly(L, 2) + S)###
fit3 <- lm(Y ~ poly(L, 2)*G)
fit4 <- lm(Y ~ poly(L, 2) + G)
fit5 <- lm(Y ~ poly(L, 2))
fit6 <- lm(Y ~ 1)
aic <- AICc(list(fit1, fit2, fit3, fit4, fit5, fit6))
print(truss[i])
print(aic)
bestmodel[i] <- max(aic$model[aic$daicc<2])
}
}
res <- data.frame(truss, expect, bestmodel)
res[order(-res$bestmodel, res$expect), ]
exp.none <- c("L", "O", "SD", "SA", "D", "DH", "DB", "DA", "AH", "AB", "AD")
exp.some <- c("M", "S", "H", "E", "V", "AV", "P", "PV")
exp.unkn <- c("AV.V", "PV.P")
expect <- rep("6 none", length(truss))
expect[truss %in% exp.some] <- "1-5 some"
expect[truss %in% exp.unkn] <- "? unkn"
figimg <- function() {
par(mar=rep(0, 4))
plotblank(axes=FALSE)
pusr <- par("usr")
rasterImage(img, pusr[1], pusr[3], pusr[2], pusr[4])
}
img <- readJPEG("C:/JVA/Consult/Yule/Superior Coreg/FishBoundary.jpg")
figu("The 'boundary' of a side-viewed fish.", FIG=figimg, w=6.5, h=dim(img)[1]/dim(img)[2]*6.5)
img <- readJPEG("C:/JVA/Consult/Yule/Superior Coreg/TopView.jpg")
figu("The relation between truss measures displayed on a top-viewed fish, when one of the points does not lie on the 'boundary' of a side-viewed fish.", 
FIG=figimg, w=6.5, h=dim(img)[1]/dim(img)[2]*6.5)
Ptruss <- sort(stringin("sigma", names(ydat)))
Ctruss <- sort(stringin("caliper", names(ydat)))
truss <- substring(Ptruss, 7)
bestmodel <- rep(NA, length(truss))
for(i in seq_along(truss)) {
P <- ydat[, Ptruss[i]]
C <- ydat[, Ctruss[i]]
L <- ydat[, "CALIPER.L"]
S <- as.factor(ydat$SPECIES)
G <- as.factor(ydat$TYPE)
Y <- P^2 - C^2
if(truss[i]=="L") {
fit7 <- lm(Y ~ S)
fit8 <- lm(Y ~ G)###
fit9 <- lm(Y ~ 1)
aic <- AICc(list(fit7, fit8, fit9))
print(truss[i])
print(aic)
bestmodel[i] <- c(2.5, 4.5, 6)[max(aic$model[aic$daicc<2])]
} else {
fit1 <- lm(Y ~ poly(L, 2)*S)
fit2 <- lm(Y ~ poly(L, 2) + S)###
fit3 <- lm(Y ~ poly(L, 2)*G)
fit4 <- lm(Y ~ poly(L, 2) + G)
fit5 <- lm(Y ~ poly(L, 2))
fit6 <- lm(Y ~ 1)
aic <- AICc(list(fit1, fit2, fit3, fit4, fit5, fit6))
print(truss[i])
print(aic)
bestmodel[i] <- max(aic$model[aic$daicc<2])
}
}
res <- data.frame(truss, expect, bestmodel)
res[order(-res$bestmodel, res$expect), ]
Ptruss <- sort(stringin("sigma", names(ydat)))
Ctruss <- sort(stringin("caliper", names(ydat)))
truss <- substring(Ptruss, 7)
bestmodel <- rep(NA, length(truss))
for(i in seq_along(truss)) {
P <- ydat[, Ptruss[i]]
C <- ydat[, Ctruss[i]]
L <- ydat[, "CALIPER.L"]
S <- as.factor(ydat$SPECIES)
G <- as.factor(ydat$TYPE)
Y <- P^2 - C^2
if(truss[i]=="L") {
fit1 <- lm(Y ~ 1)
fit2.5 <- lm(Y ~ G)
fit4.5 <- lm(Y ~ S)
aic <- AICc(list(fit7, fit8, fit9))
print(truss[i])
print(aic)
bestmodel[i] <- c(1, 2.5, 4.5)[min(aic$model[aic$daicc<2])]
} else {
fit1 <- lm(Y ~ 1)
fit2 <- lm(Y ~ poly(L, 2))
fit3 <- lm(Y ~ poly(L, 2) + G)
fit4 <- lm(Y ~ poly(L, 2)*G)
fit5 <- lm(Y ~ poly(L, 2) + S)
fit6 <- lm(Y ~ poly(L, 2)*S)
aic <- AICc(list(fit1, fit2, fit3, fit4, fit5, fit6))
print(truss[i])
print(aic)
bestmodel[i] <- min(aic$model[aic$daicc<2])
}
}
res <- data.frame(truss, expect, bestmodel)
res[order(res$expect, res$bestmodel), ]
exp.none <- c("L", "O", "SD", "SA", "D", "DH", "DB", "DA", "AH", "AB", "AD")
exp.some <- c("M", "S", "H", "E", "V", "AV", "P", "PV")
exp.unkn <- c("AV.V", "PV.P")
expect <- rep("1 none", length(truss))
expect[truss %in% exp.some] <- "2-6 some"
expect[truss %in% exp.unkn] <- "? unkn"
figimg <- function() {
par(mar=rep(0, 4))
plotblank(axes=FALSE)
pusr <- par("usr")
rasterImage(img, pusr[1], pusr[3], pusr[2], pusr[4])
}
img <- readJPEG("C:/JVA/Consult/Yule/Superior Coreg/FishBoundary.jpg")
figu("The 'boundary' of a side-viewed fish.", FIG=figimg, w=6.5, h=dim(img)[1]/dim(img)[2]*6.5)
img <- readJPEG("C:/JVA/Consult/Yule/Superior Coreg/TopView.jpg")
figu("The relation between truss measures displayed on a top-viewed fish, when one of the points does not lie on the 'boundary' of a side-viewed fish.", 
FIG=figimg, w=6.5, h=dim(img)[1]/dim(img)[2]*6.5)
Ptruss <- sort(stringin("sigma", names(ydat)))
Ctruss <- sort(stringin("caliper", names(ydat)))
truss <- substring(Ptruss, 7)
bestmodel <- rep(NA, length(truss))
for(i in seq_along(truss)) {
P <- ydat[, Ptruss[i]]
C <- ydat[, Ctruss[i]]
L <- ydat[, "CALIPER.L"]
S <- as.factor(ydat$SPECIES)
G <- as.factor(ydat$TYPE)
Y <- P^2 - C^2
if(truss[i]=="L") {
fit1 <- lm(Y ~ 1)
fit2.5 <- lm(Y ~ G)
fit4.5 <- lm(Y ~ S)
aic <- AICc(list(fit7, fit8, fit9))
print(truss[i])
print(aic)
bestmodel[i] <- c(1, 2.5, 4.5)[min(aic$model[aic$daicc<2])]
} else {
fit1 <- lm(Y ~ 1)
fit2 <- lm(Y ~ poly(L, 2))
fit3 <- lm(Y ~ poly(L, 2) + G)
fit4 <- lm(Y ~ poly(L, 2)*G)
fit5 <- lm(Y ~ poly(L, 2) + S)
fit6 <- lm(Y ~ poly(L, 2)*S)
aic <- AICc(list(fit1, fit2, fit3, fit4, fit5, fit6))
print(truss[i])
print(aic)
bestmodel[i] <- min(aic$model[aic$daicc<2])
}
}
res <- data.frame(truss, expect, bestmodel)
res[order(res$expect, res$bestmodel), ]
exp.none <- c("L", "O", "SD", "SA", "D", "DH", "DB", "DA", "AH", "AB", "AD")
exp.some <- c("M", "S", "H", "E", "V", "AV", "P", "PV")
exp.unkn <- c("AV.V", "PV.P")
expect <- rep("1 none", length(truss))
expect[truss %in% exp.some] <- "2-6 some"
expect[truss %in% exp.unkn] <- "7 unkn"
figimg <- function() {
par(mar=rep(0, 4))
plotblank(axes=FALSE)
pusr <- par("usr")
rasterImage(img, pusr[1], pusr[3], pusr[2], pusr[4])
}
img <- readJPEG("C:/JVA/Consult/Yule/Superior Coreg/FishBoundary.jpg")
figu("The 'boundary' of a side-viewed fish.", FIG=figimg, w=6.5, h=dim(img)[1]/dim(img)[2]*6.5)
img <- readJPEG("C:/JVA/Consult/Yule/Superior Coreg/TopView.jpg")
figu("The relation between truss measures displayed on a top-viewed fish, when one of the points does not lie on the 'boundary' of a side-viewed fish.", 
FIG=figimg, w=6.5, h=dim(img)[1]/dim(img)[2]*6.5)
Ptruss <- sort(stringin("sigma", names(ydat)))
Ctruss <- sort(stringin("caliper", names(ydat)))
truss <- substring(Ptruss, 7)
bestmodel <- rep(NA, length(truss))
for(i in seq_along(truss)) {
P <- ydat[, Ptruss[i]]
C <- ydat[, Ctruss[i]]
L <- ydat[, "CALIPER.L"]
S <- as.factor(ydat$SPECIES)
G <- as.factor(ydat$TYPE)
Y <- P^2 - C^2
if(truss[i]=="L") {
fit1 <- lm(Y ~ 1)
fit2.5 <- lm(Y ~ G)
fit4.5 <- lm(Y ~ S)
aic <- AICc(list(fit7, fit8, fit9))
print(truss[i])
print(aic)
bestmodel[i] <- c(1, 2.5, 4.5)[min(aic$model[aic$daicc<2])]
} else {
fit1 <- lm(Y ~ 1)
fit2 <- lm(Y ~ poly(L, 2))
fit3 <- lm(Y ~ poly(L, 2) + G)
fit4 <- lm(Y ~ poly(L, 2)*G)
fit5 <- lm(Y ~ poly(L, 2) + S)
fit6 <- lm(Y ~ poly(L, 2)*S)
aic <- AICc(list(fit1, fit2, fit3, fit4, fit5, fit6))
print(truss[i])
print(aic)
bestmodel[i] <- min(aic$model[aic$daicc<2])
}
}
res <- data.frame(truss, expect, bestmodel)
res[order(res$expect, res$bestmodel), ]
res <- data.frame(truss, expect, bestmodel)
res[order(res$expect, res$bestmodel, res$truss), ]
length(truss)
windows()
par(mar=c(0, 0, 0, 0), oma=c(2, 2, 1, 1))
for(i in seq_along(truss)) {
P <- ydat[, Ptruss[i]]
C <- ydat[, Ctruss[i]]
L <- ydat[, "CALIPER.L"]
S <- as.factor(ydat$SPECIES)
G <- as.factor(ydat$TYPE)
Y <- P^2 - C^2
plot(C, P, pch=as.numeric(S), col=as.numeric(S))
if(truss[i]=="L") {
fit1 <- lm(Y ~ 1)
fit2.5 <- lm(Y ~ G)
fit4.5 <- lm(Y ~ S)
aic <- AICc(list(fit7, fit8, fit9))
print(truss[i])
print(aic)
bestmodel[i] <- c(1, 2.5, 4.5)[min(aic$model[aic$daicc<2])]
} else {
fit1 <- lm(Y ~ 1)
fit2 <- lm(Y ~ poly(L, 2))
fit3 <- lm(Y ~ poly(L, 2) + G)
fit4 <- lm(Y ~ poly(L, 2)*G)
fit5 <- lm(Y ~ poly(L, 2) + S)
fit6 <- lm(Y ~ poly(L, 2)*S)
aic <- AICc(list(fit1, fit2, fit3, fit4, fit5, fit6))
print(truss[i])
print(aic)
bestmodel[i] <- min(aic$model[aic$daicc<2])
}
}
windows(w=9, h=6.5)
par(mfrow=c(3, 7), mar=c(0, 0, 0, 0), oma=c(2, 2, 1, 1))
for(i in seq_along(truss)) {
P <- ydat[, Ptruss[i]]
C <- ydat[, Ctruss[i]]
L <- ydat[, "CALIPER.L"]
S <- as.factor(ydat$SPECIES)
G <- as.factor(ydat$TYPE)
Y <- P^2 - C^2
plot(C, P, pch=as.numeric(S), col=as.numeric(S))
if(truss[i]=="L") {
fit1 <- lm(Y ~ 1)
fit2.5 <- lm(Y ~ G)
fit4.5 <- lm(Y ~ S)
aic <- AICc(list(fit7, fit8, fit9))
print(truss[i])
print(aic)
bestmodel[i] <- c(1, 2.5, 4.5)[min(aic$model[aic$daicc<2])]
} else {
fit1 <- lm(Y ~ 1)
fit2 <- lm(Y ~ poly(L, 2))
fit3 <- lm(Y ~ poly(L, 2) + G)
fit4 <- lm(Y ~ poly(L, 2)*G)
fit5 <- lm(Y ~ poly(L, 2) + S)
fit6 <- lm(Y ~ poly(L, 2)*S)
aic <- AICc(list(fit1, fit2, fit3, fit4, fit5, fit6))
print(truss[i])
print(aic)
bestmodel[i] <- min(aic$model[aic$daicc<2])
}
}
windows(w=9, h=6.5)
par(mfrow=c(3, 7), mar=c(0, 0, 0, 0), oma=c(2, 2, 1, 1))
for(i in seq_along(truss)) {
P <- ydat[, Ptruss[i]]
C <- ydat[, Ctruss[i]]
L <- ydat[, "CALIPER.L"]
S <- as.factor(ydat$SPECIES)
G <- as.factor(ydat$TYPE)
Y <- P^2 - C^2
plot(C, P, pch=as.numeric(S), col=as.numeric(S), xlab="", ylab="", axes=FALSE)
abline(0, 1)
box()
if(truss[i]=="L") {
fit1 <- lm(Y ~ 1)
fit2.5 <- lm(Y ~ G)
fit4.5 <- lm(Y ~ S)
aic <- AICc(list(fit7, fit8, fit9))
print(truss[i])
print(aic)
bestmodel[i] <- c(1, 2.5, 4.5)[min(aic$model[aic$daicc<2])]
} else {
fit1 <- lm(Y ~ 1)
fit2 <- lm(Y ~ poly(L, 2))
fit3 <- lm(Y ~ poly(L, 2) + G)
fit4 <- lm(Y ~ poly(L, 2)*G)
fit5 <- lm(Y ~ poly(L, 2) + S)
fit6 <- lm(Y ~ poly(L, 2)*S)
aic <- AICc(list(fit1, fit2, fit3, fit4, fit5, fit6))
print(truss[i])
print(aic)
bestmodel[i] <- min(aic$model[aic$daicc<2])
}
}
windows(w=12, h=5)
par(mfrow=c(3, 7), mar=c(0, 0, 0, 0), oma=c(2, 2, 1, 1))
for(i in seq_along(truss)) {
P <- ydat[, Ptruss[i]]
C <- ydat[, Ctruss[i]]
L <- ydat[, "CALIPER.L"]
S <- as.factor(ydat$SPECIES)
G <- as.factor(ydat$TYPE)
Y <- P^2 - C^2
eqscplot(C, P, pch=as.numeric(S), col=as.numeric(S), xlab="", ylab="", axes=FALSE)
abline(0, 1)
box()
if(truss[i]=="L") {
fit1 <- lm(Y ~ 1)
fit2.5 <- lm(Y ~ G)
fit4.5 <- lm(Y ~ S)
aic <- AICc(list(fit7, fit8, fit9))
print(truss[i])
print(aic)
bestmodel[i] <- c(1, 2.5, 4.5)[min(aic$model[aic$daicc<2])]
} else {
fit1 <- lm(Y ~ 1)
fit2 <- lm(Y ~ poly(L, 2))
fit3 <- lm(Y ~ poly(L, 2) + G)
fit4 <- lm(Y ~ poly(L, 2)*G)
fit5 <- lm(Y ~ poly(L, 2) + S)
fit6 <- lm(Y ~ poly(L, 2)*S)
aic <- AICc(list(fit1, fit2, fit3, fit4, fit5, fit6))
print(truss[i])
print(aic)
bestmodel[i] <- min(aic$model[aic$daicc<2])
}
}
windows(w=12, h=5)
par(mfrow=c(3, 7), mar=c(0, 0, 0, 0), oma=c(2, 2, 1, 1))
for(i in seq_along(truss)) {
P <- ydat[, Ptruss[i]]
C <- ydat[, Ctruss[i]]
L <- ydat[, "CALIPER.L"]
S <- as.factor(ydat$SPECIES)
G <- as.factor(ydat$TYPE)
Y <- P^2 - C^2
plot(C, P, pch=as.numeric(S), col=as.numeric(S), xlim=range(C, P), ylim=range(C, P), axes=FALSE, xlab="", ylab="")
abline(0, 1)
box()
mtext(truss[i], side=3, line=-2, adj=0.1)
if(truss[i]=="L") {
fit1 <- lm(Y ~ 1)
fit2.5 <- lm(Y ~ G)
fit4.5 <- lm(Y ~ S)
aic <- AICc(list(fit7, fit8, fit9))
print(truss[i])
print(aic)
bestmodel[i] <- c(1, 2.5, 4.5)[min(aic$model[aic$daicc<2])]
} else {
fit1 <- lm(Y ~ 1)
fit2 <- lm(Y ~ poly(L, 2))
fit3 <- lm(Y ~ poly(L, 2) + G)
fit4 <- lm(Y ~ poly(L, 2)*G)
fit5 <- lm(Y ~ poly(L, 2) + S)
fit6 <- lm(Y ~ poly(L, 2)*S)
aic <- AICc(list(fit1, fit2, fit3, fit4, fit5, fit6))
print(truss[i])
print(aic)
bestmodel[i] <- min(aic$model[aic$daicc<2])
}
}
res <- data.frame(truss, expect, bestmodel)
resb <- res[order(res$expect, res$bestmodel, res$truss), ]
resb
resb
windows(w=12, h=5)
par(mfrow=c(3, 7), mar=c(0, 0, 0, 0), oma=c(2, 2, 1, 1))
for(i in seq_along(truss)) {
P <- ydat[, paste0("SIGMA.", resb$truss[i])]
C <- ydat[, paste0("CALIPER.", resb$truss[i])]
S <- as.factor(ydat$SPECIES)
plot(C, P, pch=as.numeric(S), col=as.numeric(S), xlim=range(C, P), ylim=range(C, P), axes=FALSE, xlab="", ylab="")
abline(0, 1)
box()
mtext(truss[i], side=3, line=-2, adj=0.1)
}
resb$truss[i]
resb$truss[1]
windows(w=12, h=5)
par(mfrow=c(3, 7), mar=c(0, 0, 0, 0), oma=c(2, 2, 1, 1))
for(i in seq_along(truss)) {
P <- ydat[, paste0("SIGMA.", resb$truss[i])]
C <- ydat[, paste0("CALIPER.", resb$truss[i])]
S <- as.factor(ydat$SPECIES)
plot(C, P, pch=as.numeric(S), col=as.numeric(S), xlim=range(C, P), ylim=range(C, P), axes=FALSE, xlab="", ylab="")
abline(0, 1)
box()
mtext(resb$truss[i], side=3, line=-2, adj=0.1)
}
mtext("Caliper", side=1, outer=TRUE)
mtext("Photo", side=2, outer=TRUE)
mtext("Caliper", side=1, outer=TRUE, line=0.5)
mtext("Photo", side=2, outer=TRUE, line=0.5)
par(mfrow=c(3, 7), mar=c(0, 0, 0, 0), oma=c(2, 2, 1, 1))
for(i in seq_along(truss)) {
P <- ydat[, paste0("SIGMA.", resb$truss[i])]
C <- ydat[, paste0("CALIPER.", resb$truss[i])]
S <- as.factor(ydat$SPECIES)
plot(C, P, pch=as.numeric(S), col=as.numeric(S), xlim=range(C, P), ylim=range(C, P), axes=FALSE, xlab="", ylab="")
abline(0, 1)
box()
mtext(resb$truss[i], side=3, line=-2, adj=0.1)
}
mtext("Caliper", side=1, outer=TRUE, line=0.5)
mtext("Photo", side=2, outer=TRUE, line=0.5)
windows(w=12, h=5)
par(mfrow=c(3, 7), mar=c(0, 0, 0, 0), oma=c(2, 2, 1, 1))
for(i in seq_along(truss)) {
P <- ydat[, paste0("SIGMA.", resb$truss[i])]
C <- ydat[, paste0("CALIPER.", resb$truss[i])]
S <- as.factor(ydat$SPECIES)
G <- as.factor(ydat$TYPE)
plot(C, P, pch=as.numeric(S), col=as.numeric(G), xlim=range(C, P), ylim=range(C, P), axes=FALSE, xlab="", ylab="")
abline(0, 1)
box()
mtext(resb$truss[i], side=3, line=-2, adj=0.1)
}
mtext("Caliper", side=1, outer=TRUE, line=0.5)
mtext("Photo", side=2, outer=TRUE, line=0.5)
windows(w=12, h=5)
par(mfrow=c(3, 7), mar=c(0, 0, 0, 0), oma=c(2, 2, 1, 1))
for(i in seq_along(truss)) {
P <- ydat[, paste0("SIGMA.", resb$truss[i])]
C <- ydat[, paste0("CALIPER.", resb$truss[i])]
S <- as.factor(ydat$SPECIES)
G <- as.factor(ydat$TYPE)
plot(C, P, pch=as.numeric(S), col=as.numeric(G)+1, xlim=range(C, P), ylim=range(C, P), axes=FALSE, xlab="", ylab="")
abline(0, 1)
box()
mtext(resb$truss[i], side=3, line=-2, adj=0.1)
}
mtext("Caliper", side=1, outer=TRUE, line=0.5)
mtext("Photo", side=2, outer=TRUE, line=0.5)
par(mfrow=c(3, 7), mar=c(0, 0, 0, 0), oma=c(2, 2, 1, 1))
for(i in seq_along(truss)) {
P <- ydat[, paste0("SIGMA.", resb$truss[i])]
C <- ydat[, paste0("CALIPER.", resb$truss[i])]
S <- as.factor(ydat$SPECIES)
G <- as.factor(ydat$TYPE)
plot(C, P, pch=as.numeric(S), col=blindcolz[as.numeric(G)+1], xlim=range(C, P), ylim=range(C, P), axes=FALSE, xlab="", ylab="")
abline(0, 1)
box()
mtext(resb$truss[i], side=3, line=-2, adj=0.1)
}
mtext("Caliper", side=1, outer=TRUE, line=0.5)
mtext("Photo", side=2, outer=TRUE, line=0.5)
resb
?outer
a <x <- 1:9; names(x) <- x
# Multiplication & Power Tables
x %o% x
x <- 1:9; names(x) <- x
# Multiplication & Power Tables
x %o% x
x
?cor
names(ydat)
cor(ydat[, 8:10], ydat[, 29:30])
search()
ls(4)
plotcor
r <- cor(ydat[, Ctruss], ydat[, Ptruss])
windows()
plotcor(r)
r
r
apply(r, 1, which.max)
x <- apply(r, 1, which.max)
data.frame(names(x), Ptruss[x])
y <- apply(r, 2, which.max)
data.frame(names(y), Ctruss[y])
resb
truss
i <- 20
P <- ydat[, Ptruss[i]]
C <- ydat[, Ctruss[i]]
L <- ydat[, "CALIPER.L"]
S <- as.factor(ydat$SPECIES)
G <- as.factor(ydat$TYPE)
Y <- P^2 - C^2
windows()
plot(C, P)
abline(0, 1)
fit1 <- lm(Y ~ 1)
fit2 <- lm(Y ~ poly(L, 2))
fit3 <- lm(Y ~ poly(L, 2) + G)
fit4 <- lm(Y ~ poly(L, 2)*G)
fit5 <- lm(Y ~ poly(L, 2) + S)
fit6 <- lm(Y ~ poly(L, 2)*S)
aic <- AICc(list(fit1, fit2, fit3, fit4, fit5, fit6))
aic
fit5
plot(L, Y)
summary(fit5)
cor(L, Y)
cor.test(L, Y)
P <- ydat[, Ptruss[i]]
C <- ydat[, Ctruss[i]]
L <- ydat[, "CALIPER.L"]
S <- as.factor(ydat$SPECIES)
G <- as.factor(ydat$TYPE)
fit1 <- lm(P ~ C)
fit2 <- lm(P ~ C + L)
fit3 <- lm(P ~ C + L + G)
fit4 <- lm(P ~ C + L*G)
fit5 <- lm(P ~ C + L + S)
fit6 <- lm(P ~ C + L*S)
aic <- AICc(list(fit1, fit2, fit3, fit4, fit5, fit6))
aic
fit1
fit5
summary(fit5)
P <- ydat[, Ptruss[i]]
C <- ydat[, Ctruss[i]]
CL <- ydat[, "CALIPER.L"]
PL <- ydat[, "SIGMA.L"]
S <- as.factor(ydat$SPECIES)
G <- as.factor(ydat$TYPE)
fit1 <- lm(P/PL ~ C/CL)
fit2 <- lm(P/PL ~ C/CL + G)
fit3 <- lm(P/PL ~ C/CL + S)
aic <- AICc(list(fit1, fit2, fit3))
aic
P <- ydat[, Ptruss[i]]
C <- ydat[, Ctruss[i]]
CL <- ydat[, "CALIPER.L"]
PL <- ydat[, "SIGMA.L"]
S <- as.factor(ydat$SPECIES)
G <- as.factor(ydat$TYPE)
Y <- P/PL
X <- C/CL
fit1 <- lm(Y ~ X)
fit2 <- lm(Y ~ X + G)
fit3 <- lm(Y ~ X*G)
fit4 <- lm(Y ~ X + S)
fit5 <- lm(Y ~ X*S)
aic <- AICc(list(fit1, fit2, fit3, fit4, fit5))
aic
windows()
plot(X, Y, pch=as.numeric(S), col=as.numeric(S))
points(X, fit4$fitted, pch=16, cex=0.5, col=as.numeric(S))
abline(0, 1)
summary(fit4)
fit1 <- lm(Y ~ X)
fit2 <- lm(Y ~ X + G)
fit3 <- lm(Y ~ X*G)
fit4 <- lm(Y ~ X + S)
fit5 <- lm(Y ~ X*S)
aic <- AICc(list(fit1, fit2, fit3, fit4, fit5))
aic
windows()
eqscplot(X, Y, pch=as.numeric(S), col=as.numeric(S), cex=1.5)
points(X, fit4$fitted, pch=16, cex=0.5, col=as.numeric(S))
abline(0, 1)
i
truss[i]
windows(w=12, h=5)
par(mfrow=c(3, 7), mar=c(0, 0, 0, 0), oma=c(2, 2, 1, 1))
for(i in seq_along(truss)) {
P <- ydat[, Ptruss[i]]
C <- ydat[, Ctruss[i]]
CL <- ydat[, "CALIPER.L"]
PL <- ydat[, "SIGMA.L"]
S <- as.factor(ydat$SPECIES)
G <- as.factor(ydat$TYPE)
Y <- P/PL
X <- C/CL
if(truss[i]=="L") {
fit1 <- lm(Y ~ 1)
fit2.5 <- lm(Y ~ G)
fit4.5 <- lm(Y ~ S)
aic <- AICc(list(fit7, fit8, fit9))
print(truss[i])
print(aic)
bestmodel[i] <- c(1, 2.5, 4.5)[min(aic$model[aic$daicc<2])]
} else {
fits <- list(
lm(Y ~ X)
lm(Y ~ X + G)
lm(Y ~ X*G)
lm(Y ~ X + S)
lm(Y ~ X*S)
)
aic <- AICc(fits)
print(truss[i])
print(aic)
bestmodel[i] <- min(aic$model[aic$daicc<2])
eqscplot(X, Y, pch=as.numeric(S), col=as.numeric(S), cex=1.5, xlim=range(X, Y), ylim=range(X, Y), axes=FALSE, xlab="", ylab="")
points(X, fits[[bestmodel[i]]]$fitted, pch=16, cex=0.5, col=as.numeric(S))
abline(0, 1)
box()
mtext(resb$truss[i], side=3, line=-2, adj=0.1)
}
}
mtext("Caliper Truss/Length", side=1, outer=TRUE, line=0.5)
mtext("Photo Truss/Length", side=2, outer=TRUE, line=0.5)
windows(w=12, h=5)
par(mfrow=c(3, 7), mar=c(0, 0, 0, 0), oma=c(2, 2, 1, 1))
for(i in seq_along(truss)) {
P <- ydat[, Ptruss[i]]
C <- ydat[, Ctruss[i]]
CL <- ydat[, "CALIPER.L"]
PL <- ydat[, "SIGMA.L"]
S <- as.factor(ydat$SPECIES)
G <- as.factor(ydat$TYPE)
Y <- P/PL
X <- C/CL
if(truss[i]=="L") {
fits <- list(
lm(Y ~ 1),
lm(Y ~ G),
lm(Y ~ S)
)
aic <- AICc(fits)
print(truss[i])
print(aic)
mm <- min(aic$model[aic$daicc<2])
bestmodel[i] <- c(1, 2.5, 4.5)[mm]
} else {
fits <- list(
lm(Y ~ X),
lm(Y ~ X + G),
lm(Y ~ X*G),
lm(Y ~ X + S),
lm(Y ~ X*S)
)
aic <- AICc(fits)
print(truss[i])
print(aic)
mm <- min(aic$model[aic$daicc<2])
bestmodel[i] <- mm
eqscplot(X, Y, pch=as.numeric(S), col=as.numeric(S), cex=1.5, xlim=range(X, Y), ylim=range(X, Y), axes=FALSE, xlab="", ylab="")
points(X, fits[[mm]]$fitted, pch=16, cex=0.5, col=as.numeric(S))
abline(0, 1)
box()
mtext(resb$truss[i], side=3, line=-2, adj=0.1)
}
}
mtext("Caliper Truss/Length", side=1, outer=TRUE, line=0.5)
mtext("Photo Truss/Length", side=2, outer=TRUE, line=0.5)
windows(w=12, h=5)
par(mfrow=c(3, 7), mar=c(0, 0, 0, 0), oma=c(2, 2, 1, 1))
for(i in seq_along(truss)) {
P <- ydat[, Ptruss[i]]
C <- ydat[, Ctruss[i]]
CL <- ydat[, "CALIPER.L"]
PL <- ydat[, "SIGMA.L"]
S <- as.factor(ydat$SPECIES)
G <- as.factor(ydat$TYPE)
Y <- P/PL
X <- C/CL
if(truss[i]=="L") {
fits <- list(
lm(Y ~ 1),
lm(Y ~ G),
lm(Y ~ S)
)
aic <- AICc(fits)
print(truss[i])
print(aic)
mm <- min(aic$model[aic$daicc<2])
bestmodel[i] <- c(1, 2.5, 4.5)[mm]
} else {
fits <- list(
lm(Y ~ X),
lm(Y ~ X + G),
lm(Y ~ X*G),
lm(Y ~ X + S),
lm(Y ~ X*S)
)
aic <- AICc(fits)
print(truss[i])
print(aic)
mm <- min(aic$model[aic$daicc<2])
bestmodel[i] <- mm
eqscplot(X, Y, pch=as.numeric(S), col=as.numeric(S), cex=1.5, xlim=range(X, Y), ylim=range(X, Y), axes=FALSE, xlab="", ylab="")
points(X, fits[[mm]]$fitted, pch=16, cex=0.5, col=as.numeric(S))
abline(0, 1)
box()
mtext(resb$truss[i], side=3, line=-2, adj=0.1)
}
}
mtext("Caliper Truss/Length", side=1, outer=TRUE, line=0.5)
mtext("Photo Truss/Length", side=2, outer=TRUE, line=0.5)
windows(w=12, h=5)
par(mfrow=c(3, 7), mar=c(0, 0, 0, 0), oma=c(2, 2, 1, 1))
for(i in seq_along(truss)) {
P <- ydat[, Ptruss[i]]
C <- ydat[, Ctruss[i]]
CL <- ydat[, "CALIPER.L"]
PL <- ydat[, "SIGMA.L"]
S <- as.factor(ydat$SPECIES)
G <- as.factor(ydat$TYPE)
Y <- P/PL
X <- C/CL
fits <- list(
lm(Y ~ X),
lm(Y ~ X + G),
lm(Y ~ X*G),
lm(Y ~ X + S),
lm(Y ~ X*S)
)
aic <- AICc(fits)
print(truss[i])
print(aic)
mm <- min(aic$model[aic$daicc<2])
bestmodel[i] <- mm
eqscplot(X, Y, pch=as.numeric(S), col=as.numeric(S), cex=1.5, xlim=range(X, Y), ylim=range(X, Y), axes=FALSE, xlab="", ylab="")
points(X, fits[[mm]]$fitted, pch=16, cex=0.5, col=as.numeric(S))
abline(0, 1)
box()
mtext(resb$truss[i], side=3, line=-2, adj=0.1)
}
mtext("Caliper Truss/Length", side=1, outer=TRUE, line=0.5)
mtext("Photo Truss/Length", side=2, outer=TRUE, line=0.5)
windows(w=12, h=5)
par(mfrow=c(3, 7), mar=c(0, 0, 0, 0), oma=c(2, 2, 1, 1))
for(i in seq_along(truss)) {
P <- ydat[, Ptruss[i]]
C <- ydat[, Ctruss[i]]
CL <- ydat[, "CALIPER.L"]
PL <- ydat[, "SIGMA.L"]
S <- as.factor(ydat$SPECIES)
G <- as.factor(ydat$TYPE)
Y <- P/PL
X <- C/CL
if(truss[i]=="L") {
fits <- list(
lm(P ~ C),
lm(P ~ C + G),
lm(P ~ C + S)
)
aic <- AICc(fits)
print(truss[i])
print(aic)
mm <- min(aic$model[aic$daicc<2])
bestmodel[i] <- c(1, 1.5, 3.5)[mm]
eqscplot(C, P, pch=as.numeric(S), col=as.numeric(S), cex=1.5, xlim=range(C, P), ylim=range(C, P), axes=FALSE, xlab="", ylab="")
points(C, fits[[mm]]$fitted, pch=16, cex=0.5, col=as.numeric(S))
abline(0, 1)
box()
mtext(resb$truss[i], side=3, line=-2, adj=0.1)
} else {
fits <- list(
lm(Y ~ X),
lm(Y ~ X + G),
lm(Y ~ X*G),
lm(Y ~ X + S),
lm(Y ~ X*S)
)
aic <- AICc(fits)
print(truss[i])
print(aic)
mm <- min(aic$model[aic$daicc<2])
bestmodel[i] <- mm
eqscplot(X, Y, pch=as.numeric(S), col=as.numeric(S), cex=1.5, xlim=range(X, Y), ylim=range(X, Y), axes=FALSE, xlab="", ylab="")
points(X, fits[[mm]]$fitted, pch=16, cex=0.5, col=as.numeric(S))
abline(0, 1)
box()
mtext(resb$truss[i], side=3, line=-2, adj=0.1)
}
}
mtext("Caliper Truss/Length", side=1, outer=TRUE, line=0.5)
mtext("Photo Truss/Length", side=2, outer=TRUE, line=0.5)
res <- data.frame(truss, expect, bestmodel)
resb <- res[order(res$expect, res$bestmodel, res$truss), ]
resb
ord <- match(resb$truss, truss)
truss
ord
ord <- match(resb$truss, truss)
Ptruss <- Ptruss[ord]
Ctruss <- Ctruss[ord]
truss <- truss[ord]
windows(w=12, h=5)
par(mfrow=c(3, 7), mar=c(0, 0, 0, 0), oma=c(2, 2, 1, 1))
for(i in seq_along(truss)) {
P <- ydat[, Ptruss[i]]
C <- ydat[, Ctruss[i]]
CL <- ydat[, "CALIPER.L"]
PL <- ydat[, "SIGMA.L"]
S <- as.factor(ydat$SPECIES)
G <- as.factor(ydat$TYPE)
Y <- P/PL
X <- C/CL
if(truss[i]=="L") {
fits <- list(
lm(P ~ C),
lm(P ~ C + G),
lm(P ~ C + S)
)
aic <- AICc(fits)
print(truss[i])
print(aic)
mm <- min(aic$model[aic$daicc<2])
bestmodel[i] <- c(1, 1.5, 3.5)[mm]
eqscplot(C, P, pch=as.numeric(S), col=as.numeric(S), cex=1.5, xlim=range(C, P), ylim=range(C, P), axes=FALSE, xlab="", ylab="")
points(C, fits[[mm]]$fitted, pch=16, cex=0.5, col=as.numeric(S))
abline(0, 1)
box()
mtext(resb$truss[i], side=3, line=-2, adj=0.1)
} else {
fits <- list(
lm(Y ~ X),
lm(Y ~ X + G),
lm(Y ~ X*G),
lm(Y ~ X + S),
lm(Y ~ X*S)
)
aic <- AICc(fits)
print(truss[i])
print(aic)
mm <- min(aic$model[aic$daicc<2])
bestmodel[i] <- mm
eqscplot(X, Y, pch=as.numeric(S), col=as.numeric(S), cex=1.5, xlim=range(X, Y), ylim=range(X, Y), axes=FALSE, xlab="", ylab="")
points(X, fits[[mm]]$fitted, pch=16, cex=0.5, col=as.numeric(S))
abline(0, 1)
box()
mtext(resb$truss[i], side=3, line=-2, adj=0.1)
}
}
mtext("Caliper Truss/Length", side=1, outer=TRUE, line=0.5)
mtext("Photo Truss/Length", side=2, outer=TRUE, line=0.5)
res <- data.frame(truss, expect, bestmodel)
resb <- res[order(res$expect, res$bestmodel, res$truss), ]
resb
ord
dput(ord)
dput(as.numeric(ord))
cleanup()
graphics.off()
# C:\JVA\Consult\Yule\Superior Coreg\PhotoCaliper.r
library(jpeg)
# read in the data
wb <- loadWorkbook("C:/JVA/Consult/Yule/Superior Coreg/2014 Caliper and SigmaScan Correction Data JVA.xlsx")
ydat <- readWorksheet(wb, sheet="Caliper & Sigma for Analyses", startRow=1)
# kdat <- readWorksheet(wb, sheet="Koelz Superior Data", startRow=1)
# start a document
doc <- startrtf(file=paste(Sys.Date(), "Caliper vs. Photo"), dir="C:/JVA/Consult/Yule/Superior Coreg")
heading("Lake Superior Coregonid Morphometrics")
heading("Caliper vs. Photo Measurements", 2)
heading("for Dan Yule and Allison Derose", 3)
heading("by Jean Adams", 3)
heading(Sys.Date(), 3)
para(
"Truss measurements from Lake Superior coregonids were made using two methods: distances measured in three dimensions using calipers on actual fish and",
" distances measured in two dimensions using digitized side-view photos of fish.",
"  For trusses between two points that both lie on the 'boundary' of a side-viewed fish (Figure ", figcount, "),",
" measurements made with calipers and photos should be the same.",
"  This encompasses most of the truss measurements made (Table).",
"  However, if either of the two points does NOT lie on the 'boundary' of a side-viewed fish,",
" measurements made with calipers will be longer than those made with photos.",
"  The expected relation between the measures can be summarized using the Pythagorean theorem,")
para("P2 = C2 + T2,")
para("where P (the hypotenuse) is the photo measure, C is the caliper measure, and T is the offset in the transverse (left to right relative to the fish)",
" direction between the two points (Figure ", figcount+1, ").")
para("We have no empirical measurements of the offset for any given truss,",
" but we can assume that there is a relation between the offset and the length of the fish, which may vary with species or species group.", 
"  We will use the caliper measured standard length so that the results of the model may be applied to Koelz' data later.", 
"  So, for each truss (other than standard length), we will fit six models (listed in order from least to most complex) relating the caliper and photo measures,",
" with the difference of the squared measures as the response (P2 - C2) and explanatory variables",
" (1) none; (2) fish length;",
" (3) fish length and species group; (4) fish length, species group, and their interaction;",
" (5) fish length and species; and (6) fish length, species, and their interaction.",
"  For the standard length truss, we will fit three models relating the caliper and photo measures,",
" with the same response and explanatory variables (1) none, (2.5) species group, and (4.5) species.",
"  The best of these models will be selected for each truss, by choosing the simplest model (the lowest numbered model)",
" with a sample size adjusted Akaike's information criterion (AICc) within 2 of the minimum.",
"  If the intercept only model is selected and the 95% confidence interval of the intercept includes zero, then no conversion between measures is required.",
)
figimg <- function() {
par(mar=rep(0, 4))
plotblank(axes=FALSE)
pusr <- par("usr")
rasterImage(img, pusr[1], pusr[3], pusr[2], pusr[4])
}
img <- readJPEG("C:/JVA/Consult/Yule/Superior Coreg/FishBoundary.jpg")
figu("The 'boundary' of a side-viewed fish.", FIG=figimg, w=6.5, h=dim(img)[1]/dim(img)[2]*6.5)
img <- readJPEG("C:/JVA/Consult/Yule/Superior Coreg/TopView.jpg")
figu("The relation between truss measures displayed on a top-viewed fish, when one of the points does not lie on the 'boundary' of a side-viewed fish.", 
FIG=figimg, w=6.5, h=dim(img)[1]/dim(img)[2]*6.5)
ord <- c(1, 2, 3, 8, 14, 6, 19, 7, 9, 12, 20, 21, 4, 10, 11, 13, 15, 18, 16, 5, 17)
Ptruss <- sort(stringin("sigma", names(ydat)))[ord]
Ctruss <- sort(stringin("caliper", names(ydat)))[ord]
truss <- substring(Ptruss, 7)[ord]
exp.none <- c("L", "O", "SD", "SA", "D", "DH", "DB", "DA", "AH", "AB", "AD")
exp.some <- c("M", "S", "H", "E", "V", "AV", "P", "PV")
exp.unkn <- c("AV.V", "PV.P")
expect <- rep("1 none", length(truss))
expect[truss %in% exp.some] <- "2-6 some"
expect[truss %in% exp.unkn] <- "7 unkn"
bestmodel <- rep(NA, length(truss))
if(FALSE) {
# look to see if there was any obvious mislabeling of columns
r <- cor(ydat[, Ctruss], ydat[, Ptruss])
x <- apply(r, 1, which.max)
data.frame(names(x), Ptruss[x])
y <- apply(r, 2, which.max)
data.frame(names(y), Ctruss[y])
windows()
plotcor(r)
i <- 20
}
windows(w=12, h=5)
par(mfrow=c(3, 7), mar=c(0, 0, 0, 0), oma=c(2, 2, 1, 1))
for(i in seq_along(truss)) {
P <- ydat[, Ptruss[i]]
C <- ydat[, Ctruss[i]]
CL <- ydat[, "CALIPER.L"]
PL <- ydat[, "SIGMA.L"]
S <- as.factor(ydat$SPECIES)
G <- as.factor(ydat$TYPE)
Y <- P/PL
X <- C/CL
if(truss[i]=="L") {
fits <- list(
lm(P ~ C),
lm(P ~ C + G),
lm(P ~ C + S)
)
aic <- AICc(fits)
print(truss[i])
print(aic)
mm <- min(aic$model[aic$daicc<2])
bestmodel[i] <- c(1, 1.5, 3.5)[mm]
eqscplot(C, P, pch=as.numeric(S), col=as.numeric(S), cex=1.5, xlim=range(C, P), ylim=range(C, P), axes=FALSE, xlab="", ylab="")
points(C, fits[[mm]]$fitted, pch=16, cex=0.5, col=as.numeric(S))
abline(0, 1)
box()
mtext(resb$truss[i], side=3, line=-2, adj=0.1)
} else {
fits <- list(
lm(Y ~ X),
lm(Y ~ X + G),
lm(Y ~ X*G),
lm(Y ~ X + S),
lm(Y ~ X*S)
)
aic <- AICc(fits)
print(truss[i])
print(aic)
mm <- min(aic$model[aic$daicc<2])
bestmodel[i] <- mm
eqscplot(X, Y, pch=as.numeric(S), col=as.numeric(S), cex=1.5, xlim=range(X, Y), ylim=range(X, Y), axes=FALSE, xlab="", ylab="")
points(X, fits[[mm]]$fitted, pch=16, cex=0.5, col=as.numeric(S))
abline(0, 1)
box()
mtext(resb$truss[i], side=3, line=-2, adj=0.1)
}
}
mtext("Caliper Truss/Length", side=1, outer=TRUE, line=0.5)
mtext("Photo Truss/Length", side=2, outer=TRUE, line=0.5)
figcount
jvamiscenv$figcount
cleanup()
graphics.off()
# C:\JVA\Consult\Yule\Superior Coreg\PhotoCaliper.r
library(jpeg)
# read in the data
wb <- loadWorkbook("C:/JVA/Consult/Yule/Superior Coreg/2014 Caliper and SigmaScan Correction Data JVA.xlsx")
ydat <- readWorksheet(wb, sheet="Caliper & Sigma for Analyses", startRow=1)
# kdat <- readWorksheet(wb, sheet="Koelz Superior Data", startRow=1)
# start a document
doc <- startrtf(file=paste(Sys.Date(), "Caliper vs. Photo"), dir="C:/JVA/Consult/Yule/Superior Coreg")
heading("Lake Superior Coregonid Morphometrics")
heading("Caliper vs. Photo Measurements", 2)
heading("for Dan Yule and Allison Derose", 3)
heading("by Jean Adams", 3)
heading(Sys.Date(), 3)
para(
"Truss measurements from Lake Superior coregonids were made using two methods: distances measured in three dimensions using calipers on actual fish and",
" distances measured in two dimensions using digitized side-view photos of fish.",
"  For trusses between two points that both lie on the 'boundary' of a side-viewed fish (Figure ", jvamiscenv$figcount, "),",
" measurements made with calipers and photos should be the same.",
"  This encompasses most of the truss measurements made (Table).",
"  However, if either of the two points does NOT lie on the 'boundary' of a side-viewed fish,",
" measurements made with calipers will be longer than those made with photos.",
"  The expected relation between the measures can be summarized using the Pythagorean theorem,")
para("P2 = C2 + T2,")
para("where P (the hypotenuse) is the photo measure, C is the caliper measure, and T is the offset in the transverse (left to right relative to the fish)",
" direction between the two points (Figure ", jvamiscenv$figcount+1, ").")
para("We have no empirical measurements of the offset for any given truss,",
" but we can assume that there is a relation between the offset and the length of the fish, which may vary with species or species group.", 
"  We will use the caliper measured standard length so that the results of the model may be applied to Koelz' data later.", 
"  So, for each truss (other than standard length), we will fit six models (listed in order from least to most complex) relating the caliper and photo measures,",
" with the difference of the squared measures as the response (P2 - C2) and explanatory variables",
" (1) none; (2) fish length;",
" (3) fish length and species group; (4) fish length, species group, and their interaction;",
" (5) fish length and species; and (6) fish length, species, and their interaction.",
"  For the standard length truss, we will fit three models relating the caliper and photo measures,",
" with the same response and explanatory variables (1) none, (2.5) species group, and (4.5) species.",
"  The best of these models will be selected for each truss, by choosing the simplest model (the lowest numbered model)",
" with a sample size adjusted Akaike's information criterion (AICc) within 2 of the minimum.",
"  If the intercept only model is selected and the 95% confidence interval of the intercept includes zero, then no conversion between measures is required."
)
figimg <- function() {
par(mar=rep(0, 4))
plotblank(axes=FALSE)
pusr <- par("usr")
rasterImage(img, pusr[1], pusr[3], pusr[2], pusr[4])
}
img <- readJPEG("C:/JVA/Consult/Yule/Superior Coreg/FishBoundary.jpg")
figu("The 'boundary' of a side-viewed fish.", FIG=figimg, w=6.5, h=dim(img)[1]/dim(img)[2]*6.5)
img <- readJPEG("C:/JVA/Consult/Yule/Superior Coreg/TopView.jpg")
figu("The relation between truss measures displayed on a top-viewed fish, when one of the points does not lie on the 'boundary' of a side-viewed fish.", 
FIG=figimg, w=6.5, h=dim(img)[1]/dim(img)[2]*6.5)
ord <- c(1, 2, 3, 8, 14, 6, 19, 7, 9, 12, 20, 21, 4, 10, 11, 13, 15, 18, 16, 5, 17)
Ptruss <- sort(stringin("sigma", names(ydat)))[ord]
Ctruss <- sort(stringin("caliper", names(ydat)))[ord]
truss <- substring(Ptruss, 7)[ord]
exp.none <- c("L", "O", "SD", "SA", "D", "DH", "DB", "DA", "AH", "AB", "AD")
exp.some <- c("M", "S", "H", "E", "V", "AV", "P", "PV")
exp.unkn <- c("AV.V", "PV.P")
expect <- rep("1 none", length(truss))
expect[truss %in% exp.some] <- "2-6 some"
expect[truss %in% exp.unkn] <- "7 unkn"
bestmodel <- rep(NA, length(truss))
if(FALSE) {
# look to see if there was any obvious mislabeling of columns
r <- cor(ydat[, Ctruss], ydat[, Ptruss])
x <- apply(r, 1, which.max)
data.frame(names(x), Ptruss[x])
y <- apply(r, 2, which.max)
data.frame(names(y), Ctruss[y])
windows()
plotcor(r)
i <- 20
}
windows(w=12, h=5)
par(mfrow=c(3, 7), mar=c(0, 0, 0, 0), oma=c(2, 2, 1, 1))
for(i in seq_along(truss)) {
P <- ydat[, Ptruss[i]]
C <- ydat[, Ctruss[i]]
CL <- ydat[, "CALIPER.L"]
PL <- ydat[, "SIGMA.L"]
S <- as.factor(ydat$SPECIES)
G <- as.factor(ydat$TYPE)
Y <- P/PL
X <- C/CL
if(truss[i]=="L") {
fits <- list(
lm(P ~ C),
lm(P ~ C + G),
lm(P ~ C + S)
)
aic <- AICc(fits)
print(truss[i])
print(aic)
mm <- min(aic$model[aic$daicc<2])
bestmodel[i] <- c(1, 1.5, 3.5)[mm]
eqscplot(C, P, pch=as.numeric(S), col=as.numeric(S), cex=1.5, xlim=range(C, P), ylim=range(C, P), axes=FALSE, xlab="", ylab="")
points(C, fits[[mm]]$fitted, pch=16, cex=0.5, col=as.numeric(S))
abline(0, 1)
box()
mtext(truss[i], side=3, line=-2, adj=0.1)
} else {
fits <- list(
lm(Y ~ X),
lm(Y ~ X + G),
lm(Y ~ X*G),
lm(Y ~ X + S),
lm(Y ~ X*S)
)
aic <- AICc(fits)
print(truss[i])
print(aic)
mm <- min(aic$model[aic$daicc<2])
bestmodel[i] <- mm
eqscplot(X, Y, pch=as.numeric(S), col=as.numeric(S), cex=1.5, xlim=range(X, Y), ylim=range(X, Y), axes=FALSE, xlab="", ylab="")
points(X, fits[[mm]]$fitted, pch=16, cex=0.5, col=as.numeric(S))
abline(0, 1)
box()
mtext(truss[i], side=3, line=-2, adj=0.1)
}
}
mtext("Caliper Truss/Length", side=1, outer=TRUE, line=0.5)
mtext("Photo Truss/Length", side=2, outer=TRUE, line=0.5)
res <- data.frame(truss, expect, bestmodel)
resb <- res[order(res$expect, res$bestmodel, res$truss), ]
resb
# ord <- match(resb$truss, truss)
ord <- c(1, 2, 3, 8, 14, 6, 19, 7, 9, 12, 20, 21, 4, 10, 11, 13, 15, 18, 16, 5, 17)
Ptruss <- sort(stringin("sigma", names(ydat)))[ord]
Ctruss <- sort(stringin("caliper", names(ydat)))[ord]
truss <- substring(Ptruss, 7)
exp.none <- c("L", "O", "SD", "SA", "D", "DH", "DB", "DA", "AH", "AB", "AD")
exp.some <- c("M", "S", "H", "E", "V", "AV", "P", "PV")
exp.unkn <- c("AV.V", "PV.P")
expect <- rep("1 none", length(truss))
expect[truss %in% exp.some] <- "2-6 some"
expect[truss %in% exp.unkn] <- "7 unkn"
bestmodel <- rep(NA, length(truss))
if(FALSE) {
# look to see if there was any obvious mislabeling of columns
r <- cor(ydat[, Ctruss], ydat[, Ptruss])
x <- apply(r, 1, which.max)
data.frame(names(x), Ptruss[x])
y <- apply(r, 2, which.max)
data.frame(names(y), Ctruss[y])
windows()
plotcor(r)
i <- 20
}
windows(w=12, h=5)
par(mfrow=c(3, 7), mar=c(0, 0, 0, 0), oma=c(2, 2, 1, 1))
for(i in seq_along(truss)) {
P <- ydat[, Ptruss[i]]
C <- ydat[, Ctruss[i]]
CL <- ydat[, "CALIPER.L"]
PL <- ydat[, "SIGMA.L"]
S <- as.factor(ydat$SPECIES)
G <- as.factor(ydat$TYPE)
Y <- P/PL
X <- C/CL
if(truss[i]=="L") {
fits <- list(
lm(P ~ C),
lm(P ~ C + G),
lm(P ~ C + S)
)
aic <- AICc(fits)
print(truss[i])
print(aic)
mm <- min(aic$model[aic$daicc<2])
bestmodel[i] <- c(1, 1.5, 3.5)[mm]
eqscplot(C, P, pch=as.numeric(S), col=as.numeric(S), cex=1.5, xlim=range(C, P), ylim=range(C, P), axes=FALSE, xlab="", ylab="")
points(C, fits[[mm]]$fitted, pch=16, cex=0.5, col=as.numeric(S))
abline(0, 1)
box()
mtext(truss[i], side=3, line=-2, adj=0.1)
} else {
fits <- list(
lm(Y ~ X),
lm(Y ~ X + G),
lm(Y ~ X*G),
lm(Y ~ X + S),
lm(Y ~ X*S)
)
aic <- AICc(fits)
print(truss[i])
print(aic)
mm <- min(aic$model[aic$daicc<2])
bestmodel[i] <- mm
eqscplot(X, Y, pch=as.numeric(S), col=as.numeric(S), cex=1.5, xlim=range(X, Y), ylim=range(X, Y), axes=FALSE, xlab="", ylab="")
points(X, fits[[mm]]$fitted, pch=16, cex=0.5, col=as.numeric(S))
abline(0, 1)
box()
mtext(truss[i], side=3, line=-2, adj=0.1)
}
}
mtext("Caliper Truss/Length", side=1, outer=TRUE, line=0.5)
mtext("Photo Truss/Length", side=2, outer=TRUE, line=0.5)
res <- data.frame(truss, expect, bestmodel)
resb <- res[order(res$expect, res$bestmodel, res$truss), ]
resb
# ord <- match(resb$truss, truss)
.75*5
windows(w=4, h=9)
par(mfrow=c(7, 3), mar=c(0, 0, 0, 0), oma=c(2, 2, 1, 1))
for(i in seq_along(truss)) {
P <- ydat[, Ptruss[i]]
C <- ydat[, Ctruss[i]]
CL <- ydat[, "CALIPER.L"]
PL <- ydat[, "SIGMA.L"]
S <- as.factor(ydat$SPECIES)
G <- as.factor(ydat$TYPE)
Y <- P/PL
X <- C/CL
if(truss[i]=="L") {
fits <- list(
lm(P ~ C),
lm(P ~ C + G),
lm(P ~ C + S)
)
aic <- AICc(fits)
print(truss[i])
print(aic)
mm <- min(aic$model[aic$daicc<2])
bestmodel[i] <- c(1, 1.5, 3.5)[mm]
eqscplot(C, P, pch=as.numeric(S), col=as.numeric(S), cex=1.5, xlim=range(C, P), ylim=range(C, P), axes=FALSE, xlab="", ylab="")
points(C, fits[[mm]]$fitted, pch=16, cex=0.5, col=as.numeric(S))
abline(0, 1)
box()
mtext(paste(truss[i], bestmodel[i], sep="-"), side=3, line=-2, adj=0.1)
} else {
fits <- list(
lm(Y ~ X),
lm(Y ~ X + G),
lm(Y ~ X*G),
lm(Y ~ X + S),
lm(Y ~ X*S)
)
aic <- AICc(fits)
print(truss[i])
print(aic)
mm <- min(aic$model[aic$daicc<2])
bestmodel[i] <- mm
eqscplot(X, Y, pch=as.numeric(S), col=as.numeric(S), cex=1.5, xlim=range(X, Y), ylim=range(X, Y), axes=FALSE, xlab="", ylab="")
points(X, fits[[mm]]$fitted, pch=16, cex=0.5, col=as.numeric(S))
abline(0, 1)
box()
mtext(paste(truss[i], bestmodel[i], sep="-"), side=3, line=-2, adj=0.1)
}
}
mtext("Caliper Truss/Length", side=1, outer=TRUE, line=0.5)
mtext("Photo Truss/Length", side=2, outer=TRUE, line=0.5)
par(mfrow=c(7, 3), mar=c(0, 0, 0, 0), oma=c(2, 2, 1, 1))
for(i in seq_along(truss)) {
P <- ydat[, Ptruss[i]]
C <- ydat[, Ctruss[i]]
CL <- ydat[, "CALIPER.L"]
PL <- ydat[, "SIGMA.L"]
S <- as.factor(ydat$SPECIES)
G <- as.factor(ydat$TYPE)
Y <- P/PL
X <- C/CL
if(truss[i]=="L") {
fits <- list(
lm(P ~ C),
lm(P ~ C + G),
lm(P ~ C + S)
)
aic <- AICc(fits)
print(truss[i])
print(aic)
mm <- min(aic$model[aic$daicc<2])
bestmodel[i] <- c(1, 1.5, 3.5)[mm]
eqscplot(C, P, pch=as.numeric(S), col=as.numeric(S), xlim=range(C, P), ylim=range(C, P), axes=FALSE, xlab="", ylab="")
points(C, fits[[mm]]$fitted, pch=16, col=as.numeric(S))
abline(0, 1)
box()
mtext(paste(truss[i], bestmodel[i], sep="-"), side=3, line=-2, adj=0.1)
} else {
fits <- list(
lm(Y ~ X),
lm(Y ~ X + G),
lm(Y ~ X*G),
lm(Y ~ X + S),
lm(Y ~ X*S)
)
aic <- AICc(fits)
print(truss[i])
print(aic)
mm <- min(aic$model[aic$daicc<2])
bestmodel[i] <- mm
eqscplot(X, Y, pch=as.numeric(S), col=as.numeric(S), xlim=range(X, Y), ylim=range(X, Y), axes=FALSE, xlab="", ylab="")
points(X, fits[[mm]]$fitted, pch=16, col=as.numeric(S))
abline(0, 1)
box()
mtext(paste(truss[i], bestmodel[i], sep="-"), side=3, line=-2, adj=0.1)
}
}
mtext("Caliper Truss/Length", side=1, outer=TRUE, line=0.5)
mtext("Photo Truss/Length", side=2, outer=TRUE, line=0.5)
res <- data.frame(truss, expect, bestmodel)
resb <- res[order(res$expect, res$bestmodel, res$truss), ]
resb
# ord <- match(resb$truss, truss)
par(mfrow=c(7, 3), mar=c(0, 0, 0, 0), oma=c(2, 2, 1, 1))
for(i in seq_along(truss)) {
P <- ydat[, Ptruss[i]]
C <- ydat[, Ctruss[i]]
CL <- ydat[, "CALIPER.L"]
PL <- ydat[, "SIGMA.L"]
S <- as.factor(ydat$SPECIES)
G <- as.factor(ydat$TYPE)
Y <- P/PL
X <- C/CL
if(truss[i]=="L") {
fits <- list(
lm(P ~ C),
lm(P ~ C + G),
lm(P ~ C + S)
)
aic <- AICc(fits)
print(truss[i])
print(aic)
mm <- min(aic$model[aic$daicc<2])
bestmodel[i] <- c(1, 1.5, 3.5)[mm]
eqscplot(C, P, pch=as.numeric(S), col=as.numeric(S), xlim=range(C, P), ylim=range(C, P), axes=FALSE, xlab="", ylab="")
points(C, fits[[mm]]$fitted, pch=16, col=as.numeric(S))
abline(0, 1)
box()
mtext(paste(truss[i], bestmodel[i], sep="-"), side=3, line=-1.5, adj=0.05, cex=0.8)
} else {
fits <- list(
lm(Y ~ X),
lm(Y ~ X + G),
lm(Y ~ X*G),
lm(Y ~ X + S),
lm(Y ~ X*S)
)
aic <- AICc(fits)
print(truss[i])
print(aic)
mm <- min(aic$model[aic$daicc<2])
bestmodel[i] <- mm
eqscplot(X, Y, pch=as.numeric(S), col=as.numeric(S), xlim=range(X, Y), ylim=range(X, Y), axes=FALSE, xlab="", ylab="")
points(X, fits[[mm]]$fitted, pch=16, col=as.numeric(S))
abline(0, 1)
box()
mtext(paste(truss[i], bestmodel[i], sep="-"), side=3, line=-1.5, adj=0.05, cex=0.8)
}
}
mtext("Caliper Truss/Length", side=1, outer=TRUE, line=0.5)
mtext("Photo Truss/Length", side=2, outer=TRUE, line=0.5)
head(ydat[, 1:10])
table(ydat$Species)
table(ydat$SPECIES)
S
substring(S, 1, 1)
windows(w=4, h=9)
par(mfrow=c(7, 3), mar=c(0, 0, 0, 0), oma=c(2, 2, 1, 1))
for(i in seq_along(truss)) {
P <- ydat[, Ptruss[i]]
C <- ydat[, Ctruss[i]]
CL <- ydat[, "CALIPER.L"]
PL <- ydat[, "SIGMA.L"]
S <- as.factor(ydat$SPECIES)
G <- as.factor(ydat$TYPE)
Y <- P/PL
X <- C/CL
if(truss[i]=="L") {
fits <- list(
lm(P ~ C),
lm(P ~ C + G),
lm(P ~ C + S)
)
aic <- AICc(fits)
print(truss[i])
print(aic)
mm <- min(aic$model[aic$daicc<2])
bestmodel[i] <- c(1, 1.5, 3.5)[mm]
eqscplot(C, P, type="n", lim=range(C, P), ylim=range(C, P), axes=FALSE, xlab="", ylab="")
abline(0, 1)
points(C, fits[[mm]]$fitted, pch=16, col=as.numeric(S))
text(C, P, substring(S, 1, 1), col=as.numeric(S))
box()
mtext(paste(truss[i], bestmodel[i], sep="-"), side=3, line=-1.5, adj=0.05, cex=0.8)
} else {
fits <- list(
lm(Y ~ X),
lm(Y ~ X + G),
lm(Y ~ X*G),
lm(Y ~ X + S),
lm(Y ~ X*S)
)
aic <- AICc(fits)
print(truss[i])
print(aic)
mm <- min(aic$model[aic$daicc<2])
bestmodel[i] <- mm
eqscplot(X, Y, type="n", xlim=range(X, Y), ylim=range(X, Y), axes=FALSE, xlab="", ylab="")
abline(0, 1)
points(X, fits[[mm]]$fitted, pch=16, col=as.numeric(S))
text(X, Y, substring(S, 1, 1), col=as.numeric(S))
box()
mtext(paste(truss[i], bestmodel[i], sep="-"), side=3, line=-1.5, adj=0.05, cex=0.8)
}
}
mtext("Caliper Truss/Length", side=1, outer=TRUE, line=0.5)
mtext("Photo Truss/Length", side=2, outer=TRUE, line=0.5)
windows(w=4.5, h=9)
par(mfrow=c(7, 3), mar=c(0, 0, 0, 0), oma=c(2, 2, 1, 1))
for(i in seq_along(truss)) {
P <- ydat[, Ptruss[i]]
C <- ydat[, Ctruss[i]]
CL <- ydat[, "CALIPER.L"]
PL <- ydat[, "SIGMA.L"]
S <- as.factor(ydat$SPECIES)
G <- as.factor(ydat$TYPE)
Y <- P/PL
X <- C/CL
if(truss[i]=="L") {
fits <- list(
lm(P ~ C),
lm(P ~ C + G),
lm(P ~ C + S)
)
aic <- AICc(fits)
print(truss[i])
print(aic)
mm <- min(aic$model[aic$daicc<2])
bestmodel[i] <- c(1, 1.5, 3.5)[mm]
eqscplot(C, P, type="n", lim=range(C, P), ylim=range(C, P), axes=FALSE, xlab="", ylab="")
abline(0, 1)
text(C, P, substring(S, 1, 1), col=as.numeric(S))
points(C, fits[[mm]]$fitted, pch=16, col=as.numeric(S))
box()
mtext(paste(truss[i], bestmodel[i], sep="-"), side=3, line=-1.5, adj=0.05, cex=0.8)
} else {
fits <- list(
lm(Y ~ X),
lm(Y ~ X + G),
lm(Y ~ X*G),
lm(Y ~ X + S),
lm(Y ~ X*S)
)
aic <- AICc(fits)
print(truss[i])
print(aic)
mm <- min(aic$model[aic$daicc<2])
bestmodel[i] <- mm
eqscplot(X, Y, type="n", xlim=range(X, Y), ylim=range(X, Y), axes=FALSE, xlab="", ylab="")
abline(0, 1)
text(X, Y, substring(S, 1, 1), col=as.numeric(S))
points(X, fits[[mm]]$fitted, pch=16, col=as.numeric(S))
box()
mtext(paste(truss[i], bestmodel[i], sep="-"), side=3, line=-1.5, adj=0.05, cex=0.8)
}
}
mtext("Caliper Truss/Length", side=1, outer=TRUE, line=0.5)
mtext("Photo Truss/Length", side=2, outer=TRUE, line=0.5)
windows(w=4.2, h=9)
par(mfrow=c(7, 3), mar=c(0, 0, 0, 0), oma=c(2, 2, 1, 1))
for(i in seq_along(truss)) {
P <- ydat[, Ptruss[i]]
C <- ydat[, Ctruss[i]]
CL <- ydat[, "CALIPER.L"]
PL <- ydat[, "SIGMA.L"]
S <- as.factor(ydat$SPECIES)
G <- as.factor(ydat$TYPE)
Y <- P/PL
X <- C/CL
if(truss[i]=="L") {
fits <- list(
lm(P ~ C),
lm(P ~ C + G),
lm(P ~ C + S)
)
aic <- AICc(fits)
print(truss[i])
print(aic)
mm <- min(aic$model[aic$daicc<2])
bestmodel[i] <- c(1, 1.5, 3.5)[mm]
eqscplot(C, P, type="n", lim=range(C, P), ylim=range(C, P), axes=FALSE, xlab="", ylab="")
abline(0, 1)
text(C, P, substring(S, 1, 1), col=as.numeric(S))
points(C, fits[[mm]]$fitted, pch=16, col=as.numeric(S))
box()
mtext(paste(truss[i], bestmodel[i], sep="-"), side=3, line=-1.5, adj=0.05, cex=0.8)
} else {
fits <- list(
lm(Y ~ X),
lm(Y ~ X + G),
lm(Y ~ X*G),
lm(Y ~ X + S),
lm(Y ~ X*S)
)
aic <- AICc(fits)
print(truss[i])
print(aic)
mm <- min(aic$model[aic$daicc<2])
bestmodel[i] <- mm
eqscplot(X, Y, type="n", xlim=range(X, Y), ylim=range(X, Y), axes=FALSE, xlab="", ylab="")
abline(0, 1)
text(X, Y, substring(S, 1, 1), col=as.numeric(S))
points(X, fits[[mm]]$fitted, pch=16, col=as.numeric(S))
box()
mtext(paste(truss[i], bestmodel[i], sep="-"), side=3, line=-1.5, adj=0.05, cex=0.8)
}
}
mtext("Caliper Truss/Length", side=1, outer=TRUE, line=0.5)
mtext("Photo Truss/Length", side=2, outer=TRUE, line=0.5)
show.marks()
showmarks()
showmarks()
table(ydat$SPECIES)
?showmarks
showmarks
windows(w=4.2, h=9)
par(mfrow=c(7, 3), mar=c(0, 0, 0, 0), oma=c(2, 2, 1, 1))
for(i in seq_along(truss)) {
P <- ydat[, Ptruss[i]]
C <- ydat[, Ctruss[i]]
CL <- ydat[, "CALIPER.L"]
PL <- ydat[, "SIGMA.L"]
S <- as.factor(ydat$SPECIES)
G <- as.factor(ydat$TYPE)
Y <- P/PL
X <- C/CL
if(truss[i]=="L") {
fits <- list(
lm(P ~ C),
lm(P ~ C + G),
lm(P ~ C + S)
)
aic <- AICc(fits)
print(truss[i])
print(aic)
mm <- min(aic$model[aic$daicc<2])
bestmodel[i] <- c(1, 1.5, 3.5)[mm]
if(mm==1) kol <- "black" else if(mm==2) kol <- blindcolz[as.numeric(G)+1] else kol <- as.numeric(S)+1
eqscplot(C, P, type="n", lim=range(C, P), ylim=range(C, P), axes=FALSE, xlab="", ylab="")
abline(0, 1)
text(C, P, substring(S, 1, 1), col=kol)
points(C, fits[[mm]]$fitted, pch=16, col=kol)
box()
mtext(paste(truss[i], bestmodel[i], sep="-"), side=3, line=-1.5, adj=0.05, cex=0.8)
} else {
fits <- list(
lm(Y ~ X),
lm(Y ~ X + G),
lm(Y ~ X*G),
lm(Y ~ X + S),
lm(Y ~ X*S)
)
aic <- AICc(fits)
print(truss[i])
print(aic)
mm <- min(aic$model[aic$daicc<2])
bestmodel[i] <- mm
if(mm==1) kol <- "black" else if(mm<3.5) kol <- blindcolz[as.numeric(G)+1] else kol <- as.numeric(S)+1
eqscplot(X, Y, type="n", xlim=range(X, Y), ylim=range(X, Y), axes=FALSE, xlab="", ylab="")
abline(0, 1)
text(X, Y, substring(S, 1, 1), col=kol)
points(X, fits[[mm]]$fitted, pch=16, col=kol)
box()
mtext(paste(truss[i], bestmodel[i], sep="-"), side=3, line=-1.5, adj=0.05, cex=0.8)
}
}
mtext("Caliper Truss/Length", side=1, outer=TRUE, line=0.5)
mtext("Photo Truss/Length", side=2, outer=TRUE, line=0.5)
res <- data.frame(truss, expect, bestmodel)
resb <- res[order(res$expect, res$bestmodel, res$truss), ]
resb
cbind(truss, resb$truss)
resb
windows(w=6.5, h=8)
par(mfrow=c(7, 3), mar=c(0, 0, 0, 0), oma=c(2, 2, 1, 1))
for(i in seq_along(truss)) {
P <- ydat[, Ptruss[i]]
C <- ydat[, Ctruss[i]]
CL <- ydat[, "CALIPER.L"]
PL <- ydat[, "SIGMA.L"]
S <- as.factor(ydat$SPECIES)
G <- as.factor(ydat$TYPE)
Y <- P/PL
X <- C/CL
if(truss[i]=="L") {
fits <- list(
lm(P ~ C),
lm(P ~ C + G),
lm(P ~ C + S)
)
aic <- AICc(fits)
print(truss[i])
print(aic)
mm <- min(aic$model[aic$daicc<2])
bestmodel[i] <- c(1, 1.5, 3.5)[mm]
if(mm==1) kol <- "black" else if(mm==2) kol <- blindcolz[as.numeric(G)+1] else kol <- as.numeric(S)+1
eqscplot(C, P, type="n", lim=range(C, P), ylim=range(C, P), axes=FALSE, xlab="", ylab="")
abline(0, 1)
text(C, P, substring(S, 1, 1), col=kol)
points(C, fits[[mm]]$fitted, pch=16, col=kol)
box()
mtext(paste(truss[i], bestmodel[i], sep="-"), side=3, line=-1.5, adj=0.05, cex=0.8)
} else {
fits <- list(
lm(Y ~ X),
lm(Y ~ X + G),
lm(Y ~ X*G),
lm(Y ~ X + S),
lm(Y ~ X*S)
)
aic <- AICc(fits)
print(truss[i])
print(aic)
mm <- min(aic$model[aic$daicc<2])
bestmodel[i] <- mm
if(mm==1) kol <- "black" else if(mm<3.5) kol <- blindcolz[as.numeric(G)+1] else kol <- as.numeric(S)+1
eqscplot(X, Y, type="n", xlim=range(X, Y), ylim=range(X, Y), axes=FALSE, xlab="", ylab="")
abline(0, 1)
text(X, Y, substring(S, 1, 1), col=kol)
points(X, fits[[mm]]$fitted, pch=16, col=kol)
box()
mtext(paste(truss[i], bestmodel[i], sep="-"), side=3, line=-1.5, adj=0.05, cex=0.8)
}
}
mtext("Caliper Truss/Length", side=1, outer=TRUE, line=0.5)
mtext("Photo Truss/Length", side=2, outer=TRUE, line=0.5)
windows(w=6.5, h=8)
par(mfrow=c(7, 3), mar=c(0, 0, 0, 0), oma=c(2, 2, 1, 1))
for(i in seq_along(truss)) {
P <- ydat[, Ptruss[i]]
C <- ydat[, Ctruss[i]]
CL <- ydat[, "CALIPER.L"]
PL <- ydat[, "SIGMA.L"]
S <- as.factor(ydat$SPECIES)
G <- as.factor(ydat$TYPE)
Y <- P/PL
X <- C/CL
if(truss[i]=="L") {
fits <- list(
lm(P ~ C),
lm(P ~ C + G),
lm(P ~ C + S)
)
aic <- AICc(fits)
print(truss[i])
print(aic)
mm <- min(aic$model[aic$daicc<2])
bestmodel[i] <- c(1, 1.5, 3.5)[mm]
if(mm==1) kol <- "black" else if(mm==2) kol <- blindcolz[as.numeric(G)+1] else kol <- as.numeric(S)+1
# eqscplot(C, P, type="n", xlim=range(C, P), ylim=range(C, P), axes=FALSE, xlab="", ylab="")
plot(C, P, type="n", axes=FALSE, xlab="", ylab="")
abline(0, 1)
text(C, P, substring(S, 1, 1), col=kol)
points(C, fits[[mm]]$fitted, pch=16, col=kol)
box()
mtext(paste(truss[i], bestmodel[i], sep="-"), side=3, line=-1.5, adj=0.05, cex=0.8)
} else {
fits <- list(
lm(Y ~ X),
lm(Y ~ X + G),
lm(Y ~ X*G),
lm(Y ~ X + S),
lm(Y ~ X*S)
)
aic <- AICc(fits)
print(truss[i])
print(aic)
mm <- min(aic$model[aic$daicc<2])
bestmodel[i] <- mm
if(mm==1) kol <- "black" else if(mm<3.5) kol <- blindcolz[as.numeric(G)+1] else kol <- as.numeric(S)+1
# eqscplot(X, Y, type="n", xlim=range(X, Y), ylim=range(X, Y), axes=FALSE, xlab="", ylab="")
plot(X, Y, type="n", axes=FALSE, xlab="", ylab="")
abline(0, 1)
text(X, Y, substring(S, 1, 1), col=kol)
points(X, fits[[mm]]$fitted, pch=16, col=kol)
box()
mtext(paste(truss[i], bestmodel[i], sep="-"), side=3, line=-1.5, adj=0.05, cex=0.8)
}
}
mtext("Caliper Truss/Length", side=1, outer=TRUE, line=0.5)
mtext("Photo Truss/Length", side=2, outer=TRUE, line=0.5)
resb
figu
resb
resb$truss[resb$expect=="1 none" & resb$bestmodel!=1]
paste(resb$truss[resb$expect=="1 none" & resb$bestmodel!=1], collapse=", ")
exp1not1
exp1not1 <- resb$truss[resb$expect=="1 none" & resb$bestmodel!=1]
length(exp1not1)
numeral(length(exp1not1))
?numeral
??numeral
??number
number2words
numbers2words
??numbers2words
numbers2words <- function(x, billion=c("US", "UK")[1],and=if(billion=="US") "" else "and") {
# A function to convert a single integer into words
# Rnews Volume 5/1, May 2005, The Programmer's Niche by John Fox, How Do You Spell That Number? 
# http://cran.r-project.org/doc/Rnews/Rnews_2005-1.pdf
billion <- match.arg(billion)
trim <- function(text) gsub("(^\ *)|((\ *|-|,\ zero|-zero)$)", "", text)
makeNumber <- function(x) as.numeric(paste(x, collapse=""))
makeDigits <- function(x) strsplit(as.character(x), "")[[1]]
helper <- function(x){
negative <- x < 0
x <- abs(x)
digits <- makeDigits(x)
nDigits <- length(digits)
result <- if (nDigits == 1) as.vector(ones[digits])
else if (nDigits == 2)
if (x <= 19) as.vector(teens[digits[2]])
else trim(paste(tens[digits[1]], "-", ones[digits[2]], sep=""))
else if (nDigits == 3) {
tail <- makeNumber(digits[2:3])
if (tail == 0) paste(ones[digits[1]], "hundred")
else trim(paste(ones[digits[1]], trim(paste("hundred", and)), helper(tail)))
}
else {
nSuffix <- ((nDigits + 2) %/% 3) - 1
if (nSuffix > length(suffixes) || nDigits > 15)
stop(paste(x, "is too large!"))
pick <- 1:(nDigits - 3*nSuffix)
trim(paste(helper(makeNumber(digits[pick])), suffixes[nSuffix], helper(makeNumber(digits[-pick]))))
}
if (billion == "UK"){
words <- strsplit(result, " ")[[1]]
if (length(grep("million,", words)) > 1)
result <- sub(" million, ", ", ", result)
}
if (negative) paste("minus", result) else result
}
opts <- options(scipen=100)
on.exit(options(opts))
ones <- c("zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine")
teens <- c("ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen")
names(ones) <- names(teens) <- 0:9
tens <- c("twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety")
names(tens) <- 2:9
suffixes <- if (billion == "US")
c("thousand,", "million,", "billion,", "trillion,")
else
c("thousand,", "million,", "thousand million,", "billion,")
x <- round(x)
if (length(x) > 1) sapply(x, helper) else helper(x)
}
numbers2words(c(1234567890123, -123, 1000, 12))
numbers2words(c(4567890123, -123, 1000, 12))
numbers2words(c(4560000000, -123, 1000, 12))
?cheat
cleanup()
pkgup("jvamisc")
q()
