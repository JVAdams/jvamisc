digfish <- read.csv("C:/JVA/Consult/Yule/CiscoMorpho/LOBQ13-500 digitized.csv")
coordplot(digfish)
# I calculated the truss measurements from these coords
mytruss <- fc2truss(digfish)
# then I recreated the coordinates
look <- fishpts(mytruss)
coordplot(look[[1]])
look[[2]]
mytruss
co
dist(co)
round(mytruss, 1)
round(dist(co), 1)
round(mytruss, 1)[14:19]
truss <- as.numeric(truss)
# take the 31 truss measurements of a fish, and guess at the x,y coordinates of the fish
m.nose <- dmat(truss[1:3], 1:3)
m.head <- dmat(truss[c( 2,  8,  9,  7,  6,  5)], c(1, 3, 4, 5))
m.thorax <- dmat(truss[c( 5, 10, 13, 11, 12, 14)], c(5, 4, 6, 7))
m.abdomen <- dmat(truss[c(14, 17, 16, 18, 15, 19)], c(7, 6, 8, 9))
m.pelvis <- dmat(truss[c(19, 22, 21, 31, 20, 23)], c(9, 8, 10, 11))
m.wrist <- dmat(truss[c(23, 26, 25, 30, 24, 27)], c(11, 10, 12, 13))
m.tail <- dmat(truss[27:29], c(13, 12, 14))
m.abdomen
round(m.abdomen, 1)
dmat
dmat(c(1, 2, 3), c(1, 2, 3))
dmat(c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4))
m <- dmat(c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4))
m
m[lower.tri(m)]
m[upper.tri(m)]
?lower.tri
as.matrix.dist
stats:::as.matrix.dist(m)
m
m[upper.tri(m)] <- NA
m
stats:::as.matrix.dist(m)
?as.matrix.dist
m
as.dist(m)
as.matrix(as.dist(m))
dmat <- function(dists, names) {
# dists are the truss measurements (distances) between the points
# names are the point names
# m is the full distance matrix
rowz <- if(length(dists)==3) 3 else 4
m <- matrix(NA, nrow=rowz, ncol=rowz)
diag(m) <- 0
m[lower.tri(m)] <- dists
m <- as.matrix(as.dist(m))
dimnames(m) <- list(names, names)
m
}
truss <- as.numeric(truss)
# take the 31 truss measurements of a fish, and guess at the x,y coordinates of the fish
m.nose <- dmat(truss[1:3], 1:3)
m.head <- dmat(truss[c( 2,  8,  9,  7,  6,  5)], c(1, 3, 4, 5))
m.thorax <- dmat(truss[c( 5, 10, 13, 11, 12, 14)], c(5, 4, 6, 7))
m.abdomen <- dmat(truss[c(14, 17, 16, 18, 15, 19)], c(7, 6, 8, 9))
m.pelvis <- dmat(truss[c(19, 22, 21, 31, 20, 23)], c(9, 8, 10, 11))
m.wrist <- dmat(truss[c(23, 26, 25, 30, 24, 27)], c(11, 10, 12, 13))
m.tail <- dmat(truss[27:29], c(13, 12, 14))
m.abdomen
pick5 <- sample(dim(dat)[1], 5)
for(i in seq(pick5)) {
look <- fishpts(dat[i, ltrussvars])
coordplot(look[[1]])
lines(look[[2]][c(1:4, 6, 8, 10, 12, 14, 13, 11, 9, 7, 5, 1), ])
}
# I calculated the truss measurements from these coords
mytruss <- fc2truss(digfish)
# walk through digitized fish ... S L O W L Y
truss <- mytruss
truss <- as.numeric(truss)
# take the 31 truss measurements of a fish, and guess at the x,y coordinates of the fish
m.nose <- dmat(truss[1:3], 1:3)
m.head <- dmat(truss[c( 2,  8,  9,  7,  6,  5)], c(1, 3, 4, 5))
m.thorax <- dmat(truss[c( 5, 10, 13, 11, 12, 14)], c(5, 4, 6, 7))
m.abdomen <- dmat(truss[c(14, 17, 16, 18, 15, 19)], c(7, 6, 8, 9))
m.pelvis <- dmat(truss[c(19, 22, 21, 31, 20, 23)], c(9, 8, 10, 11))
m.wrist <- dmat(truss[c(23, 26, 25, 30, 24, 27)], c(11, 10, 12, 13))
m.tail <- dmat(truss[27:29], c(13, 12, 14))
m.abdomen
# start with abdomen
co1 <- cmdscale(m.abdomen)
coordplot(co1)
# move so that 7-9 midpoint is origin
co2 <- coordmove(co1, apply(co1[c("7", "9"), ], 2, mean), c(0, 0))
# rotate coordinates around origin, so that 7-9 is on a straight y=k line
dif <- apply(co2[c("7", "9"), ], 2, diff)
co3 <- coordturn(co2, c(0, 0), atan(dif[2]/dif[1]))
westgood <- co3["9", 1] > co3["7", 1]
northgood <- co3["7", 1] > co3["6", 1]
co4 <- co3
coordplot(co4)
if(!westgood & !northgood) {
# if both west and north are bad, rerotate additional 180
co4 <- coordturn(co2, c(0, 0), atan(dif[2]/dif[1])-pi)
} else {
if(!westgood) {
# if just west is bad, flip over the x=0 line
co4[, 1] <- -co3[, 1]
} else {
if(!northgood) {
# if just north is bad, flip over the y=0 line
co4[, 2] <- -co3[, 2]
} else {
co4 <- co3
}
}
}
c.abdomen <- co4
coordplot(c.abdomen)
# start with abdomen
co1 <- cmdscale(m.abdomen)
# move so that 7-9 midpoint is origin
co2 <- coordmove(co1, apply(co1[c("7", "9"), ], 2, mean), c(0, 0))
# rotate coordinates around origin, so that 7-9 is on a straight y=k line
dif <- apply(co2[c("7", "9"), ], 2, diff)
co3 <- coordturn(co2, c(0, 0), atan(dif[2]/dif[1]))
westgood <- co3["9", 1] > co3["7", 1]
northgood <- co3["7", 1] > co3["6", 1]
co4 <- co3
westgood
northgood
coordplot(co3)
co3
# start with abdomen
co1 <- cmdscale(m.abdomen)
# move so that 7-9 midpoint is origin
co2 <- coordmove(co1, apply(co1[c("7", "9"), ], 2, mean), c(0, 0))
# rotate coordinates around origin, so that 7-9 is on a straight y=k line
dif <- apply(co2[c("7", "9"), ], 2, diff)
co3 <- coordturn(co2, c(0, 0), atan(dif[2]/dif[1]))
westgood <- co3["9", 1] > co3["7", 1]
northgood <- co3["7", 2] > co3["6", 2]
co4 <- co3
if(!westgood & !northgood) {
# if both west and north are bad, rerotate additional 180
co4 <- coordturn(co2, c(0, 0), atan(dif[2]/dif[1])-pi)
} else {
if(!westgood) {
# if just west is bad, flip over the x=0 line
co4[, 1] <- -co3[, 1]
} else {
if(!northgood) {
# if just north is bad, flip over the y=0 line
co4[, 2] <- -co3[, 2]
} else {
co4 <- co3
}
}
}
c.abdomen <- co4
coordplot(c.abdomen)
fishpts <- function(truss) {
truss <- as.numeric(truss)
# take the 31 truss measurements of a fish, and guess at the x,y coordinates of the fish
m.nose <- dmat(truss[1:3], 1:3)
m.head <- dmat(truss[c( 2,  8,  9,  7,  6,  5)], c(1, 3, 4, 5))
m.thorax <- dmat(truss[c( 5, 10, 13, 11, 12, 14)], c(5, 4, 6, 7))
m.abdomen <- dmat(truss[c(14, 17, 16, 18, 15, 19)], c(7, 6, 8, 9))
m.pelvis <- dmat(truss[c(19, 22, 21, 31, 20, 23)], c(9, 8, 10, 11))
m.wrist <- dmat(truss[c(23, 26, 25, 30, 24, 27)], c(11, 10, 12, 13))
m.tail <- dmat(truss[27:29], c(13, 12, 14))
# start with abdomen
co1 <- cmdscale(m.abdomen)
# move so that 7-9 midpoint is origin
co2 <- coordmove(co1, apply(co1[c("7", "9"), ], 2, mean), c(0, 0))
# rotate coordinates around origin, so that 7-9 is on a straight y=k line
dif <- apply(co2[c("7", "9"), ], 2, diff)
co3 <- coordturn(co2, c(0, 0), atan(dif[2]/dif[1]))
westgood <- co3["9", 1] > co3["7", 1]
northgood <- co3["7", 2] > co3["6", 2]
co4 <- co3
if(!westgood & !northgood) {
# if both west and north are bad, rerotate additional 180
co4 <- coordturn(co2, c(0, 0), atan(dif[2]/dif[1])-pi)
} else {
if(!westgood) {
# if just west is bad, flip over the x=0 line
co4[, 1] <- -co3[, 1]
} else {
if(!northgood) {
# if just north is bad, flip over the y=0 line
co4[, 2] <- -co3[, 2]
} else {
co4 <- co3
}
}
}
c.abdomen <- co4
# c.dorsal <- matrix(c(-1, 0, 0, 1), ncol=2, dimnames=list(c("7", "9"), NULL))
# c.abdomen2 <- addtruss(oldpts=c.dorsal, newm=m.abdomen, overlap=c("7", "9"), westeast=c("7", "9"))
c.pelvis <- addtruss(oldpts=c.abdomen, newm=m.pelvis, overlap=c("8", "9"), westeast=c("9", "11"))
c.wrist <- addtruss(oldpts=c.pelvis, newm=m.wrist, overlap=c("10", "11"), westeast=c("11", "13"))
c.tail <- addtruss(oldpts=c.wrist, newm=m.tail, overlap=c("12", "13"), westeast=c("12", "14"))
c.thorax <- addtruss(oldpts=c.abdomen, newm=m.thorax, overlap=c("6", "7"), westeast=c("4", "6"))
c.head <- addtruss(oldpts=c.thorax, newm=m.head, overlap=c("4", "5"), westeast=c("3", "4"))
c.nose <- addtruss(oldpts=c.head, newm=m.nose, overlap=c("3", "1"), westeast=c("2", "1"))
c.fish <- rbind(c.nose, c.head, c.thorax, c.abdomen, c.pelvis, c.wrist, c.tail)
c.fish.m <- apply(c.fish, 2, tapply, as.numeric(dimnames(c.fish)[[1]]), mean)
list(all=c.fish, mean=c.fish.m)
}
pick5 <- sample(dim(dat)[1], 5)
for(i in seq(pick5)) {
look <- fishpts(dat[i, ltrussvars])
coordplot(look[[1]])
lines(look[[2]][c(1:4, 6, 8, 10, 12, 14, 13, 11, 9, 7, 5, 1), ])
}
fish3 <- dat[dat$ID %in% c(102577, 106227, 500), ltrussvars]
look1 <- fishpts(fish3[3, ])
coordplot(look1[[1]])
coordplot(look1[[2]])
coordplot
medun
fishcoords(medun[, 1]
)
fishcoords(medun[, 1])
coordplot(fishcoords(medun[, 1]))
fishlabs
medun <- t(apply(subm[, ltrussvars], 2, tapply, group, median, na.rm=TRUE))
fc <- apply(medun, 2, fishpts)
graphics.off()
cleanup()
# C:\JVA\Consult\Yule\CiscoMorpho\CiscoMorph.r
# bring in functions
source("C:/JVA/Consult/Yule/CiscoMorpho/CiscoMorphFunctions.r")
library(fpc)
library(rpart)
library(rpart.plot)
wb <- loadWorkbook("C:/JVA/Consult/Yule/CiscoMorpho/Cisco size-corrected residuals FINAL.xls")
dat1 <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1)
dat1$LS <- paste(substring(dat1$LAKE, 1, 1), dat1$SITE, sep=" - ")
wb <- loadWorkbook("C:/JVA/Consult/Yule/CiscoMorpho/FISH MORPHOMETRICS with total lengths RAW Truss measurements.xlsx")
datraw <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1)
dat2 <- cbind(dat1, datraw[match(dat1$ID, datraw$ID.), paste0("L", 1:31)])
ltrussvars <- paste0("L", 1:31)
rtrussvars <- paste0("r", 1:31)
doc <- startrtf(file="CiscoMorph", dir="C:/JVA/Consult/Yule/CiscoMorpho")
heading("Exploring Dan's Cisco Morphometrics Data")
heading("Jean V. Adams - 2 July 2014", 2)
para("There was one row in the cisco morphometrics data with missing truss measurements (Table ", tabcount, ").",
"  This row was eliminated from further analysis.")
tab <- dat2[is.na(dat2$L1), c("OBS", "ID", "SEX", "AGE", "LAKE", "SITE", "LS", "TL", ltrussvars[1:5])]
tabl("Records with missing truss measurements.", row.names=FALSE)
sethdat <- dat2[!is.na(dat2$L1), ]
para("There were a few rows in the cisco morphometrics data with duplicate IDs.",
"  Most of the measurements were pretty close, but a few were a bit further off (Table ", tabcount, ").",
"  Dan checked into these, and could only find photos for OBSs 563 and 675,",
" so all of the other observations were removed prior to analysis.")
a <- sethdat[sethdat$ID %in% sethdat$ID[duplicated(sethdat$ID)], ]
b <- a[c(1, 3, 5, 7, 9), rtrussvars] - a[c(2, 4, 6, 8, 10), rtrussvars]
#plot(sort(abs(unlist(b))))
tab <- a[, c(1:7, 7+c(9, 16, 28, 29))]
tab[, 8:11] <- format(round(tab[, 8:11], 2))
tabl("Records with duplicate IDs.  Truss measurements are given for those measures that were off by more than 0.3.", row.names=FALSE)
sethdat <- sethdat[!(sethdat$OBS %in% tab$OBS[!(tab$OBS %in% c(563, 675))]), ]
para("Prior to analysis, the size component was removed from the morphometric measures.",
"  Truss measurements (in mm) were natural log transformed, and the first principal component",
" (based on the covariance matrix) of these measures was used as general measure of size (Figure ", figcount, ").")
# log transform the lengths
ldat <- log(sethdat[, ltrussvars])
# use the first principal component as size
size <- princomp(ldat, cor=FALSE, scores=TRUE)$scores[, 1]
fig <- function() {
par(mar=c(4, 4, 1, 1))
plot(sethdat$TL, size, xlab="Total length of fish  (mm)", ylab="General measure of size  (PC1)", las=1)
}
figu("Relation between fish total length and derived general measure of fish size based on the first",
" principal component score of the log transformed truss measurements.", h=4, w=4)
# regress size (x) on each of the log transformed lengths (y) to get a residual
rdat <- sapply(ldat, function(y) lm(y ~ size)$resid)
dimnames(rdat)[[2]] <- rtrussvars
dat <- cbind(sethdat[, c("OBS", "ID", "SEX", "AGE", "LAKE", "SITE", "LS", "TL", ltrussvars)], size, rdat)
# write.csv(dat, "C:/JVA/Consult/Yule/CiscoMorpho/Cisco morpho with Jean residuals.csv", row.names=FALSE)
if(FALSE) {
# compare new resids to Seth's resids
windows()
plot(rdat[, 15], sethdat[, rtrussvars][, 15])
lm(sethdat[, rtrussvars][, 15] ~ rdat[, 15])
# compare new resids to Seth's resids
windows()
plot(rdat[, 25], sethdat[, rtrussvars][, 25])
lm(sethdat[, rtrussvars][, 25] ~ rdat[, 25])
}
rm(wb, dat1, datraw, dat2, sethdat, a, b, ldat, size, rdat)
para("There were also ", sum(is.na(dat$SEX)), " records where sex was missing (Table ", tabcount, ").")
a <- table(dat$LS[is.na(dat$SEX)])
tab <- data.frame(LakeSite=names(a), Nrecords=as.numeric(a))
tabl("Number of records, by lake and site, with nothing entered for sex.", row.names=FALSE)
para("And ", sum(!is.na(dat$SEX) & !(dat$SEX %in% 1:2)), " records where sex was not equal to 1 or 2 (Table ", tabcount, ").")
tab <- dat[!is.na(dat$SEX) & !(dat$SEX %in% 1:2), 1:10]
tab[, 8:10] <- round(tab[, 8:10], 2)
tabl("Records with sex not equal to 1 or 2.", row.names=FALSE)
para("For analyses conducted for individual sexes, I used only those records with sex equal to 1 (males) or 2 (females) .",
"  In all cases (both sexes, just males, and just females),",
" I scaled the data (subtracting the mean and dividing by the standard deviation),",
" so that all of the truss measurements would have the same mean and variance.",
"  This ensures that each truss measure will be given the same amount of weight in a cluster analysis.")
# subset the data
submf <- dat[!duplicated(dat$ID), ]
subm <- dat[!duplicated(dat$ID) & !is.na(dat$SEX) & dat$SEX==1, ]
subf <- dat[!duplicated(dat$ID) & !is.na(dat$SEX) & dat$SEX==2, ]
# rescale the data
subscmf <- scale(submf[, rtrussvars])
subscm <- scale(subm[, rtrussvars])
subscf <- scale(subf[, rtrussvars])
para("I looked at the length distribution and sex composition at all sites (Figures ", figcount, " and ", figcount+1, ").")
susl <- sort(unique(dat$LS))
tlmed <- tapply(submf$TL, submf$LS, median)
ord <- order(tlmed)
fig <- function() {
par(mfrow=c(length(susl), 1), mar=c(0, 0, 0, 0), oma=c(4, 1, 1, 0))
for(i in ord) {
sel <- submf$LS == susl[i]
hist(submf$TL[sel], breaks=seq(200, 550, 10), axes=FALSE, col="gray", xlab="", ylab="", main="")
mtext(susl[i], side=3, line=-1, adj=0.05, cex=0.7)
abline(v=seq(200, 550, 50))
abline(v=tlmed[i], col="cyan", lwd=2)
}
axis(1, outer=TRUE, lwd=0, lwd.ticks=1)
mtext("Total length  (mm)", side=1, outer=TRUE, line=2.5)
mtext("Frequency", side=2, outer=TRUE, line=-0.5)
}
figu("Length frequency distribution of all fish by lake and site, sites ordered by median length (vertical cyan lines).", newpage="port")
subb <- rbind(subm, subf)
pmale <- tapply(subb$SEX==1, subb$LS, mean)
ord <- order(pmale)
fig <- function() {
par(mar=c(4, 11, 1, 1), xaxs="i")
barplot(pmale[ord], horiz=TRUE, las=1, xlim=c(0, 1), xlab="Proportion males", ylab="")
box()
abline(v=seq(0.2, 0.8, 0.2))
}
figu("Sex composition by lake and site, sites ordered by the proportion of males.", h=4, w=4)
ks <- 1:14
pamcl <- pamk(data=subscmf, krange=ks, criterion="asw", usepam=TRUE, scaling=FALSE, diss=FALSE)
group <- pamcl$pamobject$clustering
para("I used the PAM (partitioning around medioids) method for clustering.",
"  I let the number of clusters range from 1 to 14 (since there were 14 sites).",
"  The recommended number of clusters for data from both sexes combined",
" based on the optimum average silhouette width was ", pamcl$nc, " (Figure ", figcount, ").")
fig <- function() {
plot(ks[-1], pamcl$crit[-1], las=1, type="b", 
xlab="No. of clusters", ylab="Average silhouette width", main="14 Sites, Both Sexes")
abline(v=pamcl$nc, lty=2)
sel <- ks==pamcl$nc
points(ks[sel], pamcl$crit[sel], pch=16, cex=1.5)
}
figu("Recommended number of clusters based on the optimum average silhouette width, 14 sites and both sexes combined.", h=4, w=4)
g1 <- sort(tapply(group==1, list(submf$LS), mean))
tab <- data.frame(LakeSite=names(g1), PropGrp1=format(round(g1, 4)))
tabl("Proportion of each cluster group in each lake and site, ordered by proportion, 14 sites and both sexes combined.", row.names=FALSE)
fig <- function() {
par(mar=c(4, 8, 1, 1))
barplot(rbind(rev(g1), 1-rev(g1)), horiz=TRUE, las=1, xlab="Proportion", ylab="")
}
figu("Proportion of each cluster group in each lake and site, ordered by proportion, 14 sites and both sexes combined.", h=4, w=4)
rm(tlmed, ord, subb, pmale)
para("I calculated the median of each of the scaled measurements for each group.",
"  Then I looked at the difference between those medians to see which truss measurements",
" were the most different between the groups (Figure ", figcount, ").")
medun <- t(apply(submf[, ltrussvars], 2, tapply, group, median, na.rm=TRUE))
fc <- apply(medun, 2, fishcoords)
fl <- lapply(fc, fishlabs)
flabs <- data.frame(x=apply(sapply(fl, function(x) x[, 1]), 1, mean),
y=apply(sapply(fl, function(x) x[, 2]), 1, mean))
xyr <- apply(do.call(rbind, fc), 2, range)
fig <- function() {
par(mar=rep(0, 4))
eqscplot(1, 1, type="n", xlim=xyr[, 1], ylim=xyr[, 2], axes=FALSE, xlab="", ylab="")
for(i in 1:length(fc)) {
co <- fc[[i]]
points(co, col=i)
lines(co[c(1:2, 4, 6:7), ], col=i)
lines(co[c(3, 2, 5), ], col=i)
}
text(flabs, c("16", "21", "22", "19", "30", "27"), font=2)
}
figu("Diagram of median fish truss measurements for each group (1 = black, 2 = red), 14 sites and both sexes combined.", h=2, w=4)
pick5 <- sample(dim(dat)[1], 5)
for(i in seq(pick5)) {
look <- fishpts(dat[i, ltrussvars])
coordplot(look[[1]])
lines(look[[2]][c(1:4, 6, 8, 10, 12, 14, 13, 11, 9, 7, 5, 1), ])
}
fish3 <- dat[dat$ID %in% c(102577, 106227, 500), ltrussvars]
look1 <- fishpts(fish3[3, ])
coordplot(look1[[1]])
# I put in digitized coordinates
digfish <- read.csv("C:/JVA/Consult/Yule/CiscoMorpho/LOBQ13-500 digitized.csv")
coordplot(digfish)
# I calculated the truss measurements from these coords
mytruss <- fc2truss(digfish)
# then I recreated the coordinates
look <- fishpts(mytruss)
coordplot(look[[1]])
# this simple example worked just fine
x <- c(0, 5, 0, 2)
y <- c(0, 0, 3, 4)
co <- cbind(x, y)
coordplot(co)
coordplot(cmdscale(dist(co)))
# try the same thing on the abdomen of the fish I digitized
# also works
co <- digfish[6:9, ]
coordplot(co)
coordplot(cmdscale(dist(co)))
# walk through digitized fish ... S L O W L Y
truss <- mytruss
# these two agree, so fc2truss() seems to be okay
round(mytruss, 1)[14:19]
round(dist(co), 1)
# this one's okay, but differently ordered
round(m.abdomen, 1)
windows()
par(mar=c(1, 1, 1, 1))
eqscplot(pts[, 1], pts[, 2], type="n", axes=FALSE, xlab="", ylab="")
m <- as.matrix(dist(look[[2]]))
m[6, 7]
m[6, 9]
m[7, 9]
m[7, 8]
m[6, 8]
m[8, 9]
fish3[3, paste0("L", 14:19)]
# median measures per group
med <- t(apply(subscmf, 2, tapply, group, median))
med2 <- data.frame(med, mdif = med[, 1] - med[, 2])
med3 <- med2[order(med2$mdif), ]
amdif <- abs(med2$mdif)
fig <- function() {
plot(1:dim(med2)[1], med2$mdif, ylim=c(-1, 1)*max(amdif), las=1,
xlab="Truss  (r#)", ylab="Difference between scaled measures of group 1 and 2", main="14 Sites, Both Sexes")
abline(h=0)
segments(1:dim(med2)[1], med2$mdif, 1:dim(med2)[1], 0)
}
figu("Difference in truss measurements between the cluster groups, 14 sites and both sexes combined, 14 sites and both sexes combined.", 
h=4, w=4)
para("I also looked at how the clustering would have proceeded if we had started with a single cluster of fish at each site.",
"  For this, I used agglomerative hierarchical clustering with the centroid method and the squared Euclidean distances (Figure ",
figcount, ".)")
cent <- apply(subscmf, 2, tapply, submf$LS, mean)
hc1 <- hclust(dist(cent)^2, method="centroid", members=table(submf$LS))
fig <- function() {
par(mar=c(1, 4, 1, 1))
plot(hc1, xlab="", sub="", , main="14 Sites, Both Sexes")
}
figu("Centroid cluster analysis starting with a single cluster at each site, 14 sites and both sexes combined.", h=4, w=4)
pamcl <- pamk(data=subscm, krange=ks, criterion="asw", usepam=TRUE, scaling=FALSE, diss=FALSE)
group <- pamcl$pamobject$clustering
para("The recommended number of clusters for males at 13 sites was ", pamcl$nc, " (Figure ", figcount, ").")
fig <- function() {
plot(ks[-1], pamcl$crit[-1], las=1, type="b", 
xlab="No. of clusters", ylab="Average silhouette width", main="13 Sites, Males")
abline(v=pamcl$nc, lty=2)
sel <- ks==pamcl$nc
points(ks[sel], pamcl$crit[sel], pch=16, cex=1.5)
}
figu("Recommended number of clusters based on the optimum average silhouette width, males at 13 sites.", h=4, w=4)
g1 <- sort(tapply(group==1, list(subm$LS), mean))
tab <- data.frame(LakeSite=names(g1), PropGrp1=format(round(g1, 4)))
tabl("Proportion of each cluster group in each lake and site, ordered by proportion, males at 13 sites.", row.names=FALSE)
fig <- function() {
par(mar=c(4, 8, 1, 1))
barplot(rbind(rev(g1), 1-rev(g1)), horiz=TRUE, las=1, xlab="Proportion", ylab="")
}
figu("Proportion of each cluster group in each lake and site, ordered by proportion, males at 13 sites.", h=4, w=4)
medun <- t(apply(subm[, ltrussvars], 2, tapply, group, median, na.rm=TRUE))
fc <- apply(medun, 2, fishpts)
fc
fc <- apply(medun, 2, function(x) fishpts(x)[[2]])
fc
fc <- lapply(medun, function(x) fishpts(x)[[2]])
medun
class(medun)
fc <- lapply(data.frame(medun), function(x) fishpts(x)[[2]])
fc
xyr <- apply(do.call(rbind, fc), 2, range)
xyr
medun
?coordplot
coordturn
test <- matrix(c(0, 4, 1, 0, 2, 3), ncol=2, dimnames=list(LETTERS[1:3], NULL))
coordplot(test)
test <- matrix(c(0, 4, 1, 0, 2, 3), ncol=2, dimnames=list(LETTERS[1:3], NULL))
coordplot(test)
# rotate the coordinates clockwise 45 degrees around the first point (the origin)
rottest <- coordturn(test, test[1, ], rot=pi/4)
coordplot(rottest)
class(rottest)
test <- data.frame(matrix(c(0, 4, 1, 0, 2, 3)), ncol=2, dimnames=list(LETTERS[1:3], NULL))
test <- data.frame(matrix(c(0, 4, 1, 0, 2, 3), ncol=2, dimnames=list(LETTERS[1:3], NULL))
)
rottest <- coordturn(test, test[1, ], rot=pi/4)
class(rottest)
rottest
test <- data.frame(matrix(c(0, 4, 1, 0, 2, 3), ncol=2, dimnames=list(LETTERS[1:3], NULL))
+ )
test <- data.frame(matrix(c(0, 4, 1, 0, 2, 3), ncol=2, dimnames=list(LETTERS[1:3], NULL)))
coordturn(test, test[1, ], rot=pi/4)
test <- matrix(c(0, 4, 1, 0, 2, 3), ncol=2, dimnames=list(LETTERS[1:3], NULL))
coordturn(test, test[1, ], rot=pi/4)
?coordturn
?cheat
library(devtools)
setwd("C:/JVA/GitHub/jvamisc")
document()
q()
