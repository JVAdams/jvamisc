result2
}
rm(expected, corrected, expected.dif.5, correction)
chi.prop <- function(obs.prop, exp.prop, n) {
# chi squared value from observed and expected proportions and n
sum(n * (obs.prop - exp.prop)^2 / (exp.prop * (1 - exp.prop)))
}
pchi.from.LC <- function(x, data, list=F) {
# calculate chi squared value from given line (defined by log10 transform of the lc50 and lc999)
LC50 <- x[1]
LC999 <- x[2]
slope <- probit(0.999) / (LC999 - LC50)
int <- -slope*LC50
expected <- inv.probit(int + slope*data$x)
# B. 1. If the expected value for any 0% or 100% dose is < 0.01% or > 99.99%, delete record
sel <- (expected >= 0.0001 & expected <= 0.9999) | data$mcat==50
n <- sum(sel)
# B. 2. Using the expected effect, record a corrected value for each 0 and 100% effect
cor.exp <- ifelse(data$mcat==50, expected, correct.val(expected))
if(n > 2) {
### C. The chi squared test
chi. <- chi.prop(data$pdead[sel], cor.exp[sel], n)
p. <- 1-pchisq(chi., n-2)
} else {
chi. <- NA
p. <- NA
}
# save the p value as a negative for minimization by optim()
if(list) y <- list(chi2=chi., p=p., df=n-2) else y <- -p.
y
}
startvals <- function(data) {
# define log10(lc50) and log10(lc999) starting values
fit <- lm(y ~ x, data=data)
lc50.1 <- -fit$coef[1]/fit$coef[2]
lc999.1 <- (probit(0.999) - fit$coef[1])/fit$coef[2]
sv <- c(lc50.1, lc999.1)
p <- pchi.from.LC(x=sv, data=data, list=F)
list(sv=sv, p=p)
}
LWauto <- function(dose, ndead, ntot, description="", plot=T) {
### A. The data and graph.
# A 1. Don't list > 2 consecutive 100% effects at the upper end or > 2 consecutive 0% effects at the lower end.
df <- data.frame(dose=dose, ndead=ndead, ntot=ntot)
df$nalive <- df$ntot - df$ndead
df$pdead <- df$ndead/df$ntot
df <- df[order(df$dose, df$pdead), ]
# get rid of any zero dosages (controls)
df <- df[df$dose > 0, ]
# get rid of consecutives ...
df2 <- df[only2consec(df$pdead), ]
# define three mortality categories, 0 for no dead, 100 for all dead, and 50 from any proportional mortality
df2$mcat <- rep(50, length(df2$pdead))
df2$mcat[df2$ntot==df2$nalive] <- 0
df2$mcat[df2$ntot==df2$ndead] <- 100
# if we have < 3 observations or we only have all dead or all survive, we can't estimate LCs
if((var(df2$mcat) < 0.00000001 & df2$mcat[1] != 50) | dim(df2)[1] < 3) {
estLCs <- NA
chi <- NA
} else {
# A 2. Plot doses against % effect on logarithmic-probability paper
df2$x <- log10(df2$dose)
df2$y <- probit(df2$pdead)
yr <- probit(c(0.001, 0.999))
df2$y[df2$pdead==0] <- yr[1]
df2$y[df2$pdead==1] <- yr[2]
# calculate starting values
pms <- sum(df2$mcat==50)
svp <- list(sv=c(NA, NA), p=NA)
# fit line to partial mortalities alone
if(pms > 1) {
df3 <- df2[df2$mcat==50, ]
svp <- startvals(df3)
}
# fit line to partial mortalities with last 0% and first 100%
if(pms==1 | is.na(svp$p)) {
df3 <- rbind(df2[df2$mcat==0, ][sum(df2$mcat==0), ], df2[df2$mcat==50, ], df2[df2$mcat==100, ][1, ])
svp <- startvals(df3)
}
# fit line to all the data
if(pms < 1 | is.na(svp$p)) {
svp <- startvals(df2)
}
# fit line to first 0% and last 100% alone
if(is.na(svp$p)) {
df3 <- rbind(df2[df2$mcat==0, ][1, ], df2[df2$mcat==100, ][sum(df2$mcat==100), ])
svp <- startvals(df3)
}
# find the LC50 and LC999 (on the log10 scale) that give the lowest p value for the chi-square
bestLC <- optim(par=svp$sv, fn=pchi.from.LC, data=df2)
estLCs <- bestLC$par
chi <- pchi.from.LC(estLCs, data=df2, list=T)
if(!is.na(chi$p) & chi$p < 0.05) print("Chi squared test indicates poor fit.")
rm(pms, svp, df3, bestLC)
}
# L-W
slope <- as.numeric(probit(0.999) / (estLCs[2] - estLCs[1]))
int <- -slope*estLCs[1]
LC25 <- as.numeric(10^( (probit(0.25) - int) / slope ))
LC50 <- as.numeric(10^estLCs[1])
LC99.9 <- as.numeric(10^estLCs[2])
# Straight probit analysis - best line, LC99.9
sel <- dose > 0
pdf <- data.frame(tfm.dose=dose, n.larv=ntot, n.dead=ndead, prop.dead=ndead/ntot)[sel, ]
probitfit <- glm(cbind(n.dead, n.larv-n.dead) ~ log10(tfm.dose), family=binomial(link=probit), data=pdf)
probitcoef <- coef(summary(probitfit))
logD25 <- dose.p(probitfit, cf=1:2, p=0.25)
D25 <- 10^c(logD25 + c(0, -1.96, 1.96) * attr(logD25, "SE"))
names(D25) <- c("D25", "lower", "upper")
logD50 <- dose.p(probitfit, cf=1:2, p=0.5)
D50 <- 10^c(logD50 + c(0, -1.96, 1.96) * attr(logD50, "SE"))
names(D50) <- c("D50", "lower", "upper")
logD999 <- dose.p(probitfit, cf=1:2, p=0.999)
D999 <- 10^c(logD999 + c(0, -1.96, 1.96) * attr(logD999, "SE"))
names(D999) <- c("D999", "lower", "upper")
Pint <- coef(summary(probitfit))[1, 1] + c(0, -1.96, 1.96)*coef(summary(probitfit))[1, 2]
Pslope <- coef(summary(probitfit))[2, 1] + c(0, -1.96, 1.96)*coef(summary(probitfit))[2, 2]
dfout <- data.frame(
param = rep(c("LC25", "LC50", "LC99.9", "intercept", "slope"), 2),
method = rep(c("Auto Litchfield-Wilcoxon", "Probit"), c(5, 5)),
estimate = c(LC25, LC50, LC99.9, int, slope, D25[1], D50[1], D999[1], Pint[1], Pslope[1]),
lower95ci = c(NA, NA, NA, NA, NA, D25[2], D50[2], D999[2], Pint[2], Pslope[2]),
upper95ci = c(NA, NA, NA, NA, NA, D25[3], D50[3], D999[3], Pint[3], Pslope[3])
)
if(plot) {
# LW
LC0.1 <- as.numeric(10^( (probit(0.001) - int) / slope ))
pred <- inv.probit(int + slope*df2$x)
cor.pred <- ifelse(df2$mcat==50, pred, correct.val(pred))
# probit
logd001 <- dose.p(probitfit, cf=1:2, p=0.001)
D001 <- 10^c(logd001 + c(0, -1.96, 1.96) * attr(logd001, "SE"))
names(D001) <- c("D001", "lower", "upper")
#windows(h=6.5, w=6.5)
par(mar=c(4.5, 4.5, 2, 1), cex=1.5, las=1)
plot(df2$x, df2$y, type="n", axes=F, xlim=range(c(df2$x, log10(LC0.1), log10(LC99.9)), na.rm=T), 
ylim=probit(c(0.001, 0.999)), xlab="Dose", ylab="Mortality  (%)", main=description)
# background grid and axes
tikz1 <- pretty(10^(range(c(df2$x, log10(LC0.1), log10(LC99.9)), na.rm=T)))
tikz3 <- c(seq(0.1, 0.9, 0.1), seq(1, 9, 1), seq(10, 90, 10), seq(91, 99, 1), seq(99.1, 99.9, 0.1))
tikz4 <- c(0.1, 1, 10, 50, 90, 99, 99.9)
tikz5 <- c(25, 50, 99.9)
abline(v=log10(tikz1), lwd=2, col="lightgray")
axis(1, at=log10(tikz1), labels=tikz1)
abline(h=probit(tikz3/100), col="lightgray")
abline(h=probit(tikz4/100), lwd=2, col="lightgray")
abline(h=probit(tikz5/100), lwd=2, col="brown")
axis(2, at=probit(tikz4/100), labels=tikz4)
box()
# LW line - use a dashed line for "poor fits" as defined by chi squared test
if(!is.na(chi$p) & chi$p < 0.05) {
abline(int, slope, lwd=3, lty=2)
} else {
abline(int, slope, lwd=3)
}
# probit line
lines(log10(c(D001[1], D999[1])), probit(c(0.001, 0.999)), lwd=3, lty=3, col="red")
# LW 99.9 point
points(log10(LC99.9), probit(0.999), pch=3, lwd=3, cex=1.7)
# observed points
points(df2$x[df2$mcat==50], df2$y[df2$mcat==50], pch=16, cex=1.5)
points(df2$x[df2$mcat!=50], df2$y[df2$mcat!=50], lwd=3, cex=1.5)
# notes on graph
par(cex=1.3)
right <- 0.8 * (par("usr")[2] - par("usr")[1]) + par("usr")[1]
text(right, -1.2, "Automated LW", font=2)
text(right, -1.6, "LC25", adj=1)
text(right, -1.6, paste(" =", formatC(LC25, digits=3, flag="#")), adj=0)
text(right, -2, "LC50", adj=1)
text(right, -2, paste(" =", formatC(LC50, digits=3, flag="#")), adj=0)
text(right, -2.4, "LC99.9", adj=1)
text(right, -2.4, paste(" =", formatC(LC99.9, digits=3, flag="#")), adj=0)
text(right, -2.8, "Slope", adj=1)
text(right, -2.8, paste(" =", formatC(slope, digits=3, flag="#")), adj=0)
if(!is.na(chi$p) & chi$p < 0.05) text(right, -3.2, "(poor fit)")
left <- 0.2 * (par("usr")[2] - par("usr")[1]) + par("usr")[1]
text(left, 2.9, "Probit", font=2, col="red")
text(left, 2.5, "LC25", adj=1, col="red")
text(left, 2.5, paste(" =", formatC(D25[1], digits=3, flag="#")), adj=0, col="red")
text(left, 2.1, "LC50", adj=1, col="red")
text(left, 2.1, paste(" =", formatC(D50[1], digits=3, flag="#")), adj=0, col="red")
text(left, 1.7, "LC99.9", adj=1, col="red")
text(left, 1.7, paste(" =", formatC(D999[1], digits=3, flag="#")), adj=0, col="red")
text(left, 1.3, "Slope", adj=1, col="red")
text(left, 1.3, paste(" =", formatC(Pslope[1], digits=3, flag="#")), adj=0, col="red")
rm(int, LC0.1, pred, cor.pred, tikz1, tikz3, tikz4, right)
}
dfout
}
rawfile <- tk_choose.files(filters=matrix(c("csv", ".csv"), ncol=2))
rawdat <- read.csv(rawfile, as.is=TRUE)
rawdat2 <- data.frame(lapply(rawdat, fill))
filesegs <- strsplit(rawfile, "/")[[1]]
L <- length(filesegs)
filename <- filesegs[L]
dirname <- paste(filesegs[-L], collapse="/")
prefix <- strsplit(filename, ".csv")[[1]]
smryname <- paste0(prefix, "Smry.csv")
pdfname <- paste0(prefix, "Smry.pdf")
pdf(file = paste(dirname, pdfname, sep="/"), paper="letter")
sut <- sort(unique(rawdat2$Test.ID))
results <- vector("list", length(sut))
for(i in seq(along=sut)) {
sel <- rawdat2$Test.ID==sut[i]
dfout <- LWauto(dose=rawdat2$TFM.Conc...mg.L.[sel], 
ndead=rawdat2$No..Dead[sel], 
ntot=rawdat2$No..Tested[sel], 
description=with(rawdat2[sel, ], paste(Test.ID, Source, Batch, Species))[1])
results[[i]] <- cbind(rawdat2[sel, ][rep(1, 10), 1:8], dfout)
}
smrydat <- do.call(rbind, results)
write.csv(smrydat, paste(dirname, smryname, sep="/"), row.names=FALSE)
graphics.off()
source("C:\\JVA\\Lamprey\\ChemControl\\Toxicity\\LWPProgram.r")
cleanup()
y
attach(jvamisc)
library(jvamisc)
cleanup()
q()
## simulate a response y and two predictors x and z
x <- rnorm(100,mean=0, sd=1)
z <- runif(100,min=-1,max=1)
y <- 1*x + 2*z + rnorm(100,mean=0, sd=1)
## fit a linear model with no intercept but with one predictor
mod <- lm(y ~ 0 + x)
## compute confidence bands (i.e., fitted values +/- 1.96 standard errors of fitted values)
conf.band.x <- predict(mod,newdata=data.frame(x = seq(from=ceiling(min(x)),to=floor(max(x)),by=0.01)),
                           interval="confidence")
## display confidence bands
conf.band.x <- data.frame(lwr=conf.band.x[,"lwr"],
                              fit=conf.band.x[,"fit"],
                              upr=conf.band.x[,"upr"])
matplot(x=seq(from=ceiling(min(x)),to=floor(max(x)),by=0.01), y=conf.band.x, type="l", xlab="x", ylab="y")
abline(v=mean(x),lty=3,col="magenta")
title("Effect of x on y")
 lm(y ~ 0 + x)
 lm(y ~ x -1)
mod <- lm(y ~ 0 + x + z)
conf.band.x <- predict(mod,newdata=data.frame(x = seq(from=ceiling(min(x)),to=floor(max(x)),by=0.01),
                                                  z = mean(z)),
                           interval="confidence")
conf.band.x <- data.frame(lwr=conf.band.x[,"lwr"],
                              fit=conf.band.x[,"fit"],
                              upr=conf.band.x[,"upr"])
matplot(x=seq(from=ceiling(min(x)),to=floor(max(x)),by=0.01), y=conf.band.x, type="l", xlab="x", ylab="y")
abline(v=mean(x),lty=3,col="magenta")
title("Partial Effect of x on y (obtained by setting z to its average level)")
mod <- lm(y ~ 0 + x + z)
predict(mod, interval="confidence")
mod <- lm(y ~ 0 + x + z)
mod
head(predict(mod, interval="confidence"))
mod2 <- lm(y ~ x + z)
mod2
head(predict(mod2, interval="confidence"))
xx <- c("D1W12001",
"D1W12002",
"D1W22001",
"D1W22002",
"D2W12001",
"D2W12002")
order(gsub('.*W','',xx))
xx[order(gsub('.*W','',xx))]
example = structure(list(set = structure(c(2L, 2L, 7L, 11L, 11L, 2L, 2L, 
6L, 11L, 12L), .Names = c("87", "89", "90", "91", "92", "93", 
"563", "564", "565", "95"), .Label = c("A/C", "A/G", "A/T", "C/A", 
"C/G", "C/T", "G/A", "G/C", "G/T", "T/A", "T/C", "T/G"), class = "factor"), 
    line1 = c("G", "G", "A", "C", "C", "A", "A", "T", "C", "G"
    ), line2 = c("A", "A", "G", "T", "T", "G", "G", "C", "T", 
    "A")), .Names = c("set", "line1", "line2"), row.names = c(5L, 
7L, 8L, 9L, 10L, 11L, 13L, 14L, 15L, 16L), class = "data.frame")
example
with(example, grep, line1, set)
grep
grep(example$line1, example$set)
?grep
sapply(example$line1, grep, example$set)
sapply(1:dim(example)[1], function(i) grep(example$line1[i], example$set[i]))
sapply(L, function(i) grep(example$line2[i], example$set[i]))
L <- 1:dim(example)[1]
sapply(L, function(i) grep(example$line1[i], example$set[i]))
sapply(L, function(i) grep(example$line2[i], example$set[i]))
?grep
sapply(L, function(i) grep(example$line2[i], example$set[i])==1)
sapply(L, function(i) grep(paste0(example$line1[i], example$line2[i]), example$set[i]))
paste0(example$line1[i], example$line2[i])
i <- 1
paste0(example$line1[i], example$line2[i])
sapply(L, function(i) grep(paste0("[", example$line1[i], example$line2[i], "]"), example$set[i]))
gsub(example$set, "/", "")
example
gsub(example$set, "//", "")
gsub("/", example$set, "")
gsub("//", example$set, "")
gsub("///", example$set, "")
gsub("////", example$set, "")
gsub("/", example$set, "", fixed=TRUE)
gsub("/", "", example$set, fixed=TRUE)
search()
ls(3)
ls(3)
stringin
?stringin
sapply(L, function(i) grep(example$line2[i], example$set[i], value=TRUE))
sapply(L, function(i) grep(example$line2[i], example$set[i]))
sapply(L, function(i) length(grep(example$line2[i], example$set[i])))
example = structure(list(set = structure(c(2L, 2L, 7L, 11L, 11L, 2L, 2L, 
6L, 11L, 12L), .Names = c("87", "89", "90", "91", "92", "93", 
"563", "564", "565", "95"), .Label = c("A/C", "A/G", "A/T", "C/A", 
"C/G", "C/T", "G/A", "G/C", "G/T", "T/A", "T/C", "T/G"), class = "factor"), 
    line1 = c("G", "G", "A", "C", "C", "A", "A", "T", "C", "G"
    ), line2 = c("A", "A", "G", "T", "T", "G", "G", "C", "T", 
    "A")), .Names = c("set", "line1", "line2"), row.names = c(5L, 
7L, 8L, 9L, 10L, 11L, 13L, 14L, 15L, 16L), class = "data.frame")
L <- 1:dim(example)[1]
in1 <- sapply(L, function(i) length(grep(example$line1[i], example$set[i])))
in2 <- sapply(L, function(i) length(grep(example$line2[i], example$set[i])))
example$check <- in1 & in2
example
cleanup()
q()
?strftime
a <- c("D4W72002", "D2W32009", "D5w372001", "D2w152003")
strftime(a, format = "D%uW%U%Y")
?character
nchar(a)
library(lubridate)
?lubridate
a <- c("D4W72002", "D2W32009", "D5w372001", "D2w152003")
nc <- nchar(a)
year <- substring(a, nc-3, nc)
dw <- strsplit(substring(a, 2, nc-4), "W")
nc
year
dw
?strsplit
nc <- nchar(a)
year <- substring(a, nc-3, nc)
dw <- strsplit(substring(a, 2, nc-4), "W")
day <- sapply(dw, "[", 1)
week <- sapply(dw, "[", 2)
ord <- order(year, week, day)
a[ord]
a <- c("D4W72002", "D2W32009", "D5W372001", "D2W152003")
nc <- nchar(a)
year <- substring(a, nc-3, nc)
dw <- strsplit(substring(a, 2, nc-4), "W")
day <- sapply(dw, "[", 1)
week <- sapply(dw, "[", 2)
ord <- order(year, week, day)
a[ord]
cleanup()
q()
.First
?.First
getOption("repos")
?options
?mirror
??mirror
?options
options("chmhelp")
options("prompt")
options("continue")
jvaFirst <- function() {
# set CRAN mirror
repo <- getOption("repos")
repo["CRAN"] <- "http://streaming.stat.iastate.edu/CRAN/"
options(repos=repo)
# prefer Compiled HTML help
options(chmhelp=FALSE)
# prefer long decimals rather than scientific notation
options(scipen=10)
# prefer characters rather than factors
options(stringsAsFactors=FALSE)
# don't print more than 100 rows
options(max.print=100)
# make it more obvious when line of code is continued on the next line
# from Tony Fischetti, http://www.onthelambda.com/2014/09/17/fun-with-rprofile-and-customizing-r-startup/
options(continue="... ")
# get rid of any "saved" plots, e.g., from past runs of dfplot()
.SavedPlots <- NULL
# attach packages
auto.loads <-c("rJava", "XLConnect", "maps", "mapproj", "RColorBrewer", "mgcv", "jvamisc")
sshhh <- function(a.package) suppressWarnings(suppressPackageStartupMessages(library(a.package, character.only=TRUE)))
sapply(auto.loads, sshhh))
# my personal functions
already <- ls(".GlobalEnv")
print(already)
}
#' Startup
#'
#' One function with all the commands I typically want run at the start of an R session.
#' @return A plot is sent to the current graphics device (no value is returned).
#' @export
#' @examples 
#' save as .First() function and run
#' .First <- jvaFirst
#' .First()
jvaFirst <- function() {
# set CRAN mirror
repo <- getOption("repos")
repo["CRAN"] <- "http://streaming.stat.iastate.edu/CRAN/"
options(repos=repo)
# prefer Compiled HTML help
options(chmhelp=FALSE)
# prefer long decimals rather than scientific notation
options(scipen=10)
# prefer characters rather than factors
options(stringsAsFactors=FALSE)
# don't print more than 100 rows
options(max.print=100)
# make it more obvious when line of code is continued on the next line
# from Tony Fischetti, http://www.onthelambda.com/2014/09/17/fun-with-rprofile-and-customizing-r-startup/
options(continue="... ")
# get rid of any "saved" plots, e.g., from past runs of dfplot()
.SavedPlots <- NULL
# attach packages
auto.loads <-c("rJava", "XLConnect", "maps", "mapproj", "RColorBrewer", "mgcv", "jvamisc")
sshhh <- function(a.package) suppressWarnings(suppressPackageStartupMessages(library(a.package, character.only=TRUE)))
sapply(auto.loads, sshhh)
# my personal functions
already <- ls(".GlobalEnv")
print(already)
}
jvaFirst()
.First <- jvaFirst
q
q()
library(devtools)
library(roxygen2)
setwd("C:/JVA/GitHub")
install("jvamisc")
setwd("C:/JVA/R/Working Directory")
library(jvamisc)
ls()
rm(already)
rm(jvaFirst)
ls()
.First
q()
search()
?jvaFirst
ls()
?ls
#' Startup
#'
#' One function with all the commands I typically want run at the start of an R session.
#' @param maxp Scalar integer, limit lines of information printed, default 100.
#' @param ndecScalar integer, maximum width of fixed notation before switching to scientific notation, default 10. 
#' @param contScalar string, prompt used for lines which continue past first command line, default \code{"... "}.
#' @param pkgsVector of strings, packages to be loaded, default
#'\code{c("rJava", "XLConnect", "maps", "mapproj", "RColorBrewer", "mgcv", "jvamisc")}.
#' @param mirrorScalar string, CRAN mirror, default \code{"http://streaming.stat.iastate.edu/CRAN/"}.
#' @param helptScalar string, type of help, default "html".
#' @param facScalar logical, use factors rather than character strings, default FALSE.
#' @param noplotsScalar logical, remove "saved" plots, e.g., from past runs of \code{\link[jvamisc]{dfplot}}, default TRUE.
#' @param showScalar logical, list objects in current environment, default TRUE.
#' @return
#' @export
#' @seealso\code{\link{options}}, \code{\link{help}}.
#' @examples 
#' # after installing/updating R
#' # save as .First() function and run
#' .First <- jvaFirst
#' .First()
jvaFirst <- function(
maxp=100, ndec=10, cont="... ",
pkgs = c("rJava", "XLConnect", "maps", "mapproj", "RColorBrewer", "mgcv", "jvamisc"),
mirror="http://streaming.stat.iastate.edu/CRAN/", 
helpt="html", fac=FALSE, noplots=TRUE, show=TRUE) {
# don't print more than 100 rows
options(max.print=maxp)
# prefer long decimals rather than scientific notation
options(scipen=ndec)
# make it more obvious when line of code is continued on the next line
# from Tony Fischetti, http://www.onthelambda.com/2014/09/17/fun-with-rprofile-and-customizing-r-startup/
options(continue=cont)
# attach packages
sshhh <- function(a.package) suppressWarnings(suppressPackageStartupMessages(library(a.package, character.only=TRUE)))
sapply(pkgs, sshhh)
# set CRAN mirror
repo <- getOption("repos")
repo["CRAN"] <- mirror
options(repos=repo)
# prefer compiled HTML help
options(help_type=helpt)
# prefer characters rather than factors
options(stringsAsFactors=fac)
# get rid of any "saved" plots, e.g., from past runs of dfplot()
if(noplots) .SavedPlots <- NULL
# my personal functions
if(show) {
already <- ls(".GlobalEnv")
print(already)
}
}
jvaFirst()
.First <- jvaFirst
cleanup()
q()
library(devtools)
library(roxygen2)
setwd("C:/JVA/GitHub")
install("jvamisc")
setwd("C:/JVA/R/Working Directory")
library(jvamisc)
?jvaFirst
library(devtools)
setwd("C:/JVA/GitHub/jvamisc")
document()
q()
