dimnames(m)[[2]] <- varnames
# right side of the formula
rightside <- apply(m, 1, function(row) paste(varnames[row==1], collapse=" + "))
# if no predictors, use 1 to represent intercept only model
rightside[rightside==""] <- "1"
form <- paste("amphibi ~", rightside)
fits <- lapply(form, function(f) lm(formula(f), dat=mydat))
# AIC table
aictab <- AICc(fits)
bigtab <- cbind(formula=rightside[aictab$model], aictab)
nmodzfit <- dim(bigtab)[1]
# top models
topmods <- bigtab[bigtab$daicc < 2, ]
# add coefficients to top model
coef <- lapply(fits[topmods$model], coef)
xmod <- unique(unlist(sapply(coef, names)))
topcoef <- t(sapply(coef, function(x) 
{
blank <- rep(0, length(xmod))
blank[match(names(x), xmod)] <- x
blank
}))
dimnames(topcoef)[[2]] <- xmod
topcoef
?round
signif(topcoef, 3)
topmods
signif(topmods, 3)
signif(topmods[, -1], 3)
topmods <- cbind(signif(topcoef, 3), round(topmods[, c("n", "p", "rmse", "aicc", "daicc", "aiccw")], 2))
topmods
select.varz <- function(varnames, mydat, max.no.ind.var) {
# keep only those varnames that have at least two unique non-missing values
varnames <- varnames[apply(mydat[, varnames], 2, function(x) {
y <- var(x[!is.na(x)])
!is.na(y) & y>0
})]
m <- allcombs(length(varnames), 0, max.no.ind.var)
dimnames(m)[[2]] <- varnames
# right side of the formula
rightside <- apply(m, 1, function(row) paste(varnames[row==1], collapse=" + "))
# if no predictors, use 1 to represent intercept only model
rightside[rightside==""] <- "1"
form <- paste("amphibi ~", rightside)
fits <- lapply(form, function(f) lm(formula(f), dat=mydat))
# AIC table
aictab <- AICc(fits)
bigtab <- cbind(formula=rightside[aictab$model], aictab)
nmodzfit <- dim(bigtab)[1]
# top models
topmods <- bigtab[bigtab$daicc < 2, ]
# add coefficients to top model
coef <- lapply(fits[topmods$model], coef)
xmod <- unique(unlist(sapply(coef, names)))
topcoef <- t(sapply(coef, function(x) 
{
blank <- rep(0, length(xmod))
blank[match(names(x), xmod)] <- x
blank
}))
dimnames(topcoef)[[2]] <- xmod
topmods <- cbind(signif(topcoef, 3), round(topmods[, c("n", "p", "rmse", "aicc", "daicc", "aiccw")], 2))
# single best model
bestnum <- bigtab$model[1]
bestfit <- fits[[bestnum]]
xvarz <- varnames[m[bestnum, ]==1]
# output
out <- list(xvarz=xvarz, nmodzfit=nmodzfit, bestfit=bestfit, topmods=topmods, allfits=fits, allmods=bigtab, allpreds=m)
print(out[1:4])
out
}
cleanup()
search()
detach()
# C:\JVA\Consult\Stapanian\Amphib\Next Subm 2\Three Group Approach 2.r
# which environmental variables best predict this index of amphibian biotic integrity
# relevant emails:
# 15 May 2013 - https://mail.google.com/mail/u/0/?shva=1#search/amphibian/13ea801401e50a84
#  8 Aug 2013 - https://mail.google.com/mail/u/1/?shva=1#inbox/1405defbc5969b40
# 27 Aug 2013 - https://mail.google.com/mail/u/1/?shva=1#inbox/140c042c5ba851fc
# bring in data and create initial figures
source("C:/JVA/Consult/Stapanian/Amphib/Next Subm 2/Explore Figs 2.r")
select.varz <- function(varnames, mydat, max.no.ind.var) {
# keep only those varnames that have at least two unique non-missing values
varnames <- varnames[apply(mydat[, varnames], 2, function(x) {
y <- var(x[!is.na(x)])
!is.na(y) & y>0
})]
m <- allcombs(length(varnames), 0, max.no.ind.var)
dimnames(m)[[2]] <- varnames
# right side of the formula
rightside <- apply(m, 1, function(row) paste(varnames[row==1], collapse=" + "))
# if no predictors, use 1 to represent intercept only model
rightside[rightside==""] <- "1"
form <- paste("amphibi ~", rightside)
fits <- lapply(form, function(f) lm(formula(f), dat=mydat))
# AIC table
aictab <- AICc(fits)
bigtab <- cbind(formula=rightside[aictab$model], aictab)
nmodzfit <- dim(bigtab)[1]
# top models
topmods <- bigtab[bigtab$daicc < 2, ]
# add coefficients to top model
coef <- lapply(fits[topmods$model], coef)
xmod <- unique(unlist(sapply(coef, names)))
topcoef <- t(sapply(coef, function(x) 
{
blank <- rep(0, length(xmod))
blank[match(names(x), xmod)] <- x
blank
}))
dimnames(topcoef)[[2]] <- xmod
topmods <- cbind(signif(topcoef, 3), round(topmods[, c("n", "p", "rmse", "aicc", "daicc", "aiccw")], 2))
# single best model
bestnum <- bigtab$model[1]
bestfit <- fits[[bestnum]]
xvarz <- varnames[m[bestnum, ]==1]
# output
out <- list(xvarz=xvarz, nmodzfit=nmodzfit, bestfit=bestfit, topmods=topmods, allfits=fits, allmods=bigtab, allpreds=m)
print(out[1:4])
out
}
# assign each observation to one of three groups
# ensure even distribution of groups across vegetation classes and latitudes
dat3 <- dat2[order(dat2$veg.class, dat2$lat.dd), ]
dat3$group <- rep(1:3, length.out=dim(dat2)[1])
df <- dat3
attach(df)
suv <- sort(unique(veg.class))
windows(h=6.5, w=6.5)
map("state", mar=c(1, 1, 1, 1), region= "ohio", col="darkgray", lwd=2)
for(i in seq(suv)) {
sel <- veg.class==suv[i]
points(lon.dd[sel], lat.dd[sel], cex=2, lwd=2, pch=c(2, 1)[i], col=group[sel]+1)
}
#legend("bottomright", capwords(suv), pch=c(2, 1), col=c("black", "gray"), pt.lwd=2, pt.cex=2, cex=1.15, title="Veg. Class")
par(usr=c(-126, 94, 21, 193), xpd=NA)
polygon(c(-128, -128, -64, -64, -128), c(22, 52, 52, 22, 22), col="white", lwd=2)
map("state", add=T, mar=c(0, 0, 0, 0)) 
map("state", region="ohio", fill=T, add=T) 
detach(df)
# step 1, select variables
# limit the number of variables in each model, such that no more than n/10 coefficients are estimated, following Burnham and Anderson (2002)
maxxvar <- round(dim(df)[1]/3/10)
ga <- select.varz(varnames=varz1, mydat=df[df$group==1, ], max.no.ind.var=maxxvar)
gb <- select.varz(varnames=varz1, mydat=df[df$group==2, ], max.no.ind.var=maxxvar)
gc <- select.varz(varnames=varz1, mydat=df[df$group==3, ], max.no.ind.var=maxxvar)
ct
attach(dat2)
ct <- t(
sapply(varz1, function(x) {
ct <- cor.test(dat2[, x], amphibi)
ctp <- ct$p.value
ctr <- as.vector(ct$estimate)
c(p=ctp, r=ctr)
})
)
detach(dat2)
ct
ct[order(ct$r), ]
ct[order(ct[, "r"]), ]
ct[rev(order(ct[, "r"])), ]
round(ct[rev(order(ct[, "r"])), ], 2)
varnames=varz1; mydat=df[df$group==3, ]; max.no.ind.var=maxxvar;
# keep only those varnames that have at least two unique non-missing values
varnames <- varnames[apply(mydat[, varnames], 2, function(x) {
y <- var(x[!is.na(x)])
!is.na(y) & y>0
})]
m <- allcombs(length(varnames), 0, max.no.ind.var)
dimnames(m)[[2]] <- varnames
# right side of the formula
rightside <- apply(m, 1, function(row) paste(varnames[row==1], collapse=" + "))
# if no predictors, use 1 to represent intercept only model
rightside[rightside==""] <- "1"
form <- paste("amphibi ~", rightside)
fits <- lapply(form, function(f) lm(formula(f), dat=mydat))
# AIC table
aictab <- AICc(fits)
bigtab <- cbind(formula=rightside[aictab$model], aictab)
nmodzfit <- dim(bigtab)[1]
# top models
topmods <- bigtab[bigtab$daicc < 2, ]
# add coefficients to top model
coef <- lapply(fits[topmods$model], coef)
xmod <- unique(unlist(sapply(coef, names)))
topcoef <- t(sapply(coef, function(x) 
{
blank <- rep(0, length(xmod))
blank[match(names(x), xmod)] <- x
blank
}))
dimnames(topcoef)[[2]] <- xmod
topcoef
coef
xmod
xmod <- unique(unlist(lapply(coef, names)))
xmod
# keep only those varnames that have at least two unique non-missing values
varnames <- varnames[apply(mydat[, varnames], 2, function(x) {
y <- var(x[!is.na(x)])
!is.na(y) & y>0
})]
m <- allcombs(length(varnames), 0, max.no.ind.var)
dimnames(m)[[2]] <- varnames
# right side of the formula
rightside <- apply(m, 1, function(row) paste(varnames[row==1], collapse=" + "))
# if no predictors, use 1 to represent intercept only model
rightside[rightside==""] <- "1"
form <- paste("amphibi ~", rightside)
fits <- lapply(form, function(f) lm(formula(f), dat=mydat))
# AIC table
aictab <- AICc(fits)
bigtab <- cbind(formula=rightside[aictab$model], aictab)
nmodzfit <- dim(bigtab)[1]
# top models
topmods <- bigtab[bigtab$daicc < 2, ]
# add coefficients to top model
coef <- lapply(fits[topmods$model], coef)
xmod <- unique(unlist(lapply(coef, names)))
topcoef <- t(sapply(coef, function(x) 
{
blank <- rep(0, length(xmod))
blank[match(names(x), xmod)] <- x
blank
}))
dimnames(topcoef)[[2]] <- xmod
topmods <- cbind(signif(topcoef, 3), round(topmods[, c("n", "p", "rmse", "aicc", "daicc", "aiccw")], 2))
# single best model
bestnum <- bigtab$model[1]
bestfit <- fits[[bestnum]]
xvarz <- varnames[m[bestnum, ]==1]
# output
out <- list(xvarz=xvarz, nmodzfit=nmodzfit, bestfit=bestfit, topmods=topmods, allfits=fits, allmods=bigtab, allpreds=m)
print(out[1:4])
names(ga)
ga$allfits[1:5]
ga$allmods[1:5]
ga$bestfit
freshfita <- lm(ga$bestfit, dat=df[df$group==2, ])
freshfita
summary(freshfita)
freshfita <- lm(ga$bestfit, dat=df[df$group==2, ])
freshfitb <- lm(gb$bestfit, dat=df[df$group==3, ])
freshfitc <- lm(gc$bestfit, dat=df[df$group==1, ])
summary(freshfita)
summary(freshfitb)
summary(freshfitc)
mtco
mtcars
fit <- lm(mgp ~ cyl + disp, data=mtcars)
fit <- lm(mpg ~ cyl + disp, data=mtcars)
calcr2(fit$fitted, mtcars$mpg, 3)
#' Coefficient of determination
#'
#' Calculate the unadjusted and adjusted coefficient of determination (R^2).
#' @param fitted a vector, fitted values
#' @param observed a vector, observed values
#' @param nparam a scalar, number of parameters in the fitted model
#' @return vector, unadjusted and adjusted coefficients of determination 
#' @export
#' @examples 
#' fit1 <- lm(mpg ~ cyl + disp, data=mtcars)
#' calcr2(fit1$fitted, mtcars$mpg, 3)
#' fit2 <- lm(mpg ~ cyl + disp + wt, data=mtcars)
#' calcr2(fit2$fitted, mtcars$mpg, 4)
calcr2 <- function(fitted, observed, nparam) {
    # calculate the R^2 and the adjusted R^2
    # from the fitted values, the observed values, and the number of parameters
    # formulas from Weisberg 1985 Applied Linear Regression
    resid <- observed - fitted
    r2 <- 1 - sum(resid^2)/ss(observed)
    adjr2 <- 1 - (length(observed) - 1)/(length(observed) - nparam)*(1 - r2)
    c(r2, adjr2)
    }
calcr2(fit1$fitted, mtcars$mpg, 3)
fit1 <- lm(mpg ~ cyl + disp, data=mtcars)
calcr2(fit1$fitted, mtcars$mpg, 3)
ss
#' Coefficient of determination
#'
#' Calculate the unadjusted and adjusted coefficient of determination (R^2).
#' @param fitted a vector, fitted values
#' @param observed a vector, observed values
#' @param nparam a scalar, number of parameters in the fitted model
#' @return vector, unadjusted and adjusted coefficients of determination 
#' @export
#' @examples 
#' fit1 <- lm(mpg ~ cyl + disp, data=mtcars)
#' calcr2(fit1$fitted, mtcars$mpg, 3)
#' fit2 <- lm(mpg ~ cyl + disp + wt, data=mtcars)
#' calcr2(fit2$fitted, mtcars$mpg, 4)
calcr2 <- function(fitted, observed, nparam) {
    # calculate the R^2 and the adjusted R^2
    # from the fitted values, the observed values, and the number of parameters
    # formulas from Weisberg 1985 Applied Linear Regression
    resid <- observed - fitted
ss <- function(x) sum((x - mean(x))^2)
    r2 <- 1 - sum(resid^2)/ss(observed)
    adjr2 <- 1 - (length(observed) - 1)/(length(observed) - nparam)*(1 - r2)
    c(r2, adjr2)
    }
fit1 <- lm(mpg ~ cyl + disp, data=mtcars)
calcr2(fit1$fitted, mtcars$mpg, 3)
fit2 <- lm(mpg ~ cyl + disp + wt, data=mtcars)
calcr2(fit2$fitted, mtcars$mpg, 4)
summary(fit1)
names(summary(fit1))
assess.fit <- function(fit, newd) {
p <- predict(fit, newdata=newd)
y <- newd$amphibi
r <- p - y
rmse <- sqrt(mean(r^2))
r2 <- calcr2(fitted=p, observed=y, nparam=length(labels(terms(freshfita)))+1)
list(cbind(p=p, y=y, r=r), rmse=rmse, r2=r2)
}
# step 3, assess fit
resa <- assess.fit(fit=freshfita, newd=df[df$group==3, ])
resb <- assess.fit(fit=freshfitb, newd=df[df$group==1, ])
resc <- assess.fit(fit=freshfitc, newd=df[df$group==2, ])
resa[-1]
resb[-1]
resc[-1]
?addedvar
addedvar(Y=mtcars$hp, X=mtcars[, c("mpg", "disp", "wt")], main="Predicting horsepower from MPG, displacement, and weight")
#' Added variable plots of predictors
#'
#' Produces an added variable plot given 1 response and 2 or more predictors.
#' @param Y a vector representing a single response
#' @param X two or more predictor columns in a matrix or dataframe
#' @param main subtitle for the plot
#' @return a plot is sent to the current graphics device (no value is returned)
#' @export
#' @examples addedvar(Y=mtcars$hp, X=mtcars[, c("mpg", "disp", "wt")], main="Predicting horsepower from MPG, displacement, and weight")
addedvar <- function(Y, X, main="") {
# Added variable plots of predictors
# Y is one response vector
# X is two or more predictor columns in a matrix or dataframe
# main is a subtitle for the plot
# calculate the number of predictors, and assign them names
p <- ncol(X)
if(p < 2) cat("There must be at least two predictors to construct added variable plots. \n")
if(is.null(dimnames(X)[[2]])) pnames <- paste("X", 1:p, sep="") else pnames <- dimnames(X)[[2]]
if(any(is.na(X))) cat("Observations with missing values will be excluded from procedure. \n")
# develop the full model with all predictors included
fullmodel <- "Y ~ X[, 1]"
if(p > 1) {
for(i in 2:p) fullmodel <- paste(fullmodel, " + X[, ", i, "]", sep="")
}
# fit the full model with each of the predictors excluded in turn
plotcols <- ceiling(sqrt(p - 1))
plotrows <- ceiling(p/plotcols)
par(mar = c(2.5, 2.5, 3, 2.5), mfrow = c(plotrows, plotcols), oma = c(3, 3, 5, 0), pty="s")
for(i in 1:p) {
noxk <- paste("~ . - X[, ", i, "]", sep="")
xkfory <- paste("X[, ", i, "] ~ .", sep="")
modelnoxk <- update(formula(fullmodel), noxk)
modelxkfory <- update(modelnoxk, xkfory)
resy <- residuals(lm(modelnoxk, na.action=na.omit))
resxk <- residuals(lm(modelxkfory, na.action=na.omit))
plot(resxk, resy, main=pnames[i], xlab="", ylab="", xaxt="n", yaxt="n")
abline(lsfit(resxk, resy))
}
mtext("Variability in the predictor not explained by other predictors", side=1, outer=T, line=1, cex=1)
mtext("Variability in the response not explained by other predictors", side=2, outer=T, line=1, cex=1, las=0)
mtext("Added variable plots for predictors", side=3, outer=T, line=3, cex=1.5)
mtext(main, side=3, outer=T, line=1.5, cex=1)
}
addedvar(Y=mtcars$hp, X=mtcars[, c("mpg", "disp", "wt")], main="Predicting horsepower from MPG, displacement, and weight")
> 
addedvar(Y=df$amphibi[df$group==1], X=df[, c("metric4", "metric6")], main="Predicting amphIBI")
addedvar(Y=df$amphibi[df$group==1], X=df[df$group==1, c("metric4", "metric6")], main="Predicting amphIBI")
df[df$group==1, c("metric4"windows()
with(df[df$group==1, ], {
plot(metric4, metric6, type="n")
symbols(metric4, metric6, circles=amphibi)
})
windows()
with(df[df$group==1, ], {
plot(metric4, metric6, type="n")
symbols(metric4, metric6, circles=amphibi)
})
with(df[df$group==1, ], {
plot(metric4, metric6, type="n")
symbols(metric4, metric6, circles=amphibi, inches=0.4)
})
windows()
with(df[df$group==1, ], {
plot(metric4, amphibi)
lines(lsfit(metric4, amphibi))
#symbols(metric4, metric6, circles=amphibi, inches=0.4)
})
with(df[df$group==1, ], {
plot(metric4, amphibi)
abline(lsfit(metric4, amphibi))
#symbols(metric4, metric6, circles=amphibi, inches=0.4)
})
with(df[df$group==1, ], {
plot(metric4, amphibi)
abline(lsfit(metric4, amphibi))
symbols(metric4, amphibi, circles=metric6, inches=0.4)
})
with(df[df$group==1, ], {
plot(metric4, amphibi)
abline(lsfit(metric4, amphibi))
symbols(metric4, amphibi, circles=metric6, inches=0.4, add=TRUE)
})
with(df[df$group==1, ], {
fit1 <- lm(amphibi ~ metric4)
symbols(metric4, amphibi, circles=metric6, inches=0.4, las=1)
points(metric4, amphibi)
arrows(metric4, fit1$fitted, metric4, amphibi)
abline(lsfit(metric4, amphibi))
})
args(arrows)
with(df[df$group==1, ], {
fit1 <- lm(amphibi ~ metric4)
symbols(metric4, amphibi, circles=metric6, inches=0.4, las=1)
arrows(metric4, fit1$fitted, metric4, amphibi, length=0.1)
abline(lsfit(metric4, amphibi))
})
par(mar=c(4, 4, 1, 1))
with(df[df$group==1, ], {
fit1 <- lm(amphibi ~ metric4)
symbols(metric4, amphibi, circles=metric6, inches=0.4, las=1)
arrows(metric4, fit1$fitted, metric4, amphibi, length=0.1)
abline(lsfit(metric4, amphibi))
})
windows()
par(mar=c(4, 4, 1, 1))
with(df[df$group==1, ], {
fit1 <- lm(amphibi ~ metric4)
symbols(metric4, amphibi, circles=metric6, inches=0.4, las=1)
arrows(metric4, fit1$fitted, metric4, amphibi, length=0.1, lwd=abs(fit1$fitted-amphibi))
abline(lsfit(metric4, amphibi))
})
par(mar=c(4, 4, 1, 1))
with(df[df$group==1, ], {
fit1 <- lm(amphibi ~ metric4)
symbols(metric4, amphibi, circles=metric6, inches=0.4, las=1)
arrows(metric4, fit1$fitted, metric4, amphibi, length=0.1, lwd=abs(fit1$fitted-amphibi)/10, lend="square")
abline(lsfit(metric4, amphibi))
})
par(mar=c(4, 4, 1, 1))
with(df[df$group==1, ], {
fit1 <- lm(amphibi ~ metric4)
symbols(metric4, amphibi, circles=metric6, inches=0.4, las=1)
arrows(metric4, fit1$fitted, metric4, amphibi, length=0.1, lwd=abs(fit1$fitted-amphibi)/5, lend="square")
abline(lsfit(metric4, amphibi))
})
windows()
plot(sort(fit1$resid))
fit1
par(mar=c(4, 4, 1, 1))
with(df[df$group==1, ], {
fit1 <<- lm(amphibi ~ metric4)
symbols(metric4, amphibi, circles=metric6, inches=0.4, las=1)
arrows(metric4, fit1$fitted, metric4, amphibi, length=0.1, lwd=abs(fit1$fitted-amphibi)/5, lend="square")
abline(lsfit(metric4, amphibi))
})
plot(sort(fit1$resid))
plot(sort(abs(fit1$resid)))
locator()
windows()
par(mar=c(4, 4, 1, 1))
with(df[df$group==1, ], {
fit1 <<- lm(amphibi ~ metric4)
symbols(metric4, amphibi, circles=metric6, inches=0.4, las=1)
sel <- abs(fit1$fitted-amphibi) > 18
arrows(metric4[sel], fit1$fitted[sel], metric4[sel], amphibi[sel], length=0.1, lwd=abs(fit1$fitted-amphibi)[sel]/5, lend="square")
abline(lsfit(metric4, amphibi))
})
windows()
par(mar=c(4, 4, 1, 1))
with(df[df$group==1, ], {
fit1 <<- lm(amphibi ~ metric4)
symbols(metric4, amphibi, circles=sqrt(metric6), inches=0.4, las=1)
sel <- abs(fit1$fitted-amphibi) > 18
arrows(metric4[sel], fit1$fitted[sel], metric4[sel], amphibi[sel], length=0.1, lwd=abs(fit1$fitted-amphibi)[sel]/5, lend="square")
abline(lsfit(metric4, amphibi))
})
head(df[df$group==1, ])
head(df[df$group==1, ])
windows()
par(mar=c(4, 4, 1, 1))
with(df[df$group==1, ], {
fit1 <<- lm(amphibi ~ metric4)
symbols(metric4, amphibi, circles=sqrt(metric6), inches=0.4, las=1)
sel <- abs(fit1$fitted-amphibi) > 18
arrows(metric4[sel], fit1$fitted[sel], metric4[sel], amphibi[sel], length=0.1, lwd=abs(fit1$fitted-amphibi)[sel]/5, lend="square")
abline(lsfit(metric4, amphibi))
identify(metric4, amphibi, site.code)
})
windows()
par(mar=c(4, 4, 1, 1))
with(df[df$group==1, ], {
fit1 <<- lm(amphibi ~ metric4)
symbols(metric4, amphibi, circles=sqrt(metric6), inches=0.4, las=1)
sel <- abs(fit1$fitted-amphibi) > 18
arrows(metric4[sel], fit1$fitted[sel], metric4[sel], amphibi[sel], length=0.1, lwd=abs(fit1$fitted-amphibi)[sel]/5, lend="square")
abline(lsfit(metric4, amphibi))
identify(metric4, amphibi, site.code)
})
cleanup()
graphics.off()
#########
# Make any changes you like
# update documentation, then quit and restart R
library(devtools)
setwd("C:/JVA/GitHub/jvamisc")
document()
quit("yes")
