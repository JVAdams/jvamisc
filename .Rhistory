?boxplot.stats
sort(outties$length.mm)[1:10]
head(outties)
sort(outties$mm.length)[1:10]
quartile
quantile
# read in the data
outties <- read.csv("C:/JVA/Consult/Tucker/outties.csv")
# create a copy of the Diet.Item column, making it a factor, ordered by the median length (for plotting)
medianlength <- tapply(outties$mm.length, outties$Diet.Item, median, na.rm=TRUE)
outties$Diet.Item.factor <- factor(outties$Diet.Item, levels=names(sort(medianlength)))
# boxplots of all the diet item sizes
windows(h=9, w=6.5)
par(mar=c(4, 12, 1, 1), cex=0.6)
a <- boxplot(mm.length ~ Diet.Item.factor, data=outties, horizontal=TRUE, las=1, xlab="Length  (mm)", ylab="", main="")
# add median length to data frame
index <- tapply(outties$mm.length, outties$Diet.Item)
outties$medianlen <- medianlength[index]
# outlier measure: the number of interquartile ranges beyond the lower and upper quartiles
q1 <- tapply(outties$mm.length, outties$Diet.Item, quantile, 0.25, na.rm=TRUE)[index]
q3 <- tapply(outties$mm.length, outties$Diet.Item, quantile, 0.75, na.rm=TRUE)[index]
iqr <- q3 - q1
outties$outmeas <- 0
outties$outmeas[outties$mm.length < q1] <- (outties$mm.length - q1)/iqr
outties$outmeas[outties$mm.length > q3] <- (outties$mm.length - q3)/iqr
# sort the data by the iqrsfrommedian (in absolute value) to look at potential outliers
outord <- outties[order(-abs(outties$outmeas), outties$medianlen, outties$mm.length), ]
outord[abs(outord$outmeas) > 1.5, ]
summary(q1)
outties[is.na(q1), ][1:10, ]
attach(outties)
summary(mm.length[Diet.Item=="Bythotrephes"])
# read in the data
outties <- read.csv("C:/JVA/Consult/Tucker/outties.csv")
# create a copy of the Diet.Item column, making it a factor, ordered by the median length (for plotting)
medianlength <- tapply(outties$mm.length, outties$Diet.Item, median, na.rm=TRUE)
outties$Diet.Item.factor <- factor(outties$Diet.Item, levels=names(sort(medianlength)))
# boxplots of all the diet item sizes
windows(h=9, w=6.5)
par(mar=c(4, 12, 1, 1), cex=0.6)
a <- boxplot(mm.length ~ Diet.Item.factor, data=outties, horizontal=TRUE, las=1, xlab="Length  (mm)", ylab="", main="")
# add median length to data frame
index <- tapply(outties$mm.length, outties$Diet.Item)
outties$medianlen <- medianlength[index]
# outlier measure: the number of interquartile ranges beyond the lower and upper quartiles
q1 <- tapply(outties$mm.length, outties$Diet.Item, quantile, 0.25, na.rm=TRUE)[index]
q3 <- tapply(outties$mm.length, outties$Diet.Item, quantile, 0.75, na.rm=TRUE)[index]
iqr <- q3 - q1
outties$outmeas <- ifelse(is.na(iqr), NA, 0)
outties$outmeas[!is.na(outties$mm.length) & outties$mm.length < q1] <- ((outties$mm.length - q1)/iqr)[outties$mm.length < q1]
outties$outmeas[!is.na(outties$mm.length) & outties$mm.length > q3] <- ((outties$mm.length - q3)/iqr)[outties$mm.length > q3]
# read in the data
outties <- read.csv("C:/JVA/Consult/Tucker/outties.csv")
# create a copy of the Diet.Item column, making it a factor, ordered by the median length (for plotting)
medianlength <- tapply(outties$mm.length, outties$Diet.Item, median, na.rm=TRUE)
outties$Diet.Item.factor <- factor(outties$Diet.Item, levels=names(sort(medianlength)))
# boxplots of all the diet item sizes
windows(h=9, w=6.5)
par(mar=c(4, 12, 1, 1), cex=0.6)
a <- boxplot(mm.length ~ Diet.Item.factor, data=outties, horizontal=TRUE, las=1, xlab="Length  (mm)", ylab="", main="")
# add median length to data frame
index <- tapply(outties$mm.length, outties$Diet.Item)
outties$medianlen <- medianlength[index]
# outlier measure: the number of interquartile ranges beyond the lower and upper quartiles
q1 <- tapply(outties$mm.length, outties$Diet.Item, quantile, 0.25, na.rm=TRUE)[index]
q3 <- tapply(outties$mm.length, outties$Diet.Item, quantile, 0.75, na.rm=TRUE)[index]
iqr <- q3 - q1
outties$outmeas <- ifelse(is.na(iqr), NA, 0)
sel <- !is.na(outties$mm.length) & outties$mm.length < q1
outties$outmeas[sel] <- ((outties$mm.length - q1)/iqr)[sel]
sel <- !is.na(outties$mm.length) & outties$mm.length > q3
outties$outmeas[sel] <- ((outties$mm.length - q3)/iqr)[sel]
# sort the data by the iqrsfrommedian (in absolute value) to look at potential outliers
outord <- outties[order(-abs(outties$outmeas), outties$medianlen, outties$mm.length), ]
outord[abs(outord$outmeas) > 1.5, ]
windows()
plot(sort(outmeas))
plot(sort(outties$outmeas))
outties[outties$Diet.Item %in% c("Gastropod TL", "Quagga whole"), ]
outties[outties$Diet.Item %in% c("Quagga whole"), ]
#subset
outties <- outties[outties$Diet.Item %in% c("Gastropod TL", "Quagga whole"), ]
# outlier measure: the number of interquartile ranges beyond the lower and upper quartiles
q1 <- tapply(outties$mm.length, outties$Diet.Item, quantile, 0.25, na.rm=TRUE)[index]
q3 <- tapply(outties$mm.length, outties$Diet.Item, quantile, 0.75, na.rm=TRUE)[index]
iqr <- q3 - q1
q1
table(q1)
table(q3)
outmeas <- ifelse(is.na(iqr), NA, 0)
table(outmeas)
sel <- !is.na(outties$mm.length) & outties$mm.length < q1
outmeas[sel] <- ((outties$mm.length - q1)/iqr)[sel]
length(sel)
!is.na(outties$mm.length)
length(!is.na(outties$mm.length))
outties$mm.length < q1
length(outties$mm.length)
length(q1)
# read in the data
outties <- read.csv("C:/JVA/Consult/Tucker/outties.csv")
# create a copy of the Diet.Item column, making it a factor, ordered by the median length (for plotting)
medianlength <- tapply(outties$mm.length, outties$Diet.Item, median, na.rm=TRUE)
Diet.Item.factor <- factor(outties$Diet.Item, levels=names(sort(medianlength)))
# boxplots of all the diet item sizes
# windows(h=9, w=6.5)
# par(mar=c(4, 12, 1, 1), cex=0.6)
# a <- boxplot(outties$mm.length ~ Diet.Item.factor, horizontal=TRUE, las=1, xlab="Length  (mm)", ylab="", main="")
#subset
outties <- outties[outties$Diet.Item %in% c("Gastropod TL", "Quagga whole"), ]
# add median length to data frame
index <- tapply(outties$mm.length, outties$Diet.Item)
outties$medianlen <- medianlength[index]
# outlier measure: the number of interquartile ranges beyond the lower and upper quartiles
q1 <- tapply(outties$mm.length, outties$Diet.Item, quantile, 0.25, na.rm=TRUE)[index]
q3 <- tapply(outties$mm.length, outties$Diet.Item, quantile, 0.75, na.rm=TRUE)[index]
iqr <- q3 - q1
outmeas <- ifelse(is.na(iqr), NA, 0)
sel <- !is.na(outties$mm.length) & outties$mm.length < q1
outmeas[sel] <- ((outties$mm.length - q1)/iqr)[sel]
sel <- !is.na(outties$mm.length) & outties$mm.length > q3
outmeas[sel] <- ((outties$mm.length - q3)/iqr)[sel]
table(iqr)
table(q1)
table(q3)
table(medianlen)
table(outties$medianlen)
cbind(outties, q1, q3, iqr, outmeas)
# sort the data by the iqrsfrommedian (in absolute value) to look at potential outliers
outord <- outties[order(-abs(outties$outmeas), outties$medianlen, outties$mm.length), ]
outord[abs(outord$outmeas) > 1.5, ]
dim(outord)
dim(outties)
class(outmeas)
# outlier measure: the number of interquartile ranges beyond the lower and upper quartiles
q1 <- tapply(outties$mm.length, outties$Diet.Item, quantile, 0.25, na.rm=TRUE)[index]
q3 <- tapply(outties$mm.length, outties$Diet.Item, quantile, 0.75, na.rm=TRUE)[index]
iqr <- q3 - q1
outmeas <- ifelse(is.na(iqr), NA, 0)
class(outmeas)
outmeas
dim(outmeas)
outmeas <- rep(0, length(iqr))
outmeas[is.na(iqr)] <- NA
class(outmeas)
# outlier measure: the number of interquartile ranges beyond the lower and upper quartiles
q1 <- tapply(outties$mm.length, outties$Diet.Item, quantile, 0.25, na.rm=TRUE)[index]
q3 <- tapply(outties$mm.length, outties$Diet.Item, quantile, 0.75, na.rm=TRUE)[index]
iqr <- q3 - q1
outmeas <- rep(0, length(iqr))
outmeas[is.na(iqr)] <- NA
sel <- !is.na(outties$mm.length) & outties$mm.length < q1
outmeas[sel] <- ((outties$mm.length - q1)/iqr)[sel]
sel <- !is.na(outties$mm.length) & outties$mm.length > q3
outmeas[sel] <- ((outties$mm.length - q3)/iqr)[sel]
# sort the data by the iqrsfrommedian (in absolute value) to look at potential outliers
outord <- outties[order(-abs(outties$outmeas), outties$medianlen, outties$mm.length), ]
outord[abs(outord$outmeas) > 1.5, ]
outties$outmeas <- outmeas
# sort the data by the iqrsfrommedian (in absolute value) to look at potential outliers
outord <- outties[order(-abs(outties$outmeas), outties$medianlen, outties$mm.length), ]
outord[abs(outord$outmeas) > 1.5, ]
a
outord[abs(outord$outmeas) > 1.5, ]
cleanup()
search()
detach()
# read in the data
outties <- read.csv("C:/JVA/Consult/Tucker/outties.csv")
# create a copy of the Diet.Item column, making it a factor, ordered by the median length (for plotting)
medianlength <- tapply(outties$mm.length, outties$Diet.Item, median, na.rm=TRUE)
Diet.Item.factor <- factor(outties$Diet.Item, levels=names(sort(medianlength)))
# boxplots of all the diet item sizes
# windows(h=9, w=6.5)
# par(mar=c(4, 12, 1, 1), cex=0.6)
# a <- boxplot(outties$mm.length ~ Diet.Item.factor, horizontal=TRUE, las=1, xlab="Length  (mm)", ylab="", main="")
#subset
outties <- outties[outties$Diet.Item %in% c("Gastropod TL", "Quagga whole"), ]
# add median length to data frame
index <- tapply(outties$mm.length, outties$Diet.Item)
outties$medianlen <- medianlength[index]
# outlier measure: the number of interquartile ranges beyond the lower and upper quartiles
# calculate quartiles and interquartile range
q1 <- tapply(outties$mm.length, outties$Diet.Item, quantile, 0.25, na.rm=TRUE)[index]
q3 <- tapply(outties$mm.length, outties$Diet.Item, quantile, 0.75, na.rm=TRUE)[index]
iqr <- q3 - q1
# set outlier measure to zero
outmeas <- rep(0, length(iqr))
# change it to NA if the interquartile range is missing
outmeas[is.na(iqr)] <- NA
# calculate the number of interquartile ranges below the first quartile
sel <- !is.na(outties$mm.length) & outties$mm.length < q1
outmeas[sel] <- ((outties$mm.length - q1)/iqr)[sel]
# calculate the number of interquartile ranges above the third quartile
sel <- !is.na(outties$mm.length) & outties$mm.length > q3
outmeas[sel] <- ((outties$mm.length - q3)/iqr)[sel]
# save the result to the outties data frame
outties$outmeas <- outmeas
# sort the data by outmeas (in absolute value) to look at potential outliers
outord <- outties[order(-abs(outties$outmeas), outties$medianlen, outties$mm.length), ]
outord[abs(outord$outmeas) > 1.5, ]
# read in the data
outties <- read.csv("C:/JVA/Consult/Tucker/outties.csv")
# create a copy of the Diet.Item column, making it a factor, ordered by the median length (for plotting)
medianlength <- tapply(outties$mm.length, outties$Diet.Item, median, na.rm=TRUE)
Diet.Item.factor <- factor(outties$Diet.Item, levels=names(sort(medianlength)))
# boxplots of all the diet item sizes
# windows(h=9, w=6.5)
# par(mar=c(4, 12, 1, 1), cex=0.6)
# a <- boxplot(outties$mm.length ~ Diet.Item.factor, horizontal=TRUE, las=1, xlab="Length  (mm)", ylab="", main="")
#subset
#outties <- outties[outties$Diet.Item %in% c("Gastropod TL", "Quagga whole"), ]
# add median length to data frame
index <- tapply(outties$mm.length, outties$Diet.Item)
outties$medianlen <- medianlength[index]
# outlier measure: the number of interquartile ranges beyond the lower and upper quartiles
# calculate quartiles and interquartile range
q1 <- tapply(outties$mm.length, outties$Diet.Item, quantile, 0.25, na.rm=TRUE)[index]
q3 <- tapply(outties$mm.length, outties$Diet.Item, quantile, 0.75, na.rm=TRUE)[index]
iqr <- q3 - q1
# set outlier measure to zero
outmeas <- rep(0, length(iqr))
# change it to NA if the interquartile range is missing
outmeas[is.na(iqr)] <- NA
# calculate the number of interquartile ranges below the first quartile
sel <- !is.na(outties$mm.length) & outties$mm.length < q1
outmeas[sel] <- ((outties$mm.length - q1)/iqr)[sel]
# calculate the number of interquartile ranges above the third quartile
sel <- !is.na(outties$mm.length) & outties$mm.length > q3
outmeas[sel] <- ((outties$mm.length - q3)/iqr)[sel]
# save the result to the outties data frame
outties$outmeas <- outmeas
# sort the data by outmeas (in absolute value) to look at potential outliers
outord <- outties[order(-abs(outties$outmeas), outties$medianlen, outties$mm.length), ]
outord[abs(outord$outmeas) > 1.5, ]
dim(outord[abs(outord$outmeas) > 1.5, ])
# read in the data
outties <- read.csv("C:/JVA/Consult/Tucker/outties.csv")
# change the Diet.Item column, making it a factor, ordered by the median length (for plotting)
medianlength <- tapply(outties$mm.length, outties$Diet.Item, median, na.rm=TRUE)
outties$Diet.Item <- factor(outties$Diet.Item, levels=names(sort(medianlength)))
# boxplots of all the diet item sizes
# windows(h=9, w=6.5)
# par(mar=c(4, 12, 1, 1), cex=0.6)
# a <- boxplot(mm.length ~ Diet.Item, data=outties, horizontal=TRUE, las=1, xlab="Length  (mm)", ylab="", main="")
#subset
#outties <- outties[outties$Diet.Item %in% c("Gastropod TL", "Quagga whole"), ]
# add median length to data frame
index <- tapply(outties$mm.length, outties$Diet.Item)
outties$medianlen <- medianlength[index]
# outlier measure: the number of interquartile ranges beyond the lower and upper quartiles
# calculate quartiles and interquartile range
q1 <- tapply(outties$mm.length, outties$Diet.Item, quantile, 0.25, na.rm=TRUE)[index]
q3 <- tapply(outties$mm.length, outties$Diet.Item, quantile, 0.75, na.rm=TRUE)[index]
iqr <- q3 - q1
# set outlier measure to zero
outmeas <- rep(0, length(iqr))
# change it to NA if the interquartile range is missing
outmeas[is.na(iqr)] <- NA
# calculate the number of interquartile ranges below the first quartile
sel <- !is.na(outties$mm.length) & outties$mm.length < q1
outmeas[sel] <- ((outties$mm.length - q1)/iqr)[sel]
# calculate the number of interquartile ranges above the third quartile
sel <- !is.na(outties$mm.length) & outties$mm.length > q3
outmeas[sel] <- ((outties$mm.length - q3)/iqr)[sel]
# save the result to the outties data frame
outties$outmeas <- outmeas
# sort the data by outmeas (in absolute value) to look at potential outliers
outord <- outties[order(-abs(outties$outmeas), outties$medianlen, outties$mm.length), ]
outord2 <- outord[abs(outord$outmeas) > 1.5, ]
dim(outord2)
table(outord2$Diet.Item)
a
a <- boxplot(mm.length ~ Diet.Item, data=outties, horizontal=TRUE, las=1, xlab="Length  (mm)", ylab="", main="")
a
a$names[a$group]
table(a$names[a$group])
table(outord2$Diet.Item)
sort(table(a$names[a$group]))
rev(sort(table(a$names[a$group])))
rev(sort(table(outord2$Diet.Item)))
sum(rev(sort(table(outord2$Diet.Item))))
dim(outord2)
outord2
summary(outord2$outmeas)
# sort the data by outmeas (in absolute value) to look at potential outliers
outord <- outties[order(-abs(outties$outmeas), outties$medianlen, outties$mm.length), ]
outord2 <- outord[!is.na(outord$outmeas) & abs(outord$outmeas) > 1.5, ]
dim(outord2)
table(outord2$Diet.Item)
# sort the data by outmeas (in absolute value) to look at potential outliers
outord <- outties[order(-abs(outties$outmeas), outties$medianlen, outties$mm.length), ]
outord2 <- outord[!is.na(outord$outmeas) & abs(outord$outmeas) > 1.5, ]
outord2
rev(sort(table(outord2$Diet.Item)))
rev(sort(table(a$names[a$group])))
rev(sort(table(outord2$Diet.Item)))
# read in the data
outties <- read.csv("C:/JVA/Consult/Tucker/outties.csv")
# change the Diet.Item column, making it a factor, ordered by the median length (for plotting)
medianlength <- tapply(outties$mm.length, outties$Diet.Item, median, na.rm=TRUE)
outties$Diet.Item <- factor(outties$Diet.Item, levels=names(sort(medianlength)))
# boxplots of all the diet item sizes
# windows(h=9, w=6.5)
# par(mar=c(4, 12, 1, 1), cex=0.6)
# a <- boxplot(mm.length ~ Diet.Item, data=outties, horizontal=TRUE, las=1, xlab="Length  (mm)", ylab="", main="")
#subset
outties <- outties[outties$Diet.Item %in% c("Gastropod TH", "Chironominae TL", "Z septa L", "Acroperus"), ]
# add median length to data frame
index <- tapply(outties$mm.length, outties$Diet.Item)
outties$medianlen <- medianlength[index]
# outlier measure: the number of interquartile ranges beyond the lower and upper quartiles
# calculate quartiles and interquartile range
q1 <- tapply(outties$mm.length, outties$Diet.Item, quantile, 0.25, na.rm=TRUE)[index]
q3 <- tapply(outties$mm.length, outties$Diet.Item, quantile, 0.75, na.rm=TRUE)[index]
iqr <- q3 - q1
# set outlier measure to zero
outmeas <- rep(0, length(iqr))
# change it to NA if the interquartile range is missing
outmeas[is.na(iqr)] <- NA
# calculate the number of interquartile ranges below the first quartile
sel <- !is.na(outties$mm.length) & outties$mm.length < q1
outmeas[sel] <- ((outties$mm.length - q1)/iqr)[sel]
# calculate the number of interquartile ranges above the third quartile
sel <- !is.na(outties$mm.length) & outties$mm.length > q3
outmeas[sel] <- ((outties$mm.length - q3)/iqr)[sel]
# save the result to the outties data frame
outties$outmeas <- outmeas
# sort the data by outmeas (in absolute value) to look at potential outliers
outord <- outties[order(-abs(outties$outmeas), outties$medianlen, outties$mm.length), ]
outord2 <- outord[!is.na(outord$outmeas) & abs(outord$outmeas) > 1.5, ]
outord2
rev(sort(table(outord2$Diet.Item)))
a <- boxplot(mm.length ~ Diet.Item, data=outties, horizontal=TRUE, las=1, xlab="Length  (mm)", ylab="", main="")
a
outord2
q1
sel <- outties$Diet.Item=="Acroperus"
q1[sel]
q3[sel]
mm.length[se;]
mm.length[sel]
outties$mm.length[sel]
sort(outties$mm.length[sel])
b <- sort(outties$mm.length[sel])
summary(b)
quantile(b, c(.25, .5, .75))
boxplot.stats(b)
boxplot.stats
fivenum
fivenum(b)
?fivenum
fivenum(1:5)
summary(1:5)
fivenum(1:6)
summary(1:6)
graphics.off()
cleanup()
search()
# read in the data
outties <- read.csv("C:/JVA/Consult/Tucker/outties.csv")
# make Diet.Item a factor, ordered by the median length (for plotting)
medianlength <- tapply(outties$mm.length, outties$Diet.Item, median, na.rm=TRUE)
outties$Diet.Item <- factor(outties$Diet.Item, levels=names(sort(medianlength)))
# boxplots of all the diet item sizes
windows(h=9, w=6.5)
par(mar=c(4, 12, 1, 1), cex=0.6)
boxplot(mm.length ~ Diet.Item, data=outties, horizontal=TRUE, las=1, xlab="Length  (mm)", ylab="", main="")
#subset
#outties <- outties[outties$Diet.Item %in% c("Gastropod TH", "Chironominae TL", "Z septa L", "Acroperus"), ]
# add median length to data frame
index <- tapply(outties$mm.length, outties$Diet.Item)
outties$medianlen <- medianlength[index]
# outlier measure: the number of interquartile ranges beyond the lower and upper quartiles
# calculate quartiles and interquartile range
q1 <- tapply(outties$mm.length, outties$Diet.Item, quantile, 0.25, na.rm=TRUE)[index]
q3 <- tapply(outties$mm.length, outties$Diet.Item, quantile, 0.75, na.rm=TRUE)[index]
iqr <- q3 - q1
# set outlier measure to zero
outmeas <- rep(0, length(iqr))
# change it to NA if the interquartile range is missing
outmeas[is.na(iqr)] <- NA
# calculate the number of interquartile ranges below the first quartile
sel <- !is.na(outties$mm.length) & outties$mm.length < q1
outmeas[sel] <- ((outties$mm.length - q1)/iqr)[sel]
# calculate the number of interquartile ranges above the third quartile
sel <- !is.na(outties$mm.length) & outties$mm.length > q3
outmeas[sel] <- ((outties$mm.length - q3)/iqr)[sel]
# save the result to the outties data frame
outties$outmeas <- outmeas
# sort the data by outmeas (in absolute value) to look at potential outliers
outord <- outties[order(-abs(outties$outmeas), outties$medianlen, outties$mm.length), ]
outord2 <- outord[!is.na(outord$outmeas) & abs(outord$outmeas) > 1.5, ]
outord2
rev(sort(table(outord2$Diet.Item)))
# read in the data
outties <- read.csv("C:/JVA/Consult/Tucker/outties.csv")
# make Diet.Item a factor, ordered by the median length (for plotting)
medianlength <- tapply(outties$mm.length, outties$Diet.Item, median, na.rm=TRUE)
itemfactor <- factor(outties$Diet.Item, levels=names(sort(medianlength)))
# boxplots of all the diet item sizes
windows(h=9, w=6.5)
par(mar=c(4, 12, 1, 1), cex=0.6)
boxplot(outties$mm.length ~ itemfactor, horizontal=TRUE, las=1, xlab="Length  (mm)", ylab="", main="")
#subset
#outties <- outties[outties$Diet.Item %in% c("Gastropod TH", "Chironominae TL", "Z septa L", "Acroperus"), ]
# add median length to data frame
index <- tapply(outties$mm.length, outties$Diet.Item)
outties$medianlen <- medianlength[index]
# outlier measure: the number of interquartile ranges beyond the lower and upper quartiles
# calculate quartiles and interquartile range
q1 <- tapply(outties$mm.length, outties$Diet.Item, quantile, 0.25, na.rm=TRUE)[index]
q3 <- tapply(outties$mm.length, outties$Diet.Item, quantile, 0.75, na.rm=TRUE)[index]
iqr <- q3 - q1
# set outlier measure to zero
outmeas <- rep(0, length(iqr))
# change it to NA if the interquartile range is missing
outmeas[is.na(iqr)] <- NA
# calculate the number of interquartile ranges below the first quartile
sel <- !is.na(outties$mm.length) & outties$mm.length < q1
outmeas[sel] <- ((outties$mm.length - q1)/iqr)[sel]
# calculate the number of interquartile ranges above the third quartile
sel <- !is.na(outties$mm.length) & outties$mm.length > q3
outmeas[sel] <- ((outties$mm.length - q3)/iqr)[sel]
# save the result to the outties data frame
outties$outmeas <- outmeas
# sort the data by outmeas (in absolute value) to look at potential outliers
outord <- outties[order(-abs(outties$outmeas), outties$medianlen, outties$mm.length), ]
outord2 <- outord[!is.na(outord$outmeas) & abs(outord$outmeas) > 1.5, ]
outord2
rev(sort(table(outord2$Diet.Item)))
cleanup()
search()
# C:\JVA\Consult\Tucker\Outliers.r
# read in the data
outties <- read.csv("C:/JVA/Consult/Tucker/outties.csv")
# create a factor version of Diet.Item a factor, ordered by the median length (for plotting)
medianlength <- tapply(outties$mm.length, outties$Diet.Item, median, na.rm=TRUE)
itemfactor <- factor(outties$Diet.Item, levels=names(sort(medianlength)))
# add median length to data frame
index <- tapply(outties$mm.length, outties$Diet.Item)
outties$medianlen <- medianlength[index]
# boxplots of all the diet item sizes
windows(h=9, w=6.5)
par(mar=c(4, 12, 1, 1), cex=0.6)
boxplot(outties$mm.length ~ itemfactor, horizontal=TRUE, las=1, xlab="Length  (mm)", ylab="", main="")
# outlier measure: the number of interquartile ranges beyond the lower and upper quartiles
# calculate quartiles and interquartile range
q1 <- tapply(outties$mm.length, outties$Diet.Item, quantile, 0.25, na.rm=TRUE)[index]
q3 <- tapply(outties$mm.length, outties$Diet.Item, quantile, 0.75, na.rm=TRUE)[index]
iqr <- q3 - q1
# set outlier measure to zero
outmeas <- rep(0, length(iqr))
# change it to NA if the interquartile range is missing
outmeas[is.na(iqr)] <- NA
# calculate the number of interquartile ranges below the first quartile
sel <- !is.na(outties$mm.length) & outties$mm.length < q1
outmeas[sel] <- ((outties$mm.length - q1)/iqr)[sel]
# calculate the number of interquartile ranges above the third quartile
sel <- !is.na(outties$mm.length) & outties$mm.length > q3
outmeas[sel] <- ((outties$mm.length - q3)/iqr)[sel]
# save the result to the outties data frame
outties$outmeas <- outmeas
# sort the data by outmeas (in absolute value) to look at potential outliers
outord <- outties[order(-abs(outties$outmeas), outties$medianlen, outties$mm.length), ]
outord2 <- outord[!is.na(outord$outmeas) & abs(outord$outmeas) > 1.5, ]
outord2
rev(sort(table(outord2$Diet.Item)))
ls()
rm(medianlength, itemfactor)
rm(q1, q3, iqr, outmeas, sel)
ls()
# C:\JVA\Consult\Tucker\Outliers.r
# read in the data
outties <- read.csv("C:/JVA/Consult/Tucker/outties.csv")
# create a factor version of Diet.Item a factor, ordered by the median length (for plotting)
medianlength <- tapply(outties$mm.length, outties$Diet.Item, median, na.rm=TRUE)
itemfactor <- factor(outties$Diet.Item, levels=names(sort(medianlength)))
# add median length to data frame
index <- tapply(outties$mm.length, outties$Diet.Item)
outties$medianlen <- medianlength[index]
# boxplots of all the diet item sizes
windows(h=9, w=6.5)
par(mar=c(4, 12, 1, 1), cex=0.6)
boxplot(outties$mm.length ~ itemfactor, horizontal=TRUE, las=1, xlab="Length  (mm)", ylab="", main="")
rm(medianlength, itemfactor)
# outlier measure: the number of interquartile ranges beyond the lower and upper quartiles
# calculate quartiles and interquartile range
q1 <- tapply(outties$mm.length, outties$Diet.Item, quantile, 0.25, na.rm=TRUE)[index]
q3 <- tapply(outties$mm.length, outties$Diet.Item, quantile, 0.75, na.rm=TRUE)[index]
iqr <- q3 - q1
# set outlier measure to zero
outmeas <- rep(0, length(iqr))
# change it to NA if the interquartile range is missing
outmeas[is.na(iqr)] <- NA
# calculate the number of interquartile ranges below the first quartile
sel <- !is.na(outties$mm.length) & outties$mm.length < q1
outmeas[sel] <- ((outties$mm.length - q1)/iqr)[sel]
# calculate the number of interquartile ranges above the third quartile
sel <- !is.na(outties$mm.length) & outties$mm.length > q3
outmeas[sel] <- ((outties$mm.length - q3)/iqr)[sel]
# save the result to the outties data frame
outties$outmeas <- outmeas
rm(index, q1, q3, iqr, outmeas, sel)
# sort the data by outmeas (in absolute value) to look at potential outliers
outord <- outties[order(-abs(outties$outmeas), outties$medianlen, outties$mm.length), ]
sel <- !is.na(outord$outmeas) & abs(outord$outmeas) > 1.5
outord[sel, ]
table(outord$Diet.Item[sel])
rm(sel)
ls()
q()
{ # functions
# the following seven plot.table related functions are from the Systematic Investor Toolbox
# load Systematic Investor Toolbox
# require(RCurl)
# sit = getURLContent("https://github.com/systematicinvestor/SIT/raw/master/sit.gz", binary=TRUE, followlocation=TRUE, ssl.verifypeer=FALSE)
# con = gzcon(rawConnection(sit, "rb"))
# source(con)
# close(con)
draw.cell <- function(title, r, c, text.cex = 1, bg.col = 'white', frame.cell = T) {
if(!frame.cell) bcol = bg.col else bcol = 'black'
rect((2*(c - 1) + .5), -(r - .5), (2*c + .5), -(r + .5), col = bg.col, border = bcol)
if( c == 1) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else if( r == 1 ) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else {
text((2*c + .5), -r, title, adj = 1, cex = text.cex)
}
}
plot.table.helper.auto.adjust.cex <- function(temp.table, keep.all.same.cex = FALSE) {
nr = nrow(temp.table)
nc = ncol(temp.table)
all.xrange = diff(par()$usr[1:2]) / nc
xrange = matrix( strwidth(paste('  ', temp.table), units = 'user', cex = 1), nc = nc)
all.yrange = diff(par()$usr[3:4]) / nr
yrange = matrix( 5/3 * strheight(temp.table, units = 'user', cex = 1), nc = nc)
plot.matrix.cex = pmin( round(all.yrange / yrange, 2) , round(all.xrange / xrange, 2) )
header.col.cex = min(plot.matrix.cex[1,-1])
header.row.cex = min(plot.matrix.cex[-1,1])
title.cex = plot.matrix.cex[1, 1]
data.cex = min(plot.matrix.cex[-1, -1])
if ( keep.all.same.cex ) {
plot.matrix.cex[] = min(plot.matrix.cex)
} else {
plot.matrix.cex[1,-1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,-1]= min(c(header.col.cex, header.row.cex, data.cex))
plot.matrix.cex[1,1]= min(c(header.col.cex, header.row.cex, data.cex, title.cex))
plot.matrix.cex[1,-1] = min(c(header.col.cex))
plot.matrix.cex[-1,1] = min(c(header.row.cex))
plot.matrix.cex[-1,-1]= min(c(data.cex))
plot.matrix.cex[1,1]= min(c(title.cex))
}
return(plot.matrix.cex)
}
make.table <- function(nr, nc) {
savepar = par(mar = rep(1, 4))
plot(c(0.5, nc*2 + 0.5), c(-0.5, -(nr + 0.5)), xaxs = 'i', yaxs = 'i',
type = 'n', xlab = '', ylab = '', axes = FALSE)
savepar
}
trim <- function(s) {
s = sub(pattern = '^ +', replacement = '', x = s)
s = sub(pattern = ' +$', replacement = '', x = s)
return(s)
}
plot.table.param <- function(plot.matrix, smain = '', plot.matrix.cex, plot.matrix_bg.col, frame.cell = T, keep.all.same.cex = FALSE) {
n = nrow(plot.matrix)
pages = unique(c(seq(0, n, by = 120), n))
for(p in 1:(length(pages)-1)) {
rindex = (pages[p]+1) : pages[p+1]
temp.table = matrix('', nr = length(rindex)+1, nc = ncol(plot.matrix)+1)
temp.table[-1, -1] = plot.matrix[rindex,]
temp.table[1, -1] = colnames(plot.matrix)
temp.table[-1, 1] = rownames(plot.matrix)[rindex]
temp.table[1, 1] = smain
nr = nrow(temp.table)
nc = ncol(temp.table)
par(mar = c(0, 0, 0, 0), cex = 0.5)
oldpar = make.table(nr, nc)
text.cex = plot.matrix.cex[c(1, 1 + rindex), ]
text.cex = plot.table.helper.auto.adjust.cex(temp.table, keep.all.same.cex)
bg.col = plot.matrix_bg.col[c(1, 1 + rindex), ]
for(r in 1:nr) {
for(c in 1:nc) {
draw.cell( paste('', temp.table[r,c], '', sep=' '), r, c,
text.cex = text.cex[r,c], bg.col = bg.col[r,c], frame.cell = frame.cell)
}}
}
}
plot.table <- function(plot.matrix, smain="", text.cex=1, frame.cell=TRUE, highlight=FALSE, colorbar=FALSE, keep_all.same.cex=FALSE) {
if( is.null(rownames(plot.matrix)) & is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
if( ncol(temp.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[-1, -1, drop = FALSE]
colnames(plot.matrix) = temp.matrix[1, -1]
rownames(plot.matrix) = temp.matrix[-1, 1]
smain = temp.matrix[1, 1]
} else if( is.null(rownames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( ncol(plot.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[, -1, drop = FALSE]
colnames(plot.matrix) = colnames(temp.matrix)[-1]
rownames(plot.matrix) = temp.matrix[,1]
smain = colnames(temp.matrix)[1]
} else if( is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
plot.matrix = temp.matrix[-1, , drop = FALSE]
rownames(plot.matrix) = rownames(temp.matrix)[-1]
colnames(plot.matrix) = temp.matrix[1, ]
smain = rownames(temp.matrix)[1]
}
plot.matrix[which(trim(plot.matrix) == "NA")] = ""
plot.matrix[which(trim(plot.matrix) == "NA%")] = ""
plot.matrix[which(is.na(plot.matrix))] = ""
nr = nrow(plot.matrix) + 1
nc = ncol(plot.matrix) + 1
is_highlight = TRUE
if(is.logical(highlight)) {
is_highlight = highlight
if(highlight) highlight = plot.table.helper.color(plot.matrix)
}
if(!is_highlight) {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[seq(1, nr, 2), ] = "yellow"
plot.matrix_bg.col[1,] = "gray";
plot.table.param( plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
} else {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[1,] = "gray"
plot.matrix_bg.col[2:nr,2:nc] = highlight
plot.table.param(plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
}
}
plot.table.helper.color <- function (temp) {
temp = matrix(as.double(gsub("[%,$]", "", temp)), nrow(temp), ncol(temp))
highlight = as.vector(temp)
cols = rep(NA, length(highlight))
ncols = length(highlight[!is.na(highlight)])
cols[1:ncols] = rev(rainbow(ncols, start=0.5/6, end=3.5/6))
o = sort.list(highlight, na.last = TRUE, decreasing = FALSE)
o1 = sort.list(o, na.last = TRUE, decreasing = FALSE)
highlight = matrix(cols[o1], nrow = nrow(temp))
highlight[is.na(temp)] = NA
return(highlight)
}
ModelEst <- function(fit, df) {
# derive regression estimates from log(y) fit
mse <- rev(as.matrix(summary(fit)[[1]])[, "Mean Sq"])[1]
plpe <- predict(fit, newdata=df, se.fit=T)
m <- plpe$fit
v <- plpe$se.fit^2 + mse
exp(m + v/2)
}
myrange <- function(x) {
if(all(is.na(x))) r <- c(NA, NA) else r <- range(x, na.rm=TRUE)
return(r)
}
jackindex <- function(m) {
# m is a matrix of numbers (stream PEs) with observations (years) as rows and individuals (streams) as columns
if(any(is.na(m))) stop("The input matrix may not have any missing values.")
# calculate the index as the sum of the columns for each row
rowsum <- apply(m, 1, sum)
# calculate the mean of the index
avgind <- mean(rowsum)
# recalculate the index, leaving out one individual at a time
loo <- apply(m, 2, function(column) (rowsum - column))
# rescale the loo index, relative to mean
looscaled <- apply(loo, 2, function(x) x/mean(x))
# convert to original scale
looscaled2 <- looscaled * avgind
# calculate range
ranges <- t(apply(looscaled2, 1, range))
cbind(index=rowsum, lo=ranges[, 1], hi=ranges[, 2])
}
# selstreams <- index.streams[[1]] 
# allstreamdf <- dat
# alllakedf <- lk 
# min.nmr=2 
# show=FALSE
index.est <- function(selstreams, allstreamdf, alllakedf, min.nmr=2, show=FALSE) {
# INDEX OF ADULT SEA LAMPREY ABUNDANCE
### INPUTS
# selstreams = vector of stream ids, e.g., 1.064 (lake + strcode/1000)
# allstreamdf = data frame of mark-recap estimates for all streams, with vars:  year lake ls Emr CVmr
# alllakedf = data frame of lake-wide PEs from Mullett et al. (2003) spawner model with vars:  lake year PE
# min.nmr = minimum number of mark-recapture estimates needed in a year to generate an index, default 2
# show = print out a brief summary of the results, default FALSE
### OUTPUTS
# indfit = simple model used to predict missing mark-recap estimates
# streamdf = original allstreamdf, subsetted by selstreams, with estimates for missing mark-recaps
# indxdf = original alllakedf, subsetted by lake, with annual index, including raw (indxraw), kept based on min.nmr (indxkeep, indxkeep.lo, indxkeep.hi)
# scaleup = conversion factor used to scale up annual index to spawner model PE
streamdf <- allstreamdf[allstreamdf$ls %in% selstreams, ]
# error checks
check1 <- var(streamdf$lake)
if(is.na(check1) | is.null(check1)) stop("Either no streams selected or critical data missing.") else if(check1 > 0) stop("Selected streams should be only from ONE lake.")
if(any(is.na(match(c("year", "lake", "ls", "Emr", "CVmr"), names(allstreamdf))))) stop("allstreamdf must include these variables: year lake ls Emr CVmr.")
if(any(is.na(match(c("year", "lake", "PE"), names(alllakedf))))) stop("alllakedf must include these variables: lake year PE.")
# fill in missing mark-recap data
indfit <- aov(log(Emr) ~ as.factor(ls) + as.factor(year), data=streamdf, weights=1/CVmr^2)
# figure out estimable years (those with at least 1 m-r estimate)
n.mr <- tapply(!is.na(streamdf$Emr), streamdf$year, sum)
eyrs <- as.numeric(names(n.mr)[n.mr > 0.5])
estimable <- streamdf$year %in% eyrs
streamdf$Pmr <- NA
streamdf$Pmr[estimable] <- ModelEst(fit=indfit, df=streamdf[estimable, ])
streamdf$COMBmr <- ifelse(is.na(streamdf$Emr), streamdf$Pmr, streamdf$Emr)
# annual index (sum across streams)
indxdf <- aggregate(COMBmr ~ year + lake, streamdf, sum, na.rm=TRUE, na.action=na.pass)
names(indxdf)[names(indxdf)=="COMBmr"] <- "indxraw"
indxdf$indxraw[indxdf$indxraw==0] <- NA
# only keep lake-wide index for years with at least min.nmr mark-recap estimates
indxdf$n.mr <- n.mr
indxdf$indxkeep <- ifelse(indxdf$n.mr > (min.nmr - 0.5), indxdf$indxraw, NA)
indxdf$indxkeep.lo <- NA
indxdf$indxkeep.hi <- NA
# matrix of stream estimates (rows = years, columns = index streams)
streamests <- with(streamdf, tapply(COMBmr, list(year, ls), mean))
# selection of only those streams with a keepable index
selkeep <- !is.na(indxdf$indxkeep)
jack <- jackindex(streamests[selkeep, ])
indxdf$indxkeep.lo[selkeep] <- jack[, "lo"]
indxdf$indxkeep.hi[selkeep] <- jack[, "hi"]
# scale up the index to the spawner model PE
lk1 <- lk[lk$lake == streamdf$lake[1], ]
indxdf2 <- merge(lk1, indxdf, all=TRUE)
scaleup <- median(indxdf2$PE / indxdf2$indxkeep, na.rm=TRUE)
if(show) {
cat("\nindfit\n")
print(summary(indfit))
cat("\nstreamdf\n")
print(tail(streamdf[, c("lake", "year", "ls", "Emr", "CVmr", "Pmr", "COMBmr")]))
cat("\nscaleup\n")
print(scaleup)
cat("\nindxdf\n")
print(tail(indxdf[, c("lake", "year", "n.mr", "indxraw", "indxkeep", "indxkeep.lo", "indxkeep.hi")]))
}
list(indfit=indfit, streamdf=streamdf, scaleup=scaleup, indxdf=indxdf)
}
calctarg <- function(lakenum, adults, year, targyears, adjust=c(1, 1, 0.25, 1, 1)) {
# lakenum = vector of lake numbers (1-5)
# adults = vector of lakewide adult sea lamprey estimates
# year = vector of years
# targyears = list (length 5) of selected years from which to calculate targets
# lake huron target is 25% of
targets <- data.frame(lake=1:5, target=rep(NA, 5), lo=rep(NA, 5), hi=rep(NA, 5))
for(i in 1:5) {
pick5 <- adults[lakenum==i & is.element(year, targyears[[i]]) & !is.na(adults)]
if(length(pick5) > 0) {
targets$target[i] <- mean(pick5)
n <- length(pick5)
ci <- qnorm(1 - 0.05/2) * sqrt(var(pick5)) / sqrt(n)
targets[i, c("lo", "hi")] <- mean(pick5) + c(-1, 1)*ci# using z dist (known variance)
targets[i, c("target", "lo", "hi")] <- adjust[i]*targets[i, c("target", "lo", "hi")]
} else {
targets[i, c("target", "lo", "hi")] <- c(NA, NA, NA)
}
}
targets
}
}
# bring in lake-wide spawner data
lk <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/LakePEdynamic.csv", as.is=T)
# bring in stream-specific data
dat <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/StreamPEdynamicALLCOLS.csv", as.is=T)
dat$ls <- dat$lscode
head(dat)
head(dat)
attach(dat)
table(est.source)
table(ls, year, est.source=="model")
look <- table(ls, year, est.source=="model")
apply(look, c(1, 3), sum)
look <- table(ls, year, est.source=="model")
look2 <- apply(look, c(1, 3), sum)
look2[order(look2[, 1] - look2[, 2]), ]
look <- table(ls, year, est.source=="model")
look2 <- apply(look, c(1, 3), sum)
look3 <- look2[look2[, 1]>0 & look2[, 2]>0, ]
look3[order(look3[, 1] - look3[, 2]), ]
look
dim(look)
look[1:10, 29:28, ]
look[1:10, 29:38, ]
look <- table(ls, year, est.source=="model")
# just last 10 years
look2 <- apply(look[, 29:38, ], c(1, 3), sum)
look3 <- look2[look2[, 1]>0 & look2[, 2]>0, ]
look3[order(look3[, 1] - look3[, 2]), ]
look3
names(look3)
dimnames(look3)
rownames(look3)
match(rownames(look3), ls)
dat[match(rownames(look3), ls), 1:10]
index.streams <- list(
Sup = c(1, 2, 9, 29, 31, 32, 62),
Mic = c(5, 6, 15, 24, 26, 35),
Hur = c(10, 16, 27, 32, 999, 38),
Eri = c(1, 2, 3, 7, 9),
Ont = c(5, 9, 22, 23, 36)
)
index.streams <- lapply(1:5, function(i) i + index.streams[[i]]/1000)
index.streams
unlist(index.streams)
dat[match(unlist(index.streams), ls), 1:10]
dat[match(rownames(look3), ls), 1:10]
head(look3)
dim(look3)
look2
head(dat)
mylake <- 1
yrcut <- 2004.5
# plot all non-model time series for past 10 years
sel <- ls %in% rownmaes(look3[look[, "TRUE"]==0, ]) & lake==mylak & year > yrcut
# plot all non-model time series for past 10 years
sel <- ls %in% rownames(look3[look[, "TRUE"]==0, ]) & lake==mylak & year > yrcut
# plot all non-model time series for past 10 years
sel <- ls %in% rownames(look2[look2[, "TRUE"]==0, ]) & lake==mylak & year > yrcut
# plot all non-model time series for past 10 years
sel <- ls %in% rownames(look2[look2[, "TRUE"]==0, ]) & lake==mylake & year > yrcut
table(sel)
head(dat)
# plot all non-model time series for past 10 years
sel <- ls %in% rownames(look2[look2[, "TRUE"]==0, ]) & lake==mylake & year > yrcut
plot(year[sel], combPE[sel], col=as.factor(ls))
plot(year[sel], combPE[sel], col=as.factor(ls), type="l", log="y")
windows()
par(mar=c(4, 4, 1, 1))
plot(year[sel], combPE[sel], type="n", log="y", xlab="Year", ylab="Adults")
sul <- unique(ls[sel])
for(i in seq(sul)) {
sel2 <- sel & ls==sul[i]
lines(year[sel], combPE[sel], col=i)
}
par(mar=c(4, 4, 1, 1))
plot(year[sel], combPE[sel], type="n", log="y", xlab="Year", ylab="Adults")
sul <- unique(ls[sel])
for(i in seq(sul)) {
sel2 <- sel & ls==sul[i]
lines(year[sel2], combPE[sel2], col=i)
}
par(mar=c(4, 4, 1, 1))
plot(year[sel], combPE[sel], type="n", las=1, xlab="Year", ylab="Adults")
sul <- unique(ls[sel])
for(i in seq(sul)) {
sel2 <- sel & ls==sul[i]
lines(year[sel2], combPE[sel2], col=i)
}
windows()
par(mar=c(4, 4, 1, 1))
plot(year[sel], combPE[sel], type="n", las=1, log="", xlab="Year", ylab="Adults")
sul <- unique(ls[sel])
for(i in seq(sul)) {
sel2 <- sel & ls==sul[i]
lines(year[sel2], combPE[sel2], col=i)
}
plotit <- function(sell, llog) {
windows()
par(mar=c(4, 4, 1, 1))
plot(year[sell], combPE[sell], type="n", las=1, log=llog, xlab="Year", ylab="Adults")
sul <- unique(ls[sell])
for(i in seq(sul)) {
sel2 <- sell & ls==sul[i]
lines(year[sel2], combPE[sel2], col=i)
}
}
mylake <- 1
yrcut <- 2004.5
# plot all non-model time series for past 10 years
sel1 <- ls %in% rownames(look2[look2[, "TRUE"]==0, ]) & lake==mylake & year > yrcut
# plot all model time series for past 10 years
sel2 <- ls %in% rownames(look2[look2[, "FALSE"]==0, ]) & lake==mylake & year > yrcut
# plot mixed time series for past 10 years
sel3 <- ls %in% rownames(look2[look2[, "TRUE"]!=0 & look2[, "FALSE"]!=0, ]) & lake==mylake & year > yrcut
plotit(sel1, "y")
plotit(sel2, "y")
plotit(sel3, "y")
plotit <- function(mylake, sell, llog="y", yrcut=2004.5) {
selall <- lake==mylake & year > yrcut
sul <- unique(ls[selall])
windows()
par(mar=c(4, 4, 1, 1))
plot(year[selall], combPE[selall], type="n", las=1, log=llog, xlab="Year", ylab="Adults")
for(i in seq(sul)) {
sel2 <- sell & lake==mylake & year > yrcut & ls==sul[i]
lines(year[sel2], combPE[sel2], col=i)
}
}
# plot all non-model time series for past 10 years
selbest <- ls %in% rownames(look2[look2[, "TRUE"]==0, ]) & lake==mylake & year > yrcut
# plot all model time series for past 10 years
selmodel <- ls %in% rownames(look2[look2[, "FALSE"]==0, ]) & lake==mylake & year > yrcut
# plot mixed time series for past 10 years
selmixed <- ls %in% rownames(look2[look2[, "TRUE"]!=0 & look2[, "FALSE"]!=0, ]) & lake==mylake & year > yrcut
plotit(1, selbest)
plotit(1, selmodel)
plotit(1, selmixed)
plotit <- function(mylake, sell, llog="y", yrcut=2004.5) {
selall <- lake==mylake & year > yrcut
sul <- unique(ls[selall])
windows()
par(mar=c(4, 4, 1, 1))
plot(year[selall], combPE[selall], type="n", las=1, log=llog, xlab="Year", ylab="Adults")
for(i in seq(sul)) {
sel2 <- sell & lake==mylake & year > yrcut & ls==sul[i]
lines(year[sel2], combPE[sel2], col=i, type="o", pch=ifelse(est.source=="model", 16, 1))
}
}
# plot all non-model time series for past 10 years
selbest <- ls %in% rownames(look2[look2[, "TRUE"]==0, ]) & lake==mylake & year > yrcut
# plot all model time series for past 10 years
selmodel <- ls %in% rownames(look2[look2[, "FALSE"]==0, ]) & lake==mylake & year > yrcut
# plot mixed time series for past 10 years
selmixed <- ls %in% rownames(look2[look2[, "TRUE"]!=0 & look2[, "FALSE"]!=0, ]) & lake==mylake & year > yrcut
plotit(1, selbest)
plotit(1, selmodel)
plotit(1, selmixed)
plotit <- function(mylake, sell, llog="y", yrcut=2004.5) {
selall <- lake==mylake & year > yrcut
sul <- unique(ls[selall])
windows()
par(mar=c(4, 4, 1, 1))
plot(year[selall], combPE[selall], type="n", las=1, log=llog, xlab="Year", ylab="Adults")
for(i in seq(sul)) {
sel2 <- sell & lake==mylake & year > yrcut & ls==sul[i]
lines(year[sel2], combPE[sel2], col=i, type="o", pch=ifelse(est.source[sel2]=="model", 1, 16))
}
}
# plot all non-model time series for past 10 years
selbest <- ls %in% rownames(look2[look2[, "TRUE"]==0, ]) & lake==mylake & year > yrcut
# plot all model time series for past 10 years
selmodel <- ls %in% rownames(look2[look2[, "FALSE"]==0, ]) & lake==mylake & year > yrcut
# plot mixed time series for past 10 years
selmixed <- ls %in% rownames(look2[look2[, "TRUE"]!=0 & look2[, "FALSE"]!=0, ]) & lake==mylake & year > yrcut
plotit(1, selbest)
plotit(1, selmodel)
plotit(1, selmixed)
plotit(3, selbest)
plotit(3, selmodel)
plotit(3, selmixed)
graphics.off()
plotit <- function(mylake, sell, llog="y", yrcut=2004.5) {
selall <- lake==mylake & year > yrcut
sul <- unique(ls[selall])
windows()
par(mar=c(4, 4, 1, 1))
plot(year[selall], combPE[selall], type="n", las=1, log=llog, xlab="Year", ylab="Adults")
for(i in seq(sul)) {
sel2 <- sell & lake==mylake & year > yrcut & ls==sul[i]
lines(year[sel2], combPE[sel2], col=i, type="o", pch=ifelse(est.source[sel2]=="model", 1, 16))
}
}
# all non-model time series
selbest <- ls %in% rownames(look2[look2[, "TRUE"]==0, ])
# all model time series
selmodel <- ls %in% rownames(look2[look2[, "FALSE"]==0, ])
# mixed time series
selmixed <- ls %in% rownames(look2[look2[, "TRUE"]!=0 & look2[, "FALSE"]!=0, ])
plotit(3, selbest)
plotit(3, selmodel)
plotit(3, selmixed)
plotit(5, selbest)
plotit(5, selmodel)
plotit(5, selmixed)
graphics.off()
plotit(3, selbest)
plotit(3, selmodel)
plotit(3, selmixed)
plotit(3, selbest, "")
plotit(3, selmodel, "")
plotit(3, selmixed, "")
plotit(1, selbest, "")
plotit(1, selmodel, "")
plotit(1, selmixed, "")
plotit(5, selbest, "")
plotit(5, selmodel, "")
plotit(5, selmixed, "")
graphics.off()
plotit(3, selbest)
plotit(3, selmodel)
plotit(3, selmixed)
plotit <- function(mylake, sell, llog="y", yrcut=2004.5) {
selall <- lake==mylake & year > yrcut
sul <- unique(ls[selall])
windows()
par(mar=c(4, 4, 1, 1))
plot(year[selall], combPE[selall], type="n", las=1, log=llog, xlab="Year", ylab="Adults")
for(i in seq(sul)) {
sel2 <- sell & lake==mylake & year > yrcut & ls==sul[i]
lines(year[sel2], combPE[sel2], col=i, lty=2)
y <- ifelse(est.source[sel2]=="model", NA, combPE[sel2])
lines(year[sel2], combPE[sel2], col=i, type="o", pch=ifelse(est.source[sel2]=="model", 1, 16))
lines(year[sel2], y[sel2], col=i, type="o", pch=16, cex=1.5)
}
}
# all non-model time series
selbest <- ls %in% rownames(look2[look2[, "TRUE"]==0, ])
# all model time series
selmodel <- ls %in% rownames(look2[look2[, "FALSE"]==0, ])
# mixed time series
selmixed <- ls %in% rownames(look2[look2[, "TRUE"]!=0 & look2[, "FALSE"]!=0, ])
plotit(3, selbest)
plotit(3, selmodel)
plotit(3, selmixed)
plotit <- function(mylake, sell, llog="y", yrcut=2004.5) {
selall <- lake==mylake & year > yrcut
sul <- unique(ls[selall])
windows()
par(mar=c(4, 4, 1, 1))
plot(year[selall], combPE[selall], type="n", las=1, log=llog, xlab="Year", ylab="Adults")
for(i in seq(sul)) {
sel2 <- sell & lake==mylake & year > yrcut & ls==sul[i]
lines(year[sel2], combPE[sel2], col=i, lty=2)
y <- ifelse(est.source[sel2]=="model", NA, combPE[sel2])
lines(year[sel2], y[sel2], col=i, type="o", pch=16, cex=1.5)
}
}
# all non-model time series
selbest <- ls %in% rownames(look2[look2[, "TRUE"]==0, ])
# all model time series
selmodel <- ls %in% rownames(look2[look2[, "FALSE"]==0, ])
# mixed time series
selmixed <- ls %in% rownames(look2[look2[, "TRUE"]!=0 & look2[, "FALSE"]!=0, ])
plotit(3, selbest)
plotit(3, selmodel)
plotit(3, selmixed)
plotit <- function(mylake, sell, llog="y", yrcut=2004.5) {
selall <- lake==mylake & year > yrcut
sul <- unique(ls[selall])
windows()
par(mar=c(4, 4, 1, 1))
plot(year[selall], combPE[selall], type="n", las=1, log=llog, xlab="Year", ylab="Adults")
for(i in seq(sul)) {
sel2 <- sell & lake==mylake & year > yrcut & ls==sul[i]
lines(year[sel2], combPE[sel2], col=i, lty=2)
y <- ifelse(est.source[sel2]=="model", NA, combPE[sel2])
lines(year[sel2], y, col=i, type="o", pch=16, cex=1.5)
}
}
# all non-model time series
selbest <- ls %in% rownames(look2[look2[, "TRUE"]==0, ])
# all model time series
selmodel <- ls %in% rownames(look2[look2[, "FALSE"]==0, ])
# mixed time series
selmixed <- ls %in% rownames(look2[look2[, "TRUE"]!=0 & look2[, "FALSE"]!=0, ])
plotit(3, selbest)
plotit(3, selmodel)
plotit(3, selmixed)
graphics.off()
plotit <- function(mylake, sell, llog="y", yrcut=2004.5) {
selall <- lake==mylake & year > yrcut
sul <- unique(ls[selall])
windows()
par(mar=c(4, 4, 1, 1))
plot(year[selall], combPE[selall], type="n", las=1, log=llog, xlab="Year", ylab="Adults")
for(i in seq(sul)) {
sel2 <- sell & lake==mylake & year > yrcut & ls==sul[i]
lines(year[sel2], combPE[sel2], col=i, lty=2)
y <- ifelse(est.source[sel2]=="model", NA, combPE[sel2])
lines(year[sel2], y, col=i, type="o", pch=16, cex=1.2)
}
}
# all non-model time series
selbest <- ls %in% rownames(look2[look2[, "TRUE"]==0, ])
# all model time series
selmodel <- ls %in% rownames(look2[look2[, "FALSE"]==0, ])
# mixed time series
selmixed <- ls %in% rownames(look2[look2[, "TRUE"]!=0 & look2[, "FALSE"]!=0, ])
plotit(3, selbest)
plotit(3, selmodel)
plotit(3, selmixed)
showmarks()
plotit <- function(mylake, sell, llog="y", yrcut=2004.5) {
selall <- lake==mylake & year > yrcut
sul <- unique(ls[selall])
windows()
par(mar=c(4, 4, 1, 1))
plot(year[selall], combPE[selall], type="n", las=1, log=llog, xlab="Year", ylab="Adults")
for(i in seq(sul)) {
sel2 <- sell & lake==mylake & year > yrcut & ls==sul[i]
lines(year[sel2], combPE[sel2], col=i, lty=3)
y <- ifelse(est.source[sel2]=="model", NA, combPE[sel2])
lines(year[sel2], y, col=i, type="o", pch=16, cex=1.2, lwd=2)
}
}
# all non-model time series
selbest <- ls %in% rownames(look2[look2[, "TRUE"]==0, ])
# all model time series
selmodel <- ls %in% rownames(look2[look2[, "FALSE"]==0, ])
# mixed time series
selmixed <- ls %in% rownames(look2[look2[, "TRUE"]!=0 & look2[, "FALSE"]!=0, ])
plotit(3, selbest)
plotit(3, selmodel)
plotit(3, selmixed)
plotit <- function(mylake, sell, llog="y", yrcut=2004.5) {
selall <- lake==mylake & year > yrcut
sul <- unique(ls[selall])
windows()
par(mar=c(4, 4, 1, 1))
plot(year[selall], combPE[selall], type="n", las=1, log=llog, xlab="Year", ylab="Adults")
for(i in seq(sul)) {
sel2 <- sell & lake==mylake & year > yrcut & ls==sul[i]
lines(year[sel2], combPE[sel2], col=i, lty=2)
y <- ifelse(est.source[sel2]=="model", NA, combPE[sel2])
lines(year[sel2], y, col=i, type="o", pch=16, cex=1.2, lwd=2)
}
}
# all non-model time series
selbest <- ls %in% rownames(look2[look2[, "TRUE"]==0, ])
# all model time series
selmodel <- ls %in% rownames(look2[look2[, "FALSE"]==0, ])
# mixed time series
selmixed <- ls %in% rownames(look2[look2[, "TRUE"]!=0 & look2[, "FALSE"]!=0, ])
plotit(3, selbest)
plotit(3, selmodel)
plotit(3, selmixed)
graphics.off()
lss
lls
?brewer
display.brewer.all()
colz <- rep(brewer.pal(12, "Set3"), 5)
plotit <- function(mylake, lss, llog="y", yrcut=2004.5) {
selall <- lake==mylake & year > yrcut
windows()
par(mar=c(4, 4, 1, 1))
plot(year[selall], combPE[selall], type="n", las=1, log=llog, xlab="Year", ylab="Adults")
for(i in seq(lss)) {
sel2 <- sell & lake==mylake & year > yrcut & ls==lss[i]
lines(year[sel2], combPE[sel2], col=colz[i], lty=2)
y <- ifelse(est.source[sel2]=="model", NA, combPE[sel2])
lines(year[sel2], y, col=colz[i], type="o", pch=16, cex=1.2, lwd=2)
}
}
# all non-model time series
lsbest <- rownames(look2[look2[, "TRUE"]==0, ])
# all model time series
lsmodel <- rownames(look2[look2[, "FALSE"]==0, ])
# mixed time series
lsmixed <- rownames(look2[look2[, "TRUE"]!=0 & look2[, "FALSE"]!=0, ])
plotit(3, selbest)
plotit(3, selmodel)
plotit(3, selmixed)
plotit(3, lsbest)
plotit(3, lsmodel)
plotit(3, lsmixed)
colz <- rep(brewer.pal(12, "Set3"), 5)
plotit <- function(mylake, lss, llog="y", yrcut=2004.5) {
selall <- lake==mylake & year > yrcut
windows()
par(mar=c(4, 4, 1, 1))
plot(year[selall], combPE[selall], type="n", las=1, log=llog, xlab="Year", ylab="Adults")
for(i in seq(lss)) {
sel2 <- lake==mylake & year > yrcut & ls==lss[i]
lines(year[sel2], combPE[sel2], col=colz[i], lty=2)
y <- ifelse(est.source[sel2]=="model", NA, combPE[sel2])
lines(year[sel2], y, col=colz[i], type="o", pch=16, cex=1.2, lwd=2)
}
}
# all non-model time series
lsbest <- rownames(look2[look2[, "TRUE"]==0, ])
# all model time series
lsmodel <- rownames(look2[look2[, "FALSE"]==0, ])
# mixed time series
lsmixed <- rownames(look2[look2[, "TRUE"]!=0 & look2[, "FALSE"]!=0, ])
plotit(3, lsbest)
plotit(3, lsmodel)
plotit(3, lsmixed)
lsmodel
plotit(3, lsmodel)
mylake=3
lss=lsmodel
llog="y"
yrcut=2004.5
selall <- lake==mylake & year > yrcut
windows()
par(mar=c(4, 4, 1, 1))
plot(year[selall], combPE[selall], type="n", las=1, log=llog, xlab="Year", ylab="Adults")
seq(lss)
length(colz)
181/12
colz <- rep(brewer.pal(12, "Set3"), 25)
plotit <- function(mylake, lss, llog="y", yrcut=2004.5) {
selall <- lake==mylake & year > yrcut
windows()
par(mar=c(4, 4, 1, 1))
plot(year[selall], combPE[selall], type="n", las=1, log=llog, xlab="Year", ylab="Adults")
for(i in seq(lss)) {
sel2 <- lake==mylake & year > yrcut & ls==lss[i]
lines(year[sel2], combPE[sel2], col=colz[i], lty=2)
y <- ifelse(est.source[sel2]=="model", NA, combPE[sel2])
lines(year[sel2], y, col=colz[i], type="o", pch=16, cex=1.2, lwd=2)
}
}
# all non-model time series
lsbest <- rownames(look2[look2[, "TRUE"]==0, ])
# all model time series
lsmodel <- rownames(look2[look2[, "FALSE"]==0, ])
# mixed time series
lsmixed <- rownames(look2[look2[, "TRUE"]!=0 & look2[, "FALSE"]!=0, ])
plotit(3, lsbest)
plotit(3, lsmodel)
plotit(3, lsmixed)
colz <- rep(brewer.pal(12, "Set1"), 50)
plotit <- function(mylake, lss, llog="y", yrcut=2004.5) {
selall <- lake==mylake & year > yrcut
windows()
par(mar=c(4, 4, 1, 1))
plot(year[selall], combPE[selall], type="n", las=1, log=llog, xlab="Year", ylab="Adults")
for(i in seq(lss)) {
sel2 <- lake==mylake & year > yrcut & ls==lss[i]
lines(year[sel2], combPE[sel2], col=colz[i], lty=2)
y <- ifelse(est.source[sel2]=="model", NA, combPE[sel2])
lines(year[sel2], y, col=colz[i], type="o", pch=16, cex=1.2, lwd=2)
}
}
mylake=3
lss=lsmodel
llog="y"
yrcut=2004.5
# all non-model time series
lsbest <- rownames(look2[look2[, "TRUE"]==0, ])
# all model time series
lsmodel <- rownames(look2[look2[, "FALSE"]==0, ])
# mixed time series
lsmixed <- rownames(look2[look2[, "TRUE"]!=0 & look2[, "FALSE"]!=0, ])
plotit(3, lsbest)
plotit(3, lsmodel)
plotit(3, lsmixed)
colz <- rep(brewer.pal(12, "Dark2"), 50)
plotit <- function(mylake, lss, llog="y", yrcut=2004.5) {
selall <- lake==mylake & year > yrcut
windows()
par(mar=c(4, 4, 1, 1))
plot(year[selall], combPE[selall], type="n", las=1, log=llog, xlab="Year", ylab="Adults")
for(i in seq(lss)) {
sel2 <- lake==mylake & year > yrcut & ls==lss[i]
lines(year[sel2], combPE[sel2], col=colz[i], lty=2)
y <- ifelse(est.source[sel2]=="model", NA, combPE[sel2])
lines(year[sel2], y, col=colz[i], type="o", pch=16, cex=1.2, lwd=2)
}
}
mylake=3
lss=lsmodel
llog="y"
yrcut=2004.5
# all non-model time series
lsbest <- rownames(look2[look2[, "TRUE"]==0, ])
# all model time series
lsmodel <- rownames(look2[look2[, "FALSE"]==0, ])
# mixed time series
lsmixed <- rownames(look2[look2[, "TRUE"]!=0 & look2[, "FALSE"]!=0, ])
plotit(3, lsbest)
plotit(3, lsmodel)
plotit(3, lsmixed)
length(map5)
dim(map5)
map5
windows(h=5, w=9)
par(mar=rep(0, 4))
map(xlim=range(map5$x, na.rm=T), ylim=range(map5$y, na.rm=T), col=NA, mar=rep(0, 4))
lines(map5$x, map5$y, col="darkgray", lwd=0.5)
head(dat)
sel <- est.source=="model"
points(long[sel], lat[sel], col=colz[1], cex=2)
sel <- est.source=="model"
windows(h=5, w=9)
par(mar=rep(0, 4))
map(xlim=range(map5$x, na.rm=T), ylim=range(map5$y, na.rm=T), col=NA, mar=rep(0, 4))
lines(map5$x, map5$y, col="darkgray", lwd=0.5)
points(long[sel], lat[sel], col=colz[1], cex=2)
windows(h=5, w=9)
par(mar=rep(0, 4))
map(xlim=range(map5$x, na.rm=T), ylim=range(map5$y, na.rm=T), col=NA, mar=rep(0, 4))
lines(map5$x, map5$y, col="darkgray", lwd=0.5)
points(long[!sel], lat[!sel], col=colz[2], cex=3, lwd=2)
sel <- est.source=="model"
windows(h=6, w=10)
par(mar=rep(0, 4))
map(xlim=range(map5$x, na.rm=T), ylim=range(map5$y, na.rm=T), col=NA, mar=rep(0, 4))
lines(map5$x, map5$y, col="darkgray", lwd=0.5)
points(long[sel], lat[sel], col=colz[1], cex=2)
windows(h=6, w=10)
par(mar=rep(0, 4))
map(xlim=range(map5$x, na.rm=T), ylim=range(map5$y, na.rm=T), col=NA, mar=rep(0, 4))
lines(map5$x, map5$y, col="darkgray", lwd=0.5)
points(long[!sel], lat[!sel], col=colz[2], cex=3, lwd=2)
selm <- year==2014 & est.source=="model"
selo <- year==2014 & est.source!="model"
windows(h=6, w=10)
par(mar=rep(0, 4))
map(xlim=range(map5$x, na.rm=T), ylim=range(map5$y, na.rm=T), col=NA, mar=rep(0, 4))
lines(map5$x, map5$y, col="darkgray", lwd=0.5)
points(long[selm], lat[selm], col=colz[1], cex=2)
windows(h=6, w=10)
par(mar=rep(0, 4))
map(xlim=range(map5$x, na.rm=T), ylim=range(map5$y, na.rm=T), col=NA, mar=rep(0, 4))
lines(map5$x, map5$y, col="darkgray", lwd=0.5)
points(long[selo], lat[selo], col=colz[2], cex=3, lwd=2)
legend("topright", cex=c(1, 3), lwd=c(1, 2), col=coz[1:2], pch=1)
legend("topright", c("Untrapped", "Trapped"), cex=c(1, 3), lwd=c(1, 2), col=coz[1:2], pch=1)
legend("topright", c("Untrapped", "Trapped"), cex=c(1, 3), lwd=c(1, 2), col=colz[1:2], pch=1)
par(mar=rep(0, 4))
map(xlim=range(map5$x, na.rm=T), ylim=range(map5$y, na.rm=T), col=NA, mar=rep(0, 4))
lines(map5$x, map5$y, col="darkgray", lwd=0.5)
points(long[selo], lat[selo], col=colz[2], cex=3, lwd=2)
legend("topright", c("Untrapped", "Trapped"), pt.cex=c(1, 3), lwd=c(1, 2), col=colz[1:2], pch=1)
par(mar=rep(0, 4))
map(xlim=range(map5$x, na.rm=T), ylim=range(map5$y, na.rm=T), col=NA, mar=rep(0, 4))
lines(map5$x, map5$y, col="darkgray", lwd=0.5)
points(long[selo], lat[selo], col=colz[2], cex=3, lwd=2)
legend("right", c("Untrapped", "Trapped"), pt.cex=c(1, 3), lwd=c(1, 2), col=colz[1:2], pch=1, byt="n")
par(mar=rep(0, 4))
map(xlim=range(map5$x, na.rm=T), ylim=range(map5$y, na.rm=T), col=NA, mar=rep(0, 4))
lines(map5$x, map5$y, col="darkgray", lwd=0.5)
points(long[selo], lat[selo], col=colz[2], cex=3, lwd=2)
legend("right", c("Untrapped", "Trapped"), pt.cex=c(1, 3), lwd=c(1, 2), col=colz[1:2], pch=1, bty="n")
?legend
par(mar=rep(0, 4))
map(xlim=range(map5$x, na.rm=T), ylim=range(map5$y, na.rm=T), col=NA, mar=rep(0, 4))
lines(map5$x, map5$y, col="darkgray", lwd=0.5)
points(long[selo], lat[selo], col=colz[2], cex=3, lwd=2)
legend("right", c("Untrapped", "Trapped"), pt.cex=c(2, 3), pt.lwd=c(1, 2), col=colz[1:2], pch=1, bty="n")
plotit <- function(mylake, lss, llog="y", yrcut=2004.5) {
selall <- lake==mylake & year > yrcut
windows(h=6, w=3)
par(mar=c(4, 4, 1, 1))
plot(year[selall], combPE[selall], type="n", las=1, log=llog, xlab="Year", ylab="Adults")
for(i in seq(lss)) {
sel2 <- lake==mylake & year > yrcut & ls==lss[i]
lines(year[sel2], combPE[sel2], col=colz[i], lty=2)
y <- ifelse(est.source[sel2]=="model", NA, combPE[sel2])
lines(year[sel2], y, col=colz[i], type="o", pch=16, cex=1.2, lwd=2)
}
}
# all non-model time series
lsbest <- rownames(look2[look2[, "TRUE"]==0, ])
# all model time series
lsmodel <- rownames(look2[look2[, "FALSE"]==0, ])
# mixed time series
lsmixed <- rownames(look2[look2[, "TRUE"]!=0 & look2[, "FALSE"]!=0, ])
plotit(3, lsbest)
plotit(3, lsmodel)
plotit(3, lsmixed)
plotit <- function(mylake, lss, llog="y", yrcut=2004.5) {
selall <- lake==mylake & year > yrcut
windows(h=5.5, w=3.3)
par(mar=c(4, 4, 1, 1))
plot(year[selall], combPE[selall], type="n", las=1, log=llog, xlab="Year", ylab="Adults")
for(i in seq(lss)) {
sel2 <- lake==mylake & year > yrcut & ls==lss[i]
lines(year[sel2], combPE[sel2], col=colz[i], lty=2)
y <- ifelse(est.source[sel2]=="model", NA, combPE[sel2])
lines(year[sel2], y, col=colz[i], type="o", pch=16, cex=1.2, lwd=2)
}
}
# all non-model time series
lsbest <- rownames(look2[look2[, "TRUE"]==0, ])
# all model time series
lsmodel <- rownames(look2[look2[, "FALSE"]==0, ])
# mixed time series
lsmixed <- rownames(look2[look2[, "TRUE"]!=0 & look2[, "FALSE"]!=0, ])
plotit(3, lsbest)
plotit(3, lsmodel)
plotit(3, lsmixed)
graphics.off()
plotit(3, lsbest, "")
plotit(3, lsmodel, "")
plotit(3, lsmixed, "")
plotit <- function(mylake, lss, llog="y", yrcut=2004.5) {
selall <- lake==mylake & year > yrcut
windows(h=5.5, w=3.3)
par(mar=c(4, 4, 1, 1))
if(llog=="y") {
fac <- 1
ylabb <- "Adults"
} else {
fac <- 1000
ylabb <- "Adults  (thousands)"
}
plot(year[selall], combPE[selall]/fac, type="n", las=1, log=llog, xlab="Year", ylab=ylabb)
for(i in seq(lss)) {
sel2 <- lake==mylake & year > yrcut & ls==lss[i]
lines(year[sel2], combPE[sel2]/fac, col=colz[i], lty=2)
y <- ifelse(est.source[sel2]=="model", NA, combPE[sel2])
lines(year[sel2], y/fac, col=colz[i], type="o", pch=16, cex=1.2, lwd=2)
}
}
# all non-model time series
lsbest <- rownames(look2[look2[, "TRUE"]==0, ])
# all model time series
lsmodel <- rownames(look2[look2[, "FALSE"]==0, ])
# mixed time series
lsmixed <- rownames(look2[look2[, "TRUE"]!=0 & look2[, "FALSE"]!=0, ])
plotit(3, lsbest)
plotit(3, lsmodel)
plotit(3, lsmixed)
plotit(3, lsbest, "")
plotit(3, lsmodel, "")
plotit(3, lsmixed, "")
plotit(3, lsmodel, "")
plotit(3, lsmodel)
locator()
dat[lake==3 & year==2008 & combPE > 6000, 1:10]
dat[lake==3 & year==2008 & combPE > 6000,]
locator()
dat[lake==3 & year==2008 & combPE > 6000,]
locator()
dat[lake==3 & year>2004.5 & strname=="Garden", ]
graphics.off()
plotit(1, lsbest)
plotit(1, lsmodel)
plotit(1, lsmixed)
plotit(1, lsbest, "")
plotit(1, lsmodel, "")
plotit(1, lsmixed, "")
graphics.off()
q()
windows(h=6, w=10)
par(mar=rep(0, 4))
map(xlim=range(map5$x, na.rm=T), ylim=range(map5$y, na.rm=T), col=NA, mar=rep(0, 4))
lines(map5$x, map5$y, col="darkgray", lwd=0.5)
points(long[selm], lat[selm], col=colz[1], cex=2, lwd=2)
# C:\JVA\GLFC\CLC\CLCAdultIndex.r
{ # functions
# the following seven plot.table related functions are from the Systematic Investor Toolbox
# load Systematic Investor Toolbox
# require(RCurl)
# sit = getURLContent("https://github.com/systematicinvestor/SIT/raw/master/sit.gz", binary=TRUE, followlocation=TRUE, ssl.verifypeer=FALSE)
# con = gzcon(rawConnection(sit, "rb"))
# source(con)
# close(con)
draw.cell <- function(title, r, c, text.cex = 1, bg.col = 'white', frame.cell = T) {
if(!frame.cell) bcol = bg.col else bcol = 'black'
rect((2*(c - 1) + .5), -(r - .5), (2*c + .5), -(r + .5), col = bg.col, border = bcol)
if( c == 1) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else if( r == 1 ) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else {
text((2*c + .5), -r, title, adj = 1, cex = text.cex)
}
}
plot.table.helper.auto.adjust.cex <- function(temp.table, keep.all.same.cex = FALSE) {
nr = nrow(temp.table)
nc = ncol(temp.table)
all.xrange = diff(par()$usr[1:2]) / nc
xrange = matrix( strwidth(paste('  ', temp.table), units = 'user', cex = 1), nc = nc)
all.yrange = diff(par()$usr[3:4]) / nr
yrange = matrix( 5/3 * strheight(temp.table, units = 'user', cex = 1), nc = nc)
plot.matrix.cex = pmin( round(all.yrange / yrange, 2) , round(all.xrange / xrange, 2) )
header.col.cex = min(plot.matrix.cex[1,-1])
header.row.cex = min(plot.matrix.cex[-1,1])
title.cex = plot.matrix.cex[1, 1]
data.cex = min(plot.matrix.cex[-1, -1])
if ( keep.all.same.cex ) {
plot.matrix.cex[] = min(plot.matrix.cex)
} else {
plot.matrix.cex[1,-1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,-1]= min(c(header.col.cex, header.row.cex, data.cex))
plot.matrix.cex[1,1]= min(c(header.col.cex, header.row.cex, data.cex, title.cex))
plot.matrix.cex[1,-1] = min(c(header.col.cex))
plot.matrix.cex[-1,1] = min(c(header.row.cex))
plot.matrix.cex[-1,-1]= min(c(data.cex))
plot.matrix.cex[1,1]= min(c(title.cex))
}
return(plot.matrix.cex)
}
make.table <- function(nr, nc) {
savepar = par(mar = rep(1, 4))
plot(c(0.5, nc*2 + 0.5), c(-0.5, -(nr + 0.5)), xaxs = 'i', yaxs = 'i',
type = 'n', xlab = '', ylab = '', axes = FALSE)
savepar
}
trim <- function(s) {
s = sub(pattern = '^ +', replacement = '', x = s)
s = sub(pattern = ' +$', replacement = '', x = s)
return(s)
}
plot.table.param <- function(plot.matrix, smain = '', plot.matrix.cex, plot.matrix_bg.col, frame.cell = T, keep.all.same.cex = FALSE) {
n = nrow(plot.matrix)
pages = unique(c(seq(0, n, by = 120), n))
for(p in 1:(length(pages)-1)) {
rindex = (pages[p]+1) : pages[p+1]
temp.table = matrix('', nr = length(rindex)+1, nc = ncol(plot.matrix)+1)
temp.table[-1, -1] = plot.matrix[rindex,]
temp.table[1, -1] = colnames(plot.matrix)
temp.table[-1, 1] = rownames(plot.matrix)[rindex]
temp.table[1, 1] = smain
nr = nrow(temp.table)
nc = ncol(temp.table)
par(mar = c(0, 0, 0, 0), cex = 0.5)
oldpar = make.table(nr, nc)
text.cex = plot.matrix.cex[c(1, 1 + rindex), ]
text.cex = plot.table.helper.auto.adjust.cex(temp.table, keep.all.same.cex)
bg.col = plot.matrix_bg.col[c(1, 1 + rindex), ]
for(r in 1:nr) {
for(c in 1:nc) {
draw.cell( paste('', temp.table[r,c], '', sep=' '), r, c,
text.cex = text.cex[r,c], bg.col = bg.col[r,c], frame.cell = frame.cell)
}}
}
}
plot.table <- function(plot.matrix, smain="", text.cex=1, frame.cell=TRUE, highlight=FALSE, colorbar=FALSE, keep_all.same.cex=FALSE) {
if( is.null(rownames(plot.matrix)) & is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
if( ncol(temp.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[-1, -1, drop = FALSE]
colnames(plot.matrix) = temp.matrix[1, -1]
rownames(plot.matrix) = temp.matrix[-1, 1]
smain = temp.matrix[1, 1]
} else if( is.null(rownames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( ncol(plot.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[, -1, drop = FALSE]
colnames(plot.matrix) = colnames(temp.matrix)[-1]
rownames(plot.matrix) = temp.matrix[,1]
smain = colnames(temp.matrix)[1]
} else if( is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
plot.matrix = temp.matrix[-1, , drop = FALSE]
rownames(plot.matrix) = rownames(temp.matrix)[-1]
colnames(plot.matrix) = temp.matrix[1, ]
smain = rownames(temp.matrix)[1]
}
plot.matrix[which(trim(plot.matrix) == "NA")] = ""
plot.matrix[which(trim(plot.matrix) == "NA%")] = ""
plot.matrix[which(is.na(plot.matrix))] = ""
nr = nrow(plot.matrix) + 1
nc = ncol(plot.matrix) + 1
is_highlight = TRUE
if(is.logical(highlight)) {
is_highlight = highlight
if(highlight) highlight = plot.table.helper.color(plot.matrix)
}
if(!is_highlight) {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[seq(1, nr, 2), ] = "yellow"
plot.matrix_bg.col[1,] = "gray";
plot.table.param( plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
} else {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[1,] = "gray"
plot.matrix_bg.col[2:nr,2:nc] = highlight
plot.table.param(plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
}
}
plot.table.helper.color <- function (temp) {
temp = matrix(as.double(gsub("[%,$]", "", temp)), nrow(temp), ncol(temp))
highlight = as.vector(temp)
cols = rep(NA, length(highlight))
ncols = length(highlight[!is.na(highlight)])
cols[1:ncols] = rev(rainbow(ncols, start=0.5/6, end=3.5/6))
o = sort.list(highlight, na.last = TRUE, decreasing = FALSE)
o1 = sort.list(o, na.last = TRUE, decreasing = FALSE)
highlight = matrix(cols[o1], nrow = nrow(temp))
highlight[is.na(temp)] = NA
return(highlight)
}
ModelEst <- function(fit, df) {
# derive regression estimates from log(y) fit
mse <- rev(as.matrix(summary(fit)[[1]])[, "Mean Sq"])[1]
plpe <- predict(fit, newdata=df, se.fit=T)
m <- plpe$fit
v <- plpe$se.fit^2 + mse
exp(m + v/2)
}
myrange <- function(x) {
if(all(is.na(x))) r <- c(NA, NA) else r <- range(x, na.rm=TRUE)
return(r)
}
jackindex <- function(m) {
# m is a matrix of numbers (stream PEs) with observations (years) as rows and individuals (streams) as columns
if(any(is.na(m))) stop("The input matrix may not have any missing values.")
# calculate the index as the sum of the columns for each row
rowsum <- apply(m, 1, sum)
# calculate the mean of the index
avgind <- mean(rowsum)
# recalculate the index, leaving out one individual at a time
loo <- apply(m, 2, function(column) (rowsum - column))
# rescale the loo index, relative to mean
looscaled <- apply(loo, 2, function(x) x/mean(x))
# convert to original scale
looscaled2 <- looscaled * avgind
# calculate range
ranges <- t(apply(looscaled2, 1, range))
cbind(index=rowsum, lo=ranges[, 1], hi=ranges[, 2])
}
# selstreams <- index.streams[[1]] 
# allstreamdf <- dat
# alllakedf <- lk 
# min.nmr=2 
# show=FALSE
index.est <- function(selstreams, allstreamdf, alllakedf, min.nmr=2, show=FALSE) {
# INDEX OF ADULT SEA LAMPREY ABUNDANCE
### INPUTS
# selstreams = vector of stream ids, e.g., 1.064 (lake + strcode/1000)
# allstreamdf = data frame of mark-recap estimates for all streams, with vars:  year lake ls Emr CVmr
# alllakedf = data frame of lake-wide PEs from Mullett et al. (2003) spawner model with vars:  lake year PE
# min.nmr = minimum number of mark-recapture estimates needed in a year to generate an index, default 2
# show = print out a brief summary of the results, default FALSE
### OUTPUTS
# indfit = simple model used to predict missing mark-recap estimates
# streamdf = original allstreamdf, subsetted by selstreams, with estimates for missing mark-recaps
# indxdf = original alllakedf, subsetted by lake, with annual index, including raw (indxraw), kept based on min.nmr (indxkeep, indxkeep.lo, indxkeep.hi)
# scaleup = conversion factor used to scale up annual index to spawner model PE
streamdf <- allstreamdf[allstreamdf$ls %in% selstreams, ]
# error checks
check1 <- var(streamdf$lake)
if(is.na(check1) | is.null(check1)) stop("Either no streams selected or critical data missing.") else if(check1 > 0) stop("Selected streams should be only from ONE lake.")
if(any(is.na(match(c("year", "lake", "ls", "Emr", "CVmr"), names(allstreamdf))))) stop("allstreamdf must include these variables: year lake ls Emr CVmr.")
if(any(is.na(match(c("year", "lake", "PE"), names(alllakedf))))) stop("alllakedf must include these variables: lake year PE.")
# fill in missing mark-recap data
indfit <- aov(log(Emr) ~ as.factor(ls) + as.factor(year), data=streamdf, weights=1/CVmr^2)
# figure out estimable years (those with at least 1 m-r estimate)
n.mr <- tapply(!is.na(streamdf$Emr), streamdf$year, sum)
eyrs <- as.numeric(names(n.mr)[n.mr > 0.5])
estimable <- streamdf$year %in% eyrs
streamdf$Pmr <- NA
streamdf$Pmr[estimable] <- ModelEst(fit=indfit, df=streamdf[estimable, ])
streamdf$COMBmr <- ifelse(is.na(streamdf$Emr), streamdf$Pmr, streamdf$Emr)
# annual index (sum across streams)
indxdf <- aggregate(COMBmr ~ year + lake, streamdf, sum, na.rm=TRUE, na.action=na.pass)
names(indxdf)[names(indxdf)=="COMBmr"] <- "indxraw"
indxdf$indxraw[indxdf$indxraw==0] <- NA
# only keep lake-wide index for years with at least min.nmr mark-recap estimates
indxdf$n.mr <- n.mr
indxdf$indxkeep <- ifelse(indxdf$n.mr > (min.nmr - 0.5), indxdf$indxraw, NA)
indxdf$indxkeep.lo <- NA
indxdf$indxkeep.hi <- NA
# matrix of stream estimates (rows = years, columns = index streams)
streamests <- with(streamdf, tapply(COMBmr, list(year, ls), mean))
# selection of only those streams with a keepable index
selkeep <- !is.na(indxdf$indxkeep)
jack <- jackindex(streamests[selkeep, ])
indxdf$indxkeep.lo[selkeep] <- jack[, "lo"]
indxdf$indxkeep.hi[selkeep] <- jack[, "hi"]
# scale up the index to the spawner model PE
lk1 <- lk[lk$lake == streamdf$lake[1], ]
indxdf2 <- merge(lk1, indxdf, all=TRUE)
scaleup <- median(indxdf2$PE / indxdf2$indxkeep, na.rm=TRUE)
if(show) {
cat("\nindfit\n")
print(summary(indfit))
cat("\nstreamdf\n")
print(tail(streamdf[, c("lake", "year", "ls", "Emr", "CVmr", "Pmr", "COMBmr")]))
cat("\nscaleup\n")
print(scaleup)
cat("\nindxdf\n")
print(tail(indxdf[, c("lake", "year", "n.mr", "indxraw", "indxkeep", "indxkeep.lo", "indxkeep.hi")]))
}
list(indfit=indfit, streamdf=streamdf, scaleup=scaleup, indxdf=indxdf)
}
calctarg <- function(lakenum, adults, year, targyears, adjust=c(1, 1, 0.25, 1, 1)) {
# lakenum = vector of lake numbers (1-5)
# adults = vector of lakewide adult sea lamprey estimates
# year = vector of years
# targyears = list (length 5) of selected years from which to calculate targets
# lake huron target is 25% of
targets <- data.frame(lake=1:5, target=rep(NA, 5), lo=rep(NA, 5), hi=rep(NA, 5))
for(i in 1:5) {
pick5 <- adults[lakenum==i & is.element(year, targyears[[i]]) & !is.na(adults)]
if(length(pick5) > 0) {
targets$target[i] <- mean(pick5)
n <- length(pick5)
ci <- qnorm(1 - 0.05/2) * sqrt(var(pick5)) / sqrt(n)
targets[i, c("lo", "hi")] <- mean(pick5) + c(-1, 1)*ci# using z dist (known variance)
targets[i, c("target", "lo", "hi")] <- adjust[i]*targets[i, c("target", "lo", "hi")]
} else {
targets[i, c("target", "lo", "hi")] <- c(NA, NA, NA)
}
}
targets
}
}
# bring in lake-wide spawner data
lk <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/LakePEdynamic.csv", as.is=T)
# bring in stream-specific data
dat <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/StreamPEdynamicALLCOLS.csv", as.is=T)
dat$ls <- dat$lscode
attach(dat)
colz <- rep(brewer.pal(12, "Dark2"), 50)
selm <- year==2014 & est.source=="model"
selo <- year==2014 & est.source!="model"
windows(h=6, w=10)
par(mar=rep(0, 4))
map(xlim=range(map5$x, na.rm=T), ylim=range(map5$y, na.rm=T), col=NA, mar=rep(0, 4))
lines(map5$x, map5$y, col="darkgray", lwd=0.5)
points(long[selm], lat[selm], col=colz[1], cex=2, lwd=2)
# C:\JVA\GLFC\CLC\CLCAdultIndex.r
{ # functions
# the following seven plot.table related functions are from the Systematic Investor Toolbox
# load Systematic Investor Toolbox
# require(RCurl)
# sit = getURLContent("https://github.com/systematicinvestor/SIT/raw/master/sit.gz", binary=TRUE, followlocation=TRUE, ssl.verifypeer=FALSE)
# con = gzcon(rawConnection(sit, "rb"))
# source(con)
# close(con)
draw.cell <- function(title, r, c, text.cex = 1, bg.col = 'white', frame.cell = T) {
if(!frame.cell) bcol = bg.col else bcol = 'black'
rect((2*(c - 1) + .5), -(r - .5), (2*c + .5), -(r + .5), col = bg.col, border = bcol)
if( c == 1) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else if( r == 1 ) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else {
text((2*c + .5), -r, title, adj = 1, cex = text.cex)
}
}
plot.table.helper.auto.adjust.cex <- function(temp.table, keep.all.same.cex = FALSE) {
nr = nrow(temp.table)
nc = ncol(temp.table)
all.xrange = diff(par()$usr[1:2]) / nc
xrange = matrix( strwidth(paste('  ', temp.table), units = 'user', cex = 1), nc = nc)
all.yrange = diff(par()$usr[3:4]) / nr
yrange = matrix( 5/3 * strheight(temp.table, units = 'user', cex = 1), nc = nc)
plot.matrix.cex = pmin( round(all.yrange / yrange, 2) , round(all.xrange / xrange, 2) )
header.col.cex = min(plot.matrix.cex[1,-1])
header.row.cex = min(plot.matrix.cex[-1,1])
title.cex = plot.matrix.cex[1, 1]
data.cex = min(plot.matrix.cex[-1, -1])
if ( keep.all.same.cex ) {
plot.matrix.cex[] = min(plot.matrix.cex)
} else {
plot.matrix.cex[1,-1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,-1]= min(c(header.col.cex, header.row.cex, data.cex))
plot.matrix.cex[1,1]= min(c(header.col.cex, header.row.cex, data.cex, title.cex))
plot.matrix.cex[1,-1] = min(c(header.col.cex))
plot.matrix.cex[-1,1] = min(c(header.row.cex))
plot.matrix.cex[-1,-1]= min(c(data.cex))
plot.matrix.cex[1,1]= min(c(title.cex))
}
return(plot.matrix.cex)
}
make.table <- function(nr, nc) {
savepar = par(mar = rep(1, 4))
plot(c(0.5, nc*2 + 0.5), c(-0.5, -(nr + 0.5)), xaxs = 'i', yaxs = 'i',
type = 'n', xlab = '', ylab = '', axes = FALSE)
savepar
}
trim <- function(s) {
s = sub(pattern = '^ +', replacement = '', x = s)
s = sub(pattern = ' +$', replacement = '', x = s)
return(s)
}
plot.table.param <- function(plot.matrix, smain = '', plot.matrix.cex, plot.matrix_bg.col, frame.cell = T, keep.all.same.cex = FALSE) {
n = nrow(plot.matrix)
pages = unique(c(seq(0, n, by = 120), n))
for(p in 1:(length(pages)-1)) {
rindex = (pages[p]+1) : pages[p+1]
temp.table = matrix('', nr = length(rindex)+1, nc = ncol(plot.matrix)+1)
temp.table[-1, -1] = plot.matrix[rindex,]
temp.table[1, -1] = colnames(plot.matrix)
temp.table[-1, 1] = rownames(plot.matrix)[rindex]
temp.table[1, 1] = smain
nr = nrow(temp.table)
nc = ncol(temp.table)
par(mar = c(0, 0, 0, 0), cex = 0.5)
oldpar = make.table(nr, nc)
text.cex = plot.matrix.cex[c(1, 1 + rindex), ]
text.cex = plot.table.helper.auto.adjust.cex(temp.table, keep.all.same.cex)
bg.col = plot.matrix_bg.col[c(1, 1 + rindex), ]
for(r in 1:nr) {
for(c in 1:nc) {
draw.cell( paste('', temp.table[r,c], '', sep=' '), r, c,
text.cex = text.cex[r,c], bg.col = bg.col[r,c], frame.cell = frame.cell)
}}
}
}
plot.table <- function(plot.matrix, smain="", text.cex=1, frame.cell=TRUE, highlight=FALSE, colorbar=FALSE, keep_all.same.cex=FALSE) {
if( is.null(rownames(plot.matrix)) & is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
if( ncol(temp.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[-1, -1, drop = FALSE]
colnames(plot.matrix) = temp.matrix[1, -1]
rownames(plot.matrix) = temp.matrix[-1, 1]
smain = temp.matrix[1, 1]
} else if( is.null(rownames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( ncol(plot.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[, -1, drop = FALSE]
colnames(plot.matrix) = colnames(temp.matrix)[-1]
rownames(plot.matrix) = temp.matrix[,1]
smain = colnames(temp.matrix)[1]
} else if( is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
plot.matrix = temp.matrix[-1, , drop = FALSE]
rownames(plot.matrix) = rownames(temp.matrix)[-1]
colnames(plot.matrix) = temp.matrix[1, ]
smain = rownames(temp.matrix)[1]
}
plot.matrix[which(trim(plot.matrix) == "NA")] = ""
plot.matrix[which(trim(plot.matrix) == "NA%")] = ""
plot.matrix[which(is.na(plot.matrix))] = ""
nr = nrow(plot.matrix) + 1
nc = ncol(plot.matrix) + 1
is_highlight = TRUE
if(is.logical(highlight)) {
is_highlight = highlight
if(highlight) highlight = plot.table.helper.color(plot.matrix)
}
if(!is_highlight) {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[seq(1, nr, 2), ] = "yellow"
plot.matrix_bg.col[1,] = "gray";
plot.table.param( plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
} else {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[1,] = "gray"
plot.matrix_bg.col[2:nr,2:nc] = highlight
plot.table.param(plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
}
}
plot.table.helper.color <- function (temp) {
temp = matrix(as.double(gsub("[%,$]", "", temp)), nrow(temp), ncol(temp))
highlight = as.vector(temp)
cols = rep(NA, length(highlight))
ncols = length(highlight[!is.na(highlight)])
cols[1:ncols] = rev(rainbow(ncols, start=0.5/6, end=3.5/6))
o = sort.list(highlight, na.last = TRUE, decreasing = FALSE)
o1 = sort.list(o, na.last = TRUE, decreasing = FALSE)
highlight = matrix(cols[o1], nrow = nrow(temp))
highlight[is.na(temp)] = NA
return(highlight)
}
ModelEst <- function(fit, df) {
# derive regression estimates from log(y) fit
mse <- rev(as.matrix(summary(fit)[[1]])[, "Mean Sq"])[1]
plpe <- predict(fit, newdata=df, se.fit=T)
m <- plpe$fit
v <- plpe$se.fit^2 + mse
exp(m + v/2)
}
myrange <- function(x) {
if(all(is.na(x))) r <- c(NA, NA) else r <- range(x, na.rm=TRUE)
return(r)
}
jackindex <- function(m) {
# m is a matrix of numbers (stream PEs) with observations (years) as rows and individuals (streams) as columns
if(any(is.na(m))) stop("The input matrix may not have any missing values.")
# calculate the index as the sum of the columns for each row
rowsum <- apply(m, 1, sum)
# calculate the mean of the index
avgind <- mean(rowsum)
# recalculate the index, leaving out one individual at a time
loo <- apply(m, 2, function(column) (rowsum - column))
# rescale the loo index, relative to mean
looscaled <- apply(loo, 2, function(x) x/mean(x))
# convert to original scale
looscaled2 <- looscaled * avgind
# calculate range
ranges <- t(apply(looscaled2, 1, range))
cbind(index=rowsum, lo=ranges[, 1], hi=ranges[, 2])
}
# selstreams <- index.streams[[1]] 
# allstreamdf <- dat
# alllakedf <- lk 
# min.nmr=2 
# show=FALSE
index.est <- function(selstreams, allstreamdf, alllakedf, min.nmr=2, show=FALSE) {
# INDEX OF ADULT SEA LAMPREY ABUNDANCE
### INPUTS
# selstreams = vector of stream ids, e.g., 1.064 (lake + strcode/1000)
# allstreamdf = data frame of mark-recap estimates for all streams, with vars:  year lake ls Emr CVmr
# alllakedf = data frame of lake-wide PEs from Mullett et al. (2003) spawner model with vars:  lake year PE
# min.nmr = minimum number of mark-recapture estimates needed in a year to generate an index, default 2
# show = print out a brief summary of the results, default FALSE
### OUTPUTS
# indfit = simple model used to predict missing mark-recap estimates
# streamdf = original allstreamdf, subsetted by selstreams, with estimates for missing mark-recaps
# indxdf = original alllakedf, subsetted by lake, with annual index, including raw (indxraw), kept based on min.nmr (indxkeep, indxkeep.lo, indxkeep.hi)
# scaleup = conversion factor used to scale up annual index to spawner model PE
streamdf <- allstreamdf[allstreamdf$ls %in% selstreams, ]
# error checks
check1 <- var(streamdf$lake)
if(is.na(check1) | is.null(check1)) stop("Either no streams selected or critical data missing.") else if(check1 > 0) stop("Selected streams should be only from ONE lake.")
if(any(is.na(match(c("year", "lake", "ls", "Emr", "CVmr"), names(allstreamdf))))) stop("allstreamdf must include these variables: year lake ls Emr CVmr.")
if(any(is.na(match(c("year", "lake", "PE"), names(alllakedf))))) stop("alllakedf must include these variables: lake year PE.")
# fill in missing mark-recap data
indfit <- aov(log(Emr) ~ as.factor(ls) + as.factor(year), data=streamdf, weights=1/CVmr^2)
# figure out estimable years (those with at least 1 m-r estimate)
n.mr <- tapply(!is.na(streamdf$Emr), streamdf$year, sum)
eyrs <- as.numeric(names(n.mr)[n.mr > 0.5])
estimable <- streamdf$year %in% eyrs
streamdf$Pmr <- NA
streamdf$Pmr[estimable] <- ModelEst(fit=indfit, df=streamdf[estimable, ])
streamdf$COMBmr <- ifelse(is.na(streamdf$Emr), streamdf$Pmr, streamdf$Emr)
# annual index (sum across streams)
indxdf <- aggregate(COMBmr ~ year + lake, streamdf, sum, na.rm=TRUE, na.action=na.pass)
names(indxdf)[names(indxdf)=="COMBmr"] <- "indxraw"
indxdf$indxraw[indxdf$indxraw==0] <- NA
# only keep lake-wide index for years with at least min.nmr mark-recap estimates
indxdf$n.mr <- n.mr
indxdf$indxkeep <- ifelse(indxdf$n.mr > (min.nmr - 0.5), indxdf$indxraw, NA)
indxdf$indxkeep.lo <- NA
indxdf$indxkeep.hi <- NA
# matrix of stream estimates (rows = years, columns = index streams)
streamests <- with(streamdf, tapply(COMBmr, list(year, ls), mean))
# selection of only those streams with a keepable index
selkeep <- !is.na(indxdf$indxkeep)
jack <- jackindex(streamests[selkeep, ])
indxdf$indxkeep.lo[selkeep] <- jack[, "lo"]
indxdf$indxkeep.hi[selkeep] <- jack[, "hi"]
# scale up the index to the spawner model PE
lk1 <- lk[lk$lake == streamdf$lake[1], ]
indxdf2 <- merge(lk1, indxdf, all=TRUE)
scaleup <- median(indxdf2$PE / indxdf2$indxkeep, na.rm=TRUE)
if(show) {
cat("\nindfit\n")
print(summary(indfit))
cat("\nstreamdf\n")
print(tail(streamdf[, c("lake", "year", "ls", "Emr", "CVmr", "Pmr", "COMBmr")]))
cat("\nscaleup\n")
print(scaleup)
cat("\nindxdf\n")
print(tail(indxdf[, c("lake", "year", "n.mr", "indxraw", "indxkeep", "indxkeep.lo", "indxkeep.hi")]))
}
list(indfit=indfit, streamdf=streamdf, scaleup=scaleup, indxdf=indxdf)
}
calctarg <- function(lakenum, adults, year, targyears, adjust=c(1, 1, 0.25, 1, 1)) {
# lakenum = vector of lake numbers (1-5)
# adults = vector of lakewide adult sea lamprey estimates
# year = vector of years
# targyears = list (length 5) of selected years from which to calculate targets
# lake huron target is 25% of
targets <- data.frame(lake=1:5, target=rep(NA, 5), lo=rep(NA, 5), hi=rep(NA, 5))
for(i in 1:5) {
pick5 <- adults[lakenum==i & is.element(year, targyears[[i]]) & !is.na(adults)]
if(length(pick5) > 0) {
targets$target[i] <- mean(pick5)
n <- length(pick5)
ci <- qnorm(1 - 0.05/2) * sqrt(var(pick5)) / sqrt(n)
targets[i, c("lo", "hi")] <- mean(pick5) + c(-1, 1)*ci# using z dist (known variance)
targets[i, c("target", "lo", "hi")] <- adjust[i]*targets[i, c("target", "lo", "hi")]
} else {
targets[i, c("target", "lo", "hi")] <- c(NA, NA, NA)
}
}
targets
}
}
# bring in lake-wide spawner data
lk <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/LakePEdynamic.csv", as.is=T)
# bring in stream-specific data
dat <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/StreamPEdynamicALLCOLS.csv", as.is=T)
dat$ls <- dat$lscode
attach(dat)
colz <- rep(brewer.pal(8, "Dark2"), 100)
selm <- year==2014 & est.source=="model"
selo <- year==2014 & est.source!="model"
windows(h=6, w=10)
par(mar=rep(0, 4))
map(xlim=range(map5$x, na.rm=T), ylim=range(map5$y, na.rm=T), col=NA, mar=rep(0, 4))
lines(map5$x, map5$y, col="darkgray", lwd=0.5)
points(long[selm], lat[selm], col=colz[1], cex=2, lwd=2)
windows(h=6, w=10)
par(mar=rep(0, 4))
map(xlim=range(map5$x, na.rm=T), ylim=range(map5$y, na.rm=T), col=NA, mar=rep(0, 4))
lines(map5$x, map5$y, col="darkgray", lwd=0.5)
points(long[selo], lat[selo], col=colz[2], cex=3, lwd=2)
legend("right", c("Untrapped", "Trapped"), pt.cex=c(2, 3), pt.lwd=c(1, 2), col=colz[1:2], pch=1, bty="n")
search()
detach()
windows(h=6, w=10)
par(mar=rep(0, 4))
map(xlim=range(map5$x, na.rm=T), ylim=range(map5$y, na.rm=T), col=NA, mar=rep(0, 4))
lines(map5$x, map5$y, col="darkgray", lwd=0.5)
points(long[selm], lat[selm], col=colz[1], cex=2, lwd=2)
windows(h=6, w=10)
par(mar=rep(0, 4))
map(xlim=range(map5$x, na.rm=T), ylim=range(map5$y, na.rm=T), col=NA, mar=rep(0, 4))
lines(map5$x, map5$y, col="darkgray", lwd=0.5)
points(long[selo], lat[selo], col=colz[2], cex=3, lwd=2)
legend("right", c("Untrapped", "Trapped"), pt.cex=c(2, 3), pt.lwd=2, col=colz[1:2], pch=1, bty="n")
selm <- year==2014 & est.source=="model"
selo <- year==2014 & est.source!="model"
windows(h=6, w=10)
par(mar=rep(0, 4))
map(xlim=range(map5$x, na.rm=T), ylim=range(map5$y, na.rm=T), col=NA, mar=rep(0, 4))
lines(map5$x, map5$y, col="darkgray", lwd=0.5)
windows(h=6, w=10)
par(mar=rep(0, 4))
map(xlim=range(map5$x, na.rm=T), ylim=range(map5$y, na.rm=T), col=NA, mar=rep(0, 4))
points(long[selo], lat[selo], col=colz[2], cex=3, lwd=2)
windows(h=6, w=10)
par(mar=rep(0, 4))
map(xlim=range(map5$x, na.rm=T), ylim=range(map5$y, na.rm=T), col=NA, mar=rep(0, 4))
points(long[selm], lat[selm], col=colz[1], cex=2, lwd=2)
legend("right", c("Untrapped", "Trapped"), pt.cex=c(2, 3), pt.lwd=2, col=colz[1:2], pch=1, bty="n")
windows(h=6, w=10)
par(mar=rep(0, 4))
map(xlim=range(map5$x, na.rm=T), ylim=range(map5$y, na.rm=T), col=NA, mar=rep(0, 4))
points(long[selm], lat[selm], col=colz[1], cex=2, lwd=2)
legend("right", c("Trapped", "Untrapped"), pt.cex=c(3, 2), pt.lwd=2, col=colz[2:1], pch=1, bty="n")
graphics.off()
### plots of time series
look <- table(ls, year, est.source=="model")
# just last 10 years
look2 <- apply(look[, 29:38, ], c(1, 3), sum)
look3 <- look2[look2[, 1]>0 & look2[, 2]>0, ]
look3[order(look3[, 1] - look3[, 2]), ]
dat[match(rownames(look3), ls), 1:10]
#dat[match(unlist(index.streams), ls), 1:10]
plotit <- function(mylake, lss, llog="y", yrcut=2004.5, ...) {
selall <- lake==mylake & year > yrcut
windows(h=5.5, w=3.3)
par(mar=c(4, 4, 1, 1))
if(llog=="y") {
fac <- 1
ylabb <- "Adults"
} else {
fac <- 1000
ylabb <- "Adults  (thousands)"
}
plot(year[selall], combPE[selall]/fac, type="n", las=1, log=llog, xlab="Year", ylab=ylabb, ...)
for(i in seq(lss)) {
sel2 <- lake==mylake & year > yrcut & ls==lss[i]
lines(year[sel2], combPE[sel2]/fac, col=colz[i], lty=2)
y <- ifelse(est.source[sel2]=="model", NA, combPE[sel2])
lines(year[sel2], y/fac, col=colz[i], type="o", pch=16, cex=1.2, lwd=2)
}
}
# all non-model time series
lsbest <- rownames(look2[look2[, "TRUE"]==0, ])
# all model time series
lsmodel <- rownames(look2[look2[, "FALSE"]==0, ])
# mixed time series
lsmixed <- rownames(look2[look2[, "TRUE"]!=0 & look2[, "FALSE"]!=0, ])
plotit(3, lsbest)
plotit(3, lsmodel)
plotit(3, lsmixed)
plotit(3, lsbest, "")
plotit(3, lsmodel, "")
plotit(3, lsmixed, "")
plotit(3, lsbest, "", ylim=range(combPE[lake==mylake & year > yrcut & ls %in% lss]))
plotit(3, lsbest, "", ylim=range(combPE[lake==mylake & year > yrcut & ls %in% lss])/fac)
plotit(3, lsbest, "", ylim=range(combPE[lake==mylake & year > yrcut & ls %in% lss])/1000)
range(combPE[lake==mylake & year > yrcut & ls %in% lss])
range(combPE[lake==mylake & year > yrcut & ls %in% lsbest])
plotit(3, lsbest, "", ylim=range(combPE[lake==mylake & year > yrcut & ls %in% lsbest])/1000)
### index streams
# 2014-04-09 Jess and Gale agreed that the East Au Gres (38) should be replaced with the Au Sable (36) in Lake Huron
# 2014-04-10 Jess thinks that we should just stick with the East Au Gres (38)
index.streams <- list(
Sup = c(1, 2, 9, 29, 31, 32, 62),
Mic = c(5, 6, 15, 24, 26, 35),
Hur = c(10, 16, 27, 32, 999, 38),
Eri = c(1, 2, 3, 7, 9),
Ont = c(5, 9, 22, 23, 36)
)
index.streams <- lapply(1:5, function(i) i + index.streams[[i]]/1000)
index.streams
index.streams[[3]]
plotit(3, index.streams[[3]], "", ylim=range(combPE[lake==mylake & year > yrcut & ls %in% lsbest])/1000)
lsbest
lsbest[lsbest %in% index.streams[[3]]
]
plotit(3, lsbest[!(lsbest %in% index.streams[[3]])], "", ylim=range(combPE[lake==mylake & year > yrcut & ls %in% lsbest])/1000)
plotit(3, lsbest[lsbest %in% index.streams[[3]]], "", ylim=range(combPE[lake==mylake & year > yrcut & ls %in% lsbest])/1000)
search()
ls(6)
length(mapL)
mapit <- function(mylake, lss) {
sel <- lake==mylake & year=2014 & ls %in% lss
windows(h=6, w=10)
par(mar=rep(0, 4))
map(xlim=range(mapL[[mylake]]$x, na.rm=T), ylim=range(mapL[[mylake]]$y, na.rm=T), col=NA, mar=rep(0, 4))
points(long[sel], lat[sel], col=colz, pch=16)
}
mapit(3, lsbest[!(lsbest %in% index.streams[[3]])])
mapit <- function(mylake, lss) {
sel <- lake==mylake & year==2014 & ls %in% lss
windows(h=6, w=10)
par(mar=rep(0, 4))
map(xlim=range(mapL[[mylake]]$x, na.rm=T), ylim=range(mapL[[mylake]]$y, na.rm=T), col=NA, mar=rep(0, 4))
points(long[sel], lat[sel], col=colz, pch=16)
}
mapit(3, lsbest[!(lsbest %in% index.streams[[3]])])
mapit <- function(mylake, lss) {
sel <- lake==mylake & year==2014 & ls %in% lss
windows(h=6, w=10)
par(mar=rep(0, 4))
map(xlim=range(mapL[[mylake]]$x, na.rm=T), ylim=range(mapL[[mylake]]$y, na.rm=T), col=NA, mar=rep(0, 4))
lines(mapL[[mylake]]$x, mapL[[mylake]]$y, col="darkgray", lwd=0.5)
points(long[sel], lat[sel], col=colz, pch=16)
}
mapit(3, lsbest[!(lsbest %in% index.streams[[3]])])
mapit <- function(mylake, lss, ...) {
sel <- lake==mylake & year==2014 & ls %in% lss
windows(h=6, w=10)
par(mar=rep(0, 4))
map(xlim=range(mapL[[mylake]]$x, na.rm=T), ylim=range(mapL[[mylake]]$y, na.rm=T), col=NA, mar=rep(0, 4))
lines(mapL[[mylake]]$x, mapL[[mylake]]$y, col="darkgray", lwd=0.5)
points(long[sel], lat[sel], col=colz, pch=16, cex=2)
text(long[sel], lat[sel], strname[sel], col=colz, pos=2, cex=2, ...)
}
mapit(3, lsbest[!(lsbest %in% index.streams[[3]])])
mapit <- function(mylake, lss, ...) {
sel <- lake==mylake & year==2014 & ls %in% lss
windows(h=6, w=10)
par(mar=c(0, 6, 0, 6))
map(xlim=range(mapL[[mylake]]$x, na.rm=T), ylim=range(mapL[[mylake]]$y, na.rm=T), col=NA, mar=c(0, 6, 0, 6))
lines(mapL[[mylake]]$x, mapL[[mylake]]$y, col="darkgray", lwd=0.5)
points(long[sel], lat[sel], col=colz, pch=16, cex=2)
text(long[sel], lat[sel], strname[sel], col=colz, pos=2, cex=1.5, ...)
}
graphics.off()
mapit(3, lsbest[!(lsbest %in% index.streams[[3]])])
mapit(3, lsbest[lsbest %in% index.streams[[3]]], font=2)
?par
mapit <- function(mylake, lss, ...) {
sel <- lake==mylake & year==2014 & ls %in% lss
windows(h=6, w=10)
par(mar=c(0, 6, 0, 6))
map(xlim=range(mapL[[mylake]]$x, na.rm=T), ylim=range(mapL[[mylake]]$y, na.rm=T), col=NA, mar=c(0, 6, 0, 6))
lines(mapL[[mylake]]$x, mapL[[mylake]]$y, col="darkgray", lwd=0.5)
par(xpd=NA)
points(long[sel], lat[sel], col=colz, pch=16, cex=2)
text(long[sel], lat[sel], strname[sel], col=colz, cex=1.5, ...)
}
mapit(3, lsbest[!(lsbest %in% index.streams[[3]])], pos=2)
mapit(3, lsbest[lsbest %in% index.streams[[3]]], pos=4, font=2)
mapit <- function(mylake, lss, ...) {
sel <- lake==mylake & year==2014 & ls %in% lss
windows(h=5, w=8)
par(mar=c(0, 6, 0, 6))
map(xlim=range(mapL[[mylake]]$x, na.rm=T), ylim=range(mapL[[mylake]]$y, na.rm=T), col=NA, mar=c(0, 6, 0, 6))
lines(mapL[[mylake]]$x, mapL[[mylake]]$y, col="darkgray", lwd=0.5)
par(xpd=NA)
points(long[sel], lat[sel], col=colz, pch=16, cex=2)
text(long[sel], lat[sel], strname[sel], col=colz, cex=1.5, ...)
}
mapit(3, lsbest[!(lsbest %in% index.streams[[3]])], pos=2)
mapit(3, lsbest[lsbest %in% index.streams[[3]]], pos=4, font=2)
mapit <- function(mylake, lss, ...) {
sel <- lake==mylake & year==2014 & ls %in% lss
windows(h=5, w=8)
par(mar=c(0, 6, 0, 6))
map(xlim=range(mapL[[mylake]]$x, na.rm=T), ylim=range(mapL[[mylake]]$y, na.rm=T), col=NA, mar=c(0, 6, 0, 6))
lines(mapL[[mylake]]$x, mapL[[mylake]]$y, col="darkgray", lwd=0.5)
par(xpd=NA)
points(long[sel], lat[sel], col=colz, pch=16, cex=1.5)
text(long[sel], lat[sel], strname[sel], col=colz, ...)
}
mapit(3, lsbest[!(lsbest %in% index.streams[[3]])], pos=2, font=1, cex=1.2)
mapit(3, lsbest[lsbest %in% index.streams[[3]]], pos=4, font=2, cex=1.5)
mapit <- function(mylake, lss, ...) {
windows(h=5, w=8)
par(mar=c(0, 6, 0, 6))
map(xlim=range(mapL[[mylake]]$x, na.rm=T), ylim=range(mapL[[mylake]]$y, na.rm=T), col=NA, mar=c(0, 6, 0, 6))
lines(mapL[[mylake]]$x, mapL[[mylake]]$y, col="darkgray", lwd=0.5)
par(xpd=NA)
for(i in seq(lss)) {
sel <- lake==mylake & year==2014 & ls==lss[i]
points(long[sel], lat[sel], col=colz, pch=16, cex=1.5)
text(long[sel], lat[sel], strname[sel], col=colz, ...)
}
}
graphics.off()
mapit(3, lsbest[!(lsbest %in% index.streams[[3]])], pos=2, font=1, cex=1.2)
mapit(3, lsbest[lsbest %in% index.streams[[3]]], pos=4, font=2, cex=1.5)
mapit <- function(mylake, lss, ...) {
windows(h=5, w=8)
par(mar=c(0, 6, 0, 6))
map(xlim=range(mapL[[mylake]]$x, na.rm=T), ylim=range(mapL[[mylake]]$y, na.rm=T), col=NA, mar=c(0, 6, 0, 6))
lines(mapL[[mylake]]$x, mapL[[mylake]]$y, col="darkgray", lwd=0.5)
par(xpd=NA)
for(i in seq(lss)) {
sel <- lake==mylake & year==2014 & ls==lss[i]
points(long[sel], lat[sel], col=colz[i], pch=16, cex=1.5)
text(long[sel], lat[sel], strname[sel], col=colz[i], ...)
}
}
mapit(3, lsbest[!(lsbest %in% index.streams[[3]])], pos=2, font=1, cex=1.2)
mapit(3, lsbest[lsbest %in% index.streams[[3]]], pos=4, font=2, cex=1.5)
mylake <- 3
lss <- lsbest[!(lsbest %in% index.streams[[3]])]
windows(h=5, w=8)
par(mar=c(0, 6, 0, 6))
map(xlim=range(mapL[[mylake]]$x, na.rm=T), ylim=range(mapL[[mylake]]$y, na.rm=T), col=NA, mar=c(0, 6, 0, 6))
lines(mapL[[mylake]]$x, mapL[[mylake]]$y, col="darkgray", lwd=0.5)
par(xpd=NA)
 seq(lss)
lsbest
# all non-model time series
lsbest <- rownames(look2[look2[, "TRUE"]==0, ])
lsbest
plotit <- function(mylake, lss, llog="y", yrcut=2004.5, ...) {
selall <- lake==mylake & year > yrcut
lss2 <- ls[lake==mylake & year==2014]
windows(h=5.5, w=3.3)
par(mar=c(4, 4, 1, 1))
if(llog=="y") {
fac <- 1
ylabb <- "Adults"
} else {
fac <- 1000
ylabb <- "Adults  (thousands)"
}
plot(year[selall], combPE[selall]/fac, type="n", las=1, log=llog, xlab="Year", ylab=ylabb, ...)
for(i in seq(lss2)) {
sel2 <- lake==mylake & year > yrcut & ls==lss2[i]
lines(year[sel2], combPE[sel2]/fac, col=colz[i], lty=2)
y <- ifelse(est.source[sel2]=="model", NA, combPE[sel2])
lines(year[sel2], y/fac, col=colz[i], type="o", pch=16, cex=1.2, lwd=2)
}
}
mapit <- function(mylake, lss, ...) {
lss2 <- ls[lake==mylake & year==2014]
windows(h=5, w=8)
par(mar=c(0, 6, 0, 6))
map(xlim=range(mapL[[mylake]]$x, na.rm=T), ylim=range(mapL[[mylake]]$y, na.rm=T), col=NA, mar=c(0, 6, 0, 6))
lines(mapL[[mylake]]$x, mapL[[mylake]]$y, col="darkgray", lwd=0.5)
par(xpd=NA)
for(i in seq(lss2)) {
sel <- lake==mylake & year==2014 & ls==lss2[i]
points(long[sel], lat[sel], col=colz[i], pch=16, cex=1.5)
text(long[sel], lat[sel], strname[sel], col=colz[i], ...)
}
}
graphics.of()
graphic.off()
graphics.off()
# all non-model time series
lsbest <- rownames(look2[look2[, "TRUE"]==0, ])
# all model time series
lsmodel <- rownames(look2[look2[, "FALSE"]==0, ])
# mixed time series
lsmixed <- rownames(look2[look2[, "TRUE"]!=0 & look2[, "FALSE"]!=0, ])
plotit(3, lsbest)
plotit(3, lsmodel)
plotit(3, lsmixed)
plotit(3, lsbest, "")
plotit(3, lsmodel, "")
plotit(3, lsmixed, "")
graphics.off()
plotit <- function(mylake, lss, llog="y", yrcut=2004.5, ...) {
selall <- lake==mylake & year > yrcut
lss2 <- ls[lake==mylake & year==2014 & ls %in% lss]
windows(h=5.5, w=3.3)
par(mar=c(4, 4, 1, 1))
if(llog=="y") {
fac <- 1
ylabb <- "Adults"
} else {
fac <- 1000
ylabb <- "Adults  (thousands)"
}
plot(year[selall], combPE[selall]/fac, type="n", las=1, log=llog, xlab="Year", ylab=ylabb, ...)
for(i in seq(lss2)) {
sel2 <- lake==mylake & year > yrcut & ls==lss2[i]
lines(year[sel2], combPE[sel2]/fac, col=colz[i], lty=2)
y <- ifelse(est.source[sel2]=="model", NA, combPE[sel2])
lines(year[sel2], y/fac, col=colz[i], type="o", pch=16, cex=1.2, lwd=2)
}
}
mapit <- function(mylake, lss, ...) {
lss2 <- ls[lake==mylake & year==2014 & ls %in% lss]
windows(h=5, w=8)
par(mar=c(0, 6, 0, 6))
map(xlim=range(mapL[[mylake]]$x, na.rm=T), ylim=range(mapL[[mylake]]$y, na.rm=T), col=NA, mar=c(0, 6, 0, 6))
lines(mapL[[mylake]]$x, mapL[[mylake]]$y, col="darkgray", lwd=0.5)
par(xpd=NA)
for(i in seq(lss2)) {
sel <- lake==mylake & year==2014 & ls==lss2[i]
points(long[sel], lat[sel], col=colz[i], pch=16, cex=1.5)
text(long[sel], lat[sel], strname[sel], col=colz[i], ...)
}
}
# all non-model time series
lsbest <- rownames(look2[look2[, "TRUE"]==0, ])
# all model time series
lsmodel <- rownames(look2[look2[, "FALSE"]==0, ])
# mixed time series
lsmixed <- rownames(look2[look2[, "TRUE"]!=0 & look2[, "FALSE"]!=0, ])
plotit(3, lsbest)
plotit(3, lsmodel)
plotit(3, lsmixed)
plotit(3, lsbest, "")
plotit(3, lsmodel, "")
plotit(3, lsmixed, "")
plotit(3, lsbest[!(lsbest %in% index.streams[[3]])], "", ylim=range(combPE[lake==mylake & year > yrcut & ls %in% lsbest])/1000)
plotit(3, lsbest[lsbest %in% index.streams[[3]]], "", ylim=range(combPE[lake==mylake & year > yrcut & ls %in% lsbest])/1000)
mapit(3, lsbest[!(lsbest %in% index.streams[[3]])], pos=2, font=1, cex=1.2)
mapit(3, lsbest[lsbest %in% index.streams[[3]]], pos=4, font=2, cex=1.5)
brewer.pal()
?brewer
display.brewer.all()
graphics.off()
colz <- rep(c(brewer.pal(8, "Dark2"), brewer.pal(8, "Set2")), 100)
### map of trapped and untrapped streams
selm <- year==2014 & est.source=="model"
selo <- year==2014 & est.source!="model"
windows(h=6, w=10)
par(mar=rep(0, 4))
map(xlim=range(map5$x, na.rm=T), ylim=range(map5$y, na.rm=T), col=NA, mar=rep(0, 4))
lines(map5$x, map5$y, col="darkgray", lwd=0.5)
windows(h=6, w=10)
par(mar=rep(0, 4))
map(xlim=range(map5$x, na.rm=T), ylim=range(map5$y, na.rm=T), col=NA, mar=rep(0, 4))
points(long[selo], lat[selo], col=colz[2], cex=3, lwd=2)
windows(h=6, w=10)
par(mar=rep(0, 4))
map(xlim=range(map5$x, na.rm=T), ylim=range(map5$y, na.rm=T), col=NA, mar=rep(0, 4))
points(long[selm], lat[selm], col=colz[1], cex=2, lwd=2)
legend("right", c("Trapped", "Untrapped"), pt.cex=c(3, 2), pt.lwd=2, col=colz[2:1], pch=1, bty="n")
### index streams
# 2014-04-09 Jess and Gale agreed that the East Au Gres (38) should be replaced with the Au Sable (36) in Lake Huron
# 2014-04-10 Jess thinks that we should just stick with the East Au Gres (38)
index.streams <- list(
Sup = c(1, 2, 9, 29, 31, 32, 62),
Mic = c(5, 6, 15, 24, 26, 35),
Hur = c(10, 16, 27, 32, 999, 38),
Eri = c(1, 2, 3, 7, 9),
Ont = c(5, 9, 22, 23, 36)
)
index.streams <- lapply(1:5, function(i) i + index.streams[[i]]/1000)
### plots of time series
look <- table(ls, year, est.source=="model")
# just last 10 years
look2 <- apply(look[, 29:38, ], c(1, 3), sum)
look3 <- look2[look2[, 1]>0 & look2[, 2]>0, ]
look3[order(look3[, 1] - look3[, 2]), ]
dat[match(rownames(look3), ls), 1:10]
#dat[match(unlist(index.streams), ls), 1:10]
plotit <- function(mylake, lss, llog="y", yrcut=2004.5, ...) {
selall <- lake==mylake & year > yrcut
lss2 <- ls[lake==mylake & year==2014 & ls %in% lss]
windows(h=5.5, w=3.3)
par(mar=c(4, 4, 1, 1))
if(llog=="y") {
fac <- 1
ylabb <- "Adults"
} else {
fac <- 1000
ylabb <- "Adults  (thousands)"
}
plot(year[selall], combPE[selall]/fac, type="n", las=1, log=llog, xlab="Year", ylab=ylabb, ...)
for(i in seq(lss2)) {
sel2 <- lake==mylake & year > yrcut & ls==lss2[i]
lines(year[sel2], combPE[sel2]/fac, col=colz[i], lty=2)
y <- ifelse(est.source[sel2]=="model", NA, combPE[sel2])
lines(year[sel2], y/fac, col=colz[i], type="o", pch=16, cex=1.2, lwd=2)
}
}
mapit <- function(mylake, lss, ...) {
lss2 <- ls[lake==mylake & year==2014 & ls %in% lss]
windows(h=5, w=8)
par(mar=c(0, 6, 0, 6))
map(xlim=range(mapL[[mylake]]$x, na.rm=T), ylim=range(mapL[[mylake]]$y, na.rm=T), col=NA, mar=c(0, 6, 0, 6))
lines(mapL[[mylake]]$x, mapL[[mylake]]$y, col="darkgray", lwd=0.5)
par(xpd=NA)
for(i in seq(lss2)) {
sel <- lake==mylake & year==2014 & ls==lss2[i]
points(long[sel], lat[sel], col=colz[i], pch=16, cex=1.5)
text(long[sel], lat[sel], strname[sel], col=colz[i], ...)
}
}
# all non-model time series
lsbest <- rownames(look2[look2[, "TRUE"]==0, ])
# all model time series
lsmodel <- rownames(look2[look2[, "FALSE"]==0, ])
# mixed time series
lsmixed <- rownames(look2[look2[, "TRUE"]!=0 & look2[, "FALSE"]!=0, ])
plotit(3, lsbest)
plotit(3, lsmodel)
plotit(3, lsmixed)
plotit(3, lsbest, "")
plotit(3, lsmodel, "")
plotit(3, lsmixed, "")
dat[lake==3 & year==2008 & combPE > 6000, ]
dat[lake==3 & year>2004.5 & strname=="Garden", ]
plotit(3, lsbest[!(lsbest %in% index.streams[[3]])], "", ylim=range(combPE[lake==mylake & year > yrcut & ls %in% lsbest])/1000)
plotit(3, lsbest[lsbest %in% index.streams[[3]]], "", ylim=range(combPE[lake==mylake & year > yrcut & ls %in% lsbest])/1000)
mapit(3, lsbest[!(lsbest %in% index.streams[[3]])], pos=2, font=1, cex=1.2)
mapit(3, lsbest[lsbest %in% index.streams[[3]]], pos=4, font=2, cex=1.5)
head(dat)
sub <- dat[, c("year", "ls", "combPE")]
sub <- dat[year > yrcut, c("year", "ls", "combPE")]
tapply(sub$combPE, sub$ls, median)
# all non-model time series
lsbest <- as.numeric(rownames(look2[look2[, "TRUE"]==0, ]))
# all model time series
lsmodel <- as.numeric(rownames(look2[look2[, "FALSE"]==0, ]))
# mixed time series
lsmixed <- as.numeric(rownames(look2[look2[, "TRUE"]!=0 & look2[, "FALSE"]!=0, ]))
sub <- dat[year > yrcut, c("year", "ls", "combPE")]
medPE <- tapply(sub$combPE, sub$ls, median)
df1 <- cbind(medPE, ls=as.numeric(names(medPE)))
df2 <- cbind(ls=c(lsbest, lsmodel, lsmixed), group=rep(c("1best", "2model", "3mixed"), c(length(lsbest), length(lsmodel), length(lsmixed))))
merge(df1, df2)
df <- merge(df1, df2)
df$lake <- floor(df$sub)
sub <- dat[year > yrcut, c("year", "ls", "combPE")]
medPE <- tapply(sub$combPE, sub$ls, median)
df1 <- cbind(medPE, ls=as.numeric(names(medPE)))
df2 <- cbind(ls=c(lsbest, lsmodel, lsmixed), group=rep(c("1best", "2model", "3mixed"), c(length(lsbest), length(lsmodel), length(lsmixed))))
df <- merge(df1, df2)
df$lake <- floor(df$ls)
head(df)
df <- df[order(df$lake, df$group, -df$medPE), ]
head(df)
df$lg <- paste(df$lake, df$group)
head(df)
tapply(-df$medPE, df$lg, rank)
?rank
tapply(-df$medPE, df$lg, rank, ties.method="random")
sub <- dat[year > yrcut, c("year", "ls", "combPE")]
medPE <- tapply(sub$combPE, sub$ls, median)
df1 <- cbind(medPE, ls=as.numeric(names(medPE)))
df2 <- cbind(ls=c(lsbest, lsmodel, lsmixed), group=rep(c("1best", "2model", "3mixed"), c(length(lsbest), length(lsmodel), length(lsmixed))))
df <- merge(df1, df2)
df$lake <- floor(df$ls)
df <- df[order(df$lake, df$group, -df$medPE), ]
df$lg <- paste(df$lake, df$group)
df$coli <- unlist(tapply(-df$medPE, df$lg, rank, ties.method="random"))
df$colx <- colz[df$coli]
head(df)
df
summary(df)
51/16
colz <- rep(c(brewer.pal(8, "Dark2"), brewer.pal(8, "Set2")), 4)
plotit <- function(mylake, lss, llog="y", yrcut=2004.5, ...) {
selall <- lake==mylake & year > yrcut
lss2 <- ls[lake==mylake & year==2014 & ls %in% lss]
windows(h=5.5, w=3.3)
par(mar=c(4, 4, 1, 1))
if(llog=="y") {
fac <- 1
ylabb <- "Adults"
} else {
fac <- 1000
ylabb <- "Adults  (thousands)"
}
plot(year[selall], combPE[selall]/fac, type="n", las=1, log=llog, xlab="Year", ylab=ylabb, ...)
for(i in seq(lss2)) {
sel2 <- lake==mylake & year > yrcut & ls==lss2[i]
lines(year[sel2], combPE[sel2]/fac, col=colkey$colx[colkey$ls==lss2[i]], lty=2)
y <- ifelse(est.source[sel2]=="model", NA, combPE[sel2])
lines(year[sel2], y/fac, col=colkey$colx[colkey$ls==lss2[i]], type="o", pch=16, cex=1.2, lwd=2)
}
}
mapit <- function(mylake, lss, ...) {
lss2 <- ls[lake==mylake & year==2014 & ls %in% lss]
windows(h=5, w=8)
par(mar=c(0, 6, 0, 6))
map(xlim=range(mapL[[mylake]]$x, na.rm=T), ylim=range(mapL[[mylake]]$y, na.rm=T), col=NA, mar=c(0, 6, 0, 6))
lines(mapL[[mylake]]$x, mapL[[mylake]]$y, col="darkgray", lwd=0.5)
par(xpd=NA)
for(i in seq(lss2)) {
sel <- lake==mylake & year==2014 & ls==lss2[i]
points(long[sel], lat[sel], col=colkey$colx[colkey$ls==lss2[i]], pch=16, cex=1.5)
text(long[sel], lat[sel], strname[sel], col=colkey$colx[colkey$ls==lss2[i]], ...)
}
}
# all non-model time series
lsbest <- as.numeric(rownames(look2[look2[, "TRUE"]==0, ]))
# all model time series
lsmodel <- as.numeric(rownames(look2[look2[, "FALSE"]==0, ]))
# mixed time series
lsmixed <- as.numeric(rownames(look2[look2[, "TRUE"]!=0 & look2[, "FALSE"]!=0, ]))
# create a color key
sub <- dat[year > yrcut, c("year", "ls", "combPE")]
medPE <- tapply(sub$combPE, sub$ls, median)
df1 <- cbind(medPE, ls=as.numeric(names(medPE)))
df2 <- cbind(ls=c(lsbest, lsmodel, lsmixed), group=rep(c("1best", "2model", "3mixed"), c(length(lsbest), length(lsmodel), length(lsmixed))))
colkey <- merge(df1, df2)
colkey$lake <- floor(colkey$ls)
colkey <- colkey[order(colkey$lake, colkey$group, -colkey$medPE), ]
colkey$lg <- paste(colkey$lake, colkey$group)
colkey$coli <- unlist(tapply(-colkey$medPE, colkey$lg, rank, ties.method="random"))
colkey$colx <- colz[colkey$coli]
head(colkey)
graphics.off()
plotit(3, lsbest)
plotit(3, lsmodel)
plotit(3, lsmixed)
plotit(3, lsbest, "")
plotit(3, lsmodel, "")
plotit(3, lsmixed, "")
dat[lake==3 & year==2008 & combPE > 6000, ]
dat[lake==3 & year>2004.5 & strname=="Garden", ]
plotit(3, lsbest[!(lsbest %in% index.streams[[3]])], "", ylim=range(combPE[lake==mylake & year > yrcut & ls %in% lsbest])/1000)
plotit(3, lsbest[lsbest %in% index.streams[[3]]], "", ylim=range(combPE[lake==mylake & year > yrcut & ls %in% lsbest])/1000)
mapit(3, lsbest[!(lsbest %in% index.streams[[3]])], pos=2, font=1, cex=1.2)
mapit(3, lsbest[lsbest %in% index.streams[[3]]], pos=4, font=2, cex=1.5)
# estimate adult index of abundance for each lake using index streams
indices <- lapply(index.streams, index.est, dat, lk)
# combine index data for all lakes in one dataframe
indxall <- do.call(rbind, lapply(indices, "[[", "indxdf"))
# calculate targets 
sptargyrz <- list(1994:1998, 1988:1992, 1989:1993, 1991:1995, 1999:2003)
targyrz <- apply(sapply(sptargyrz, range), 2, paste, collapse="-")
# spawner model
targets.sm <- calctarg(lakenum=lk$lake, adults=lk$PE, year=lk$year, targyears=sptargyrz)
# adult index
targets.ai <- calctarg(lakenum=indxall$lake, adults=indxall$indxkeep, year=indxall$year, targyears=sptargyrz)
# spawner model targets scaled down to adult index
targets.sm.su <- cbind(lake=targets.sm[, 1], (1/sapply(indices, "[[", "scaleup")) * targets.sm[, -1])
# adult index adjusted
targets.ai.adj <- targets.ai
targets.ai.adj[is.na(targets.ai$target), ] <- targets.sm.su[is.na(targets.ai$target), ]
YEAR1 <- 1984
outcex <- 1.2
YEARb <- 1995
### bar plot of individual index stream PEs
col7 <- c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69")
fig <- function(mylake) {
windows()
par(mar=c(4, 4, 1, 1), yaxs="i", cex=1.2)
mymap <- mapL[[mylake]]
mystreamdf <- indices[[mylake]]$streamdf
myindxdf <- indices[[mylake]]$indxdf
mystreamdf <- mystreamdf[mystreamdf$year >= YEARb, ]
myindxdf <- myindxdf[myindxdf$year >= YEARb, ]
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p[is.na(myindxdf$indxkeep), ] <- NA
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
a <- barplot(t(p)/1000, las=1, col=col7, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.03*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="Year", ylab="Adult abundance  (thousands)", main=Lakenames[mylake], border=NA)
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2, las=1)
box()
legend("topleft", rev(colnames(p)), fill=rev(col7[1:dim(p)[2]]), cex=0.5, bty="n", border=NA)
}
fig(3)
mylake <- 3
windows()
par(mar=c(4, 4, 1, 1), yaxs="i", cex=1.2)
mymap <- mapL[[mylake]]
mystreamdf <- indices[[mylake]]$streamdf
myindxdf <- indices[[mylake]]$indxdf
mystreamdf <- mystreamdf[mystreamdf$year >= YEARb, ]
myindxdf <- myindxdf[myindxdf$year >= YEARb, ]
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p[is.na(myindxdf$indxkeep), ] <- NA
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
p
colnames(p)
match(dat$ls, colnames(p))
match(colnames(p), dat$strname)
match(colnames(p), susbstring(dat$strname, 1, 10))
match(colnames(p), substring(dat$strname, 1, 10))
dat$ls[match(colnames(p), substring(dat$strname, 1, 10))]
dat$ls[match(colnames(p), substring(dat$strname, 1, 10))]
match(dat$ls[match(colnames(p), substring(dat$strname, 1, 10))], colkey$ls)
match(dat$ls[match(colnames(p), substring(dat$strname, 1, 10))], colkey$ls)
colkey$colx[match(dat$ls[match(colnames(p), substring(dat$strname, 1, 10))], colkey$ls)]
outcex <- 1.2
YEARb <- 1995
### bar plot of individual index stream PEs
fig <- function(mylake) {
windows()
par(mar=c(4, 4, 1, 1), yaxs="i", cex=1.2)
mymap <- mapL[[mylake]]
mystreamdf <- indices[[mylake]]$streamdf
myindxdf <- indices[[mylake]]$indxdf
mystreamdf <- mystreamdf[mystreamdf$year >= YEARb, ]
myindxdf <- myindxdf[myindxdf$year >= YEARb, ]
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p[is.na(myindxdf$indxkeep), ] <- NA
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
mycol <- colkey$colx[match(dat$ls[match(colnames(p), substring(dat$strname, 1, 10))], colkey$ls)]
a <- barplot(t(p)/1000, las=1, col=mycol, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.03*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="Year", ylab="Adult abundance  (thousands)", main=Lakenames[mylake], border=NA)
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2, las=1)
box()
legend("topleft", rev(colnames(p)), fill=rev(mycol[1:dim(p)[2]]), cex=0.5, bty="n", border=NA)
}
fig(3)
outcex <- 1.2
YEARb <- 1995
### bar plot of individual index stream PEs
fig <- function(mylake) {
windows()
par(mar=c(4, 4, 1, 3), yaxs="i", cex=1.2)
mymap <- mapL[[mylake]]
mystreamdf <- indices[[mylake]]$streamdf
myindxdf <- indices[[mylake]]$indxdf
mystreamdf <- mystreamdf[mystreamdf$year >= YEARb, ]
myindxdf <- myindxdf[myindxdf$year >= YEARb, ]
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p[is.na(myindxdf$indxkeep), ] <- NA
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
mycol <- colkey$colx[match(dat$ls[match(colnames(p), substring(dat$strname, 1, 10))], colkey$ls)]
a <- barplot(t(p)/1000, las=1, col=mycol, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.03*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="Year", ylab="Adult abundance  (thousands)", main=Lakenames[mylake], border=NA)
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2, las=1)
box()
legend("topleft", rev(colnames(p)), fill=rev(mycol[1:dim(p)[2]]), cex=0.7, bty="n", border=NA)
}
fig(3)
outcex <- 1.2
YEARb <- 1995
### bar plot of individual index stream PEs
fig <- function(mylake) {
windows()
par(mar=c(4, 4, 1, 3), yaxs="i", cex=1.2)
mymap <- mapL[[mylake]]
mystreamdf <- indices[[mylake]]$streamdf
myindxdf <- indices[[mylake]]$indxdf
myscaleup <- indices[[mylake]]$scaleup
print(myscaleup)
mystreamdf <- mystreamdf[mystreamdf$year >= YEARb, ]
myindxdf <- myindxdf[myindxdf$year >= YEARb, ]
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p[is.na(myindxdf$indxkeep), ] <- NA
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
mycol <- colkey$colx[match(dat$ls[match(colnames(p), substring(dat$strname, 1, 10))], colkey$ls)]
a <- barplot(t(p)/1000, las=1, col=mycol, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.03*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="Year", ylab="Adult abundance  (thousands)", main=Lakenames[mylake], border=NA)
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2, las=1)
box()
legend("topleft", rev(colnames(p)), fill=rev(mycol[1:dim(p)[2]]), cex=0.7, bty="n", border=NA)
}
fig(3)
p
apply(p, 1, sum)
outcex <- 1.2
YEARb <- 1995
### bar plot of individual index stream PEs
fig <- function(mylake) {
windows()
par(mar=c(4, 4, 1, 3), yaxs="i", cex=1.2)
mymap <- mapL[[mylake]]
mystreamdf <- indices[[mylake]]$streamdf
myindxdf <- indices[[mylake]]$indxdf
myscaleup <- indices[[mylake]]$scaleup
print(myscaleup)
mystreamdf <- mystreamdf[mystreamdf$year >= YEARb, ]
myindxdf <- myindxdf[myindxdf$year >= YEARb, ]
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p[is.na(myindxdf$indxkeep), ] <- NA
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
mycol <- colkey$colx[match(dat$ls[match(colnames(p), substring(dat$strname, 1, 10))], colkey$ls)]
a <- barplot(t(p)/1000, las=1, col=mycol, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.03*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="Year", ylab="Adult abundance  (thousands)", main=Lakenames[mylake], border=NA)
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2, las=1)
anntotals <- apply(p, 1, sum)
axis(4, at=pretty(myscaleup*anntotals)/anntotals, labels=pretty(myscaleup*anntotals))
box()
legend("topleft", rev(colnames(p)), fill=rev(mycol[1:dim(p)[2]]), cex=0.7, bty="n", border=NA)
}
fig(3)
pretty(myscaleup*anntotals)
outcex <- 1.2
YEARb <- 1995
### bar plot of individual index stream PEs
fig <- function(mylake) {
windows()
par(mar=c(4, 4, 1, 3), yaxs="i", cex=1.2)
mymap <- mapL[[mylake]]
mystreamdf <- indices[[mylake]]$streamdf
myindxdf <- indices[[mylake]]$indxdf
myscaleup <- indices[[mylake]]$scaleup
print(myscaleup)
mystreamdf <- mystreamdf[mystreamdf$year >= YEARb, ]
myindxdf <- myindxdf[myindxdf$year >= YEARb, ]
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p[is.na(myindxdf$indxkeep), ] <- NA
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
mycol <- colkey$colx[match(dat$ls[match(colnames(p), substring(dat$strname, 1, 10))], colkey$ls)]
a <- barplot(t(p)/1000, las=1, col=mycol, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.03*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="Year", ylab="Adult abundance  (thousands)", main=Lakenames[mylake], border=NA)
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2, las=1)
anntotals <- apply(p, 1, sum)
prt <- pretty(myscaleup*anntotals)
axis(4, at=prt/anntotals, labels=prt)
box()
legend("topleft", rev(colnames(p)), fill=rev(mycol[1:dim(p)[2]]), cex=0.7, bty="n", border=NA)
}
fig(3)
mylake <- 3
windows()
par(mar=c(4, 4, 1, 3), yaxs="i", cex=1.2)
mymap <- mapL[[mylake]]
mystreamdf <- indices[[mylake]]$streamdf
myindxdf <- indices[[mylake]]$indxdf
myscaleup <- indices[[mylake]]$scaleup
print(myscaleup)
mystreamdf <- mystreamdf[mystreamdf$year >= YEARb, ]
myindxdf <- myindxdf[myindxdf$year >= YEARb, ]
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p[is.na(myindxdf$indxkeep), ] <- NA
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
mycol <- colkey$colx[match(dat$ls[match(colnames(p), substring(dat$strname, 1, 10))], colkey$ls)]
a <- barplot(t(p)/1000, las=1, col=mycol, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.03*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="Year", ylab="Adult abundance  (thousands)", main=Lakenames[mylake], border=NA)
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2, las=1)
anntotals <- apply(p, 1, sum)
prt <- pretty(myscaleup*anntotals)
prt
axis(4, at=prt/myscaleup, labels=prt)
box()
legend("topleft", rev(colnames(p)), fill=rev(mycol[1:dim(p)[2]]), cex=0.7, bty="n", border=NA)
anntotals <- apply(p, 1, sum)
prt <- pretty(myscaleup*anntotals)/1000
axis(4, at=prt/myscaleup, labels=prt)
box()
prt <- pretty(myscaleup*c(0, anntotals)/1000
prt <- pretty(myscaleup*c(0, anntotals))/1000
prt
axis(4, at=prt/myscaleup, labels=prt)
par(mar=c(4, 4, 1, 3), yaxs="i", cex=1.2)
mymap <- mapL[[mylake]]
mystreamdf <- indices[[mylake]]$streamdf
myindxdf <- indices[[mylake]]$indxdf
myscaleup <- indices[[mylake]]$scaleup
print(myscaleup)
mystreamdf <- mystreamdf[mystreamdf$year >= YEARb, ]
myindxdf <- myindxdf[myindxdf$year >= YEARb, ]
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p[is.na(myindxdf$indxkeep), ] <- NA
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
mycol <- colkey$colx[match(dat$ls[match(colnames(p), substring(dat$strname, 1, 10))], colkey$ls)]
a <- barplot(t(p)/1000, las=1, col=mycol, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.03*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="Year", ylab="Adult abundance  (thousands)", main=Lakenames[mylake], border=NA)
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2, las=1)
anntotals <- apply(p, 1, sum)
prt <- pretty(myscaleup*c(0, anntotals))/1000
axis(4, at=prt/myscaleup, labels=prt, las=1)
box()
legend("topleft", rev(colnames(p)), fill=rev(mycol[1:dim(p)[2]]), cex=0.7, bty="n", border=NA)
outcex <- 1.2
YEARb <- 1995
### bar plot of individual index stream PEs
fig <- function(mylake) {
windows()
par(mar=c(4, 4, 1, 4), yaxs="i", cex=1.2)
mymap <- mapL[[mylake]]
mystreamdf <- indices[[mylake]]$streamdf
myindxdf <- indices[[mylake]]$indxdf
myscaleup <- indices[[mylake]]$scaleup
print(myscaleup)
mystreamdf <- mystreamdf[mystreamdf$year >= YEARb, ]
myindxdf <- myindxdf[myindxdf$year >= YEARb, ]
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p[is.na(myindxdf$indxkeep), ] <- NA
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
mycol <- colkey$colx[match(dat$ls[match(colnames(p), substring(dat$strname, 1, 10))], colkey$ls)]
a <- barplot(t(p)/1000, las=1, col=mycol, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.03*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="Year", ylab="Index Adults  (thousands)", main=Lakenames[mylake], border=NA)
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2, las=1)
anntotals <- apply(p, 1, sum)
prt <- pretty(myscaleup*c(0, anntotals))/1000
axis(4, at=prt/myscaleup, labels=prt, las=1)
mtext("Lake-wide Adults  (thousands)", side=4)
box()
legend("topleft", rev(colnames(p)), fill=rev(mycol[1:dim(p)[2]]), cex=0.7, bty="n", border=NA)
}
fig(3)
?title
mtext("Lake-wide Adults  (thousands)", side=4, line=3, cex=1.2)
outcex <- 1.2
YEARb <- 1995
### bar plot of individual index stream PEs
fig <- function(mylake) {
windows()
par(mar=c(4, 4, 1, 4), yaxs="i", cex=1.2)
mymap <- mapL[[mylake]]
mystreamdf <- indices[[mylake]]$streamdf
myindxdf <- indices[[mylake]]$indxdf
myscaleup <- indices[[mylake]]$scaleup
mystreamdf <- mystreamdf[mystreamdf$year >= YEARb, ]
myindxdf <- myindxdf[myindxdf$year >= YEARb, ]
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p[is.na(myindxdf$indxkeep), ] <- NA
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
mycol <- colkey$colx[match(dat$ls[match(colnames(p), substring(dat$strname, 1, 10))], colkey$ls)]
a <- barplot(t(p)/1000, las=1, col=mycol, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.03*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="Year", ylab="Index Adults  (thousands)", border=NA)
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2, las=1)
anntotals <- apply(p, 1, sum)
prt <- pretty(myscaleup*c(0, anntotals))/1000
axis(4, at=prt/myscaleup, labels=prt, las=1)
mtext("Lake-wide Adults  (thousands)", side=4, line=3, cex=1.2)
box()
legend("topleft", rev(colnames(p)), fill=rev(mycol[1:dim(p)[2]]), cex=0.7, bty="n", border=NA)
}
fig(3)
outcex <- 1.2
YEARb <- 1995
### bar plot of individual index stream PEs
fig <- function(mylake) {
windows()
par(mar=c(4, 4, 1, 4), yaxs="i", cex=1.2)
mymap <- mapL[[mylake]]
mystreamdf <- indices[[mylake]]$streamdf
myindxdf <- indices[[mylake]]$indxdf
myscaleup <- indices[[mylake]]$scaleup
mystreamdf <- mystreamdf[mystreamdf$year >= YEARb, ]
myindxdf <- myindxdf[myindxdf$year >= YEARb, ]
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p[is.na(myindxdf$indxkeep), ] <- NA
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
mycol <- colkey$colx[match(dat$ls[match(colnames(p), substring(dat$strname, 1, 10))], colkey$ls)]
a <- barplot(t(p)/1000, las=1, col=mycol, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.03*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="Year", ylab="Index Adults  (thousands)", border=NA)
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2, las=1)
anntotals <- apply(p, 1, sum)
prt <- pretty(myscaleup*c(0, anntotals))/1000
axis(4, at=prt/myscaleup, labels=prt, las=1)
mtext("Lake-wide Adults  (thousands)", side=4, line=3, cex=1.2)
box()
legend("top", rev(colnames(p)), fill=rev(mycol[1:dim(p)[2]]), cex=0.8, bty="n", border=NA)
}
fig(3)
?legend
outcex <- 1.2
YEARb <- 1995
### bar plot of individual index stream PEs
fig <- function(mylake) {
windows()
par(mar=c(4, 4, 1, 4), yaxs="i", cex=1.2)
mymap <- mapL[[mylake]]
mystreamdf <- indices[[mylake]]$streamdf
myindxdf <- indices[[mylake]]$indxdf
myscaleup <- indices[[mylake]]$scaleup
mystreamdf <- mystreamdf[mystreamdf$year >= YEARb, ]
myindxdf <- myindxdf[myindxdf$year >= YEARb, ]
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p[is.na(myindxdf$indxkeep), ] <- NA
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
mycol <- colkey$colx[match(dat$ls[match(colnames(p), substring(dat$strname, 1, 10))], colkey$ls)]
a <- barplot(t(p)/1000, las=1, col=mycol, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.03*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="Year", ylab="Index Adults  (thousands)", border=NA)
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2, las=1)
anntotals <- apply(p, 1, sum)
prt <- pretty(myscaleup*c(0, anntotals))/1000
axis(4, at=prt/myscaleup, labels=prt, las=1)
mtext("Lake-wide Adults  (thousands)", side=4, line=3, cex=1.2)
box()
legend("top", rev(colnames(p)), fill=rev(mycol[1:dim(p)[2]]), cex=0.9, bty="n", border=NA, inset=.3)
}
fig(3)
outcex <- 1.2
YEARb <- 1995
### bar plot of individual index stream PEs
fig <- function(mylake) {
windows()
par(mar=c(4, 4, 1, 4), yaxs="i", cex=1.2)
mymap <- mapL[[mylake]]
mystreamdf <- indices[[mylake]]$streamdf
myindxdf <- indices[[mylake]]$indxdf
myscaleup <- indices[[mylake]]$scaleup
mystreamdf <- mystreamdf[mystreamdf$year >= YEARb, ]
myindxdf <- myindxdf[myindxdf$year >= YEARb, ]
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p[is.na(myindxdf$indxkeep), ] <- NA
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
mycol <- colkey$colx[match(dat$ls[match(colnames(p), substring(dat$strname, 1, 10))], colkey$ls)]
a <- barplot(t(p)/1000, las=1, col=mycol, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.03*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="Year", ylab="Index Adults  (thousands)", border=NA)
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2, las=1)
anntotals <- apply(p, 1, sum)
prt <- pretty(myscaleup*c(0, anntotals))/1000
axis(4, at=prt/myscaleup, labels=prt, las=1)
mtext("Lake-wide Adults  (thousands)", side=4, line=3, cex=1.2)
box()
legend("top", rev(colnames(p)), fill=rev(mycol[1:dim(p)[2]]), cex=0.9, bty="n", border=NA, inset=c(0.3, 0))
}
fig(3)
legend("top", rev(colnames(p)), fill=rev(mycol[1:dim(p)[2]]), cex=0.9, bty="n", border=NA, inset=c(0.4, 0))
legend("top", rev(colnames(p)), fill=rev(mycol[1:dim(p)[2]]), cex=0.9, bty="n", border=NA, inset=c(4, 0))
legend("top", rev(colnames(p)), fill=rev(mycol[1:dim(p)[2]]), cex=0.9, bty="n", border=NA, inset=c(1000, 0))
legend("top", rev(colnames(p)), fill=rev(mycol[1:dim(p)[2]]), cex=0.9, bty="n", border=NA, inset=c(0, 0))
legend("top", rev(colnames(p)), fill=rev(mycol[1:dim(p)[2]]), cex=0.9, bty="n", border=NA, inset=c(2, 2))
legend("top", rev(colnames(p)), fill=rev(mycol[1:dim(p)[2]]), cex=0.9, bty="n", border=NA, inset=2)
legend("top", rev(colnames(p)), fill=rev(mycol[1:dim(p)[2]]), cex=0.9, bty="n", border=NA, inset=.3)
legend("top", rev(colnames(p)), fill=rev(mycol[1:dim(p)[2]]), cex=0.9, bty="n", border=NA, inset=.4)
legend("top", rev(colnames(p)), fill=rev(mycol[1:dim(p)[2]]), cex=0.9, bty="n", border=NA, inset=.1)
outcex <- 1.2
YEARb <- 1995
### bar plot of individual index stream PEs
fig <- function(mylake) {
windows()
par(mar=c(4, 4, 1, 4), yaxs="i", cex=1.2)
mymap <- mapL[[mylake]]
mystreamdf <- indices[[mylake]]$streamdf
myindxdf <- indices[[mylake]]$indxdf
myscaleup <- indices[[mylake]]$scaleup
mystreamdf <- mystreamdf[mystreamdf$year >= YEARb, ]
myindxdf <- myindxdf[myindxdf$year >= YEARb, ]
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p[is.na(myindxdf$indxkeep), ] <- NA
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
mycol <- colkey$colx[match(dat$ls[match(colnames(p), substring(dat$strname, 1, 10))], colkey$ls)]
a <- barplot(t(p)/1000, las=1, col=mycol, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.03*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="Year", ylab="Index Adults  (thousands)", border=NA)
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2, las=1)
anntotals <- apply(p, 1, sum)
prt <- pretty(myscaleup*c(0, anntotals))/1000
axis(4, at=prt/myscaleup, labels=prt, las=1)
mtext("Lake-wide Adults  (thousands)", side=4, line=3, cex=1.2)
box()
legend("top", rev(colnames(p)), fill=rev(mycol[1:dim(p)[2]]), cex=0.9, bty="n", border=NA)
}
fig(3)
outcex <- 1.2
YEARb <- 2005
### bar plot of individual index stream PEs
fig <- function(mylake) {
windows()
par(mar=c(4, 4, 1, 4), yaxs="i", cex=1.2)
mymap <- mapL[[mylake]]
mystreamdf <- indices[[mylake]]$streamdf
myindxdf <- indices[[mylake]]$indxdf
myscaleup <- indices[[mylake]]$scaleup
mystreamdf <- mystreamdf[mystreamdf$year >= YEARb, ]
myindxdf <- myindxdf[myindxdf$year >= YEARb, ]
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p[is.na(myindxdf$indxkeep), ] <- NA
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
mycol <- colkey$colx[match(dat$ls[match(colnames(p), substring(dat$strname, 1, 10))], colkey$ls)]
a <- barplot(t(p)/1000, las=1, col=mycol, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.03*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="Year", ylab="Index Adults  (thousands)", border=NA)
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2, las=1)
anntotals <- apply(p, 1, sum)
prt <- pretty(myscaleup*c(0, anntotals))/1000
axis(4, at=prt/myscaleup, labels=prt, las=1)
mtext("Lake-wide Adults  (thousands)", side=4, line=3, cex=1.2)
box()
legend("top", rev(colnames(p)), fill=rev(mycol[1:dim(p)[2]]), cex=0.9, bty="n", border=NA)
}
fig(3)
outcex <- 1.2
YEARb <- 2005
### bar plot of individual index stream PEs
fig <- function(mylake) {
windows(h=5.5, w=6.6)
par(mar=c(4, 4, 1, 4), yaxs="i", cex=1.2)
mymap <- mapL[[mylake]]
mystreamdf <- indices[[mylake]]$streamdf
myindxdf <- indices[[mylake]]$indxdf
myscaleup <- indices[[mylake]]$scaleup
mystreamdf <- mystreamdf[mystreamdf$year >= YEARb, ]
myindxdf <- myindxdf[myindxdf$year >= YEARb, ]
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p[is.na(myindxdf$indxkeep), ] <- NA
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
mycol <- colkey$colx[match(dat$ls[match(colnames(p), substring(dat$strname, 1, 10))], colkey$ls)]
a <- barplot(t(p)/1000, las=1, col=mycol, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.03*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="Year", ylab="Index Adults  (thousands)", border=NA)
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2, las=1)
anntotals <- apply(p, 1, sum)
prt <- pretty(myscaleup*c(0, anntotals))/1000
axis(4, at=prt/myscaleup, labels=prt, las=1)
mtext("Lake-wide Adults  (thousands)", side=4, line=3, cex=1.2)
box()
legend("topleft", rev(colnames(p)), fill=rev(mycol[1:dim(p)[2]]), cex=0.9, bty="n", border=NA)
}
fig(3)
outcex <- 1.2
YEARb <- 2005
### bar plot of individual index stream PEs
fig <- function(mylake) {
windows(h=5.5, w=6.6)
par(mar=c(4, 4, 1, 4), yaxs="i", cex=1.2)
mymap <- mapL[[mylake]]
mystreamdf <- indices[[mylake]]$streamdf
myindxdf <- indices[[mylake]]$indxdf
myscaleup <- indices[[mylake]]$scaleup
mystreamdf <- mystreamdf[mystreamdf$year >= YEARb, ]
myindxdf <- myindxdf[myindxdf$year >= YEARb, ]
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p[is.na(myindxdf$indxkeep), ] <- NA
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
mycol <- colkey$colx[match(dat$ls[match(colnames(p), substring(dat$strname, 1, 10))], colkey$ls)]
a <- barplot(t(p)/1000, las=1, col=mycol, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.03*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="Year", ylab="Index Adults  (thousands)", border=NA)
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2, las=1)
anntotals <- apply(p, 1, sum)
prt <- pretty(myscaleup*c(0, anntotals))/1000
axis(4, at=prt/myscaleup, labels=prt, las=1)
mtext("Lake-wide Adults  (thousands)", side=4, line=3, cex=1.2)
box()
legend("topleft", rev(colnames(p)), fill=rev(mycol[1:dim(p)[2]]), cex=0.85, bty="n", border=NA)
}
fig(3)
outcex <- 1.2
YEARb <- 2005
### bar plot of individual index stream PEs
fig <- function(mylake) {
windows(h=5.5, w=6.6)
par(mar=c(4, 4, 1, 4), yaxs="i", cex=1.2)
mymap <- mapL[[mylake]]
mystreamdf <- indices[[mylake]]$streamdf
myindxdf <- indices[[mylake]]$indxdf
myscaleup <- indices[[mylake]]$scaleup
mystreamdf <- mystreamdf[mystreamdf$year >= YEARb, ]
myindxdf <- myindxdf[myindxdf$year >= YEARb, ]
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p[is.na(myindxdf$indxkeep), ] <- NA
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
mycol <- colkey$colx[match(dat$ls[match(colnames(p), substring(dat$strname, 1, 10))], colkey$ls)]
a <- barplot(t(p)/1000, las=1, col=mycol, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.03*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="Year", ylab="Index Adults  (thousands)", border=NA)
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2, las=1)
anntotals <- apply(p, 1, sum)
prt <- pretty(myscaleup*c(0, anntotals))/1000
axis(4, at=prt/myscaleup, labels=prt, las=1)
mtext("Lake-wide Adults  (thousands)", side=4, line=3, cex=1.2)
box()
legend("topleft", rev(colnames(p)), fill=rev(mycol[1:dim(p)[2]]), cex=0.8, bty="n", border=NA)
}
fig(3)
outcex <- 1.2
YEARb <- 2005
### bar plot of individual index stream PEs
fig <- function(mylake) {
windows(h=5.5, w=6.3)
par(mar=c(4, 4, 1, 4), yaxs="i", cex=1.2)
mymap <- mapL[[mylake]]
mystreamdf <- indices[[mylake]]$streamdf
myindxdf <- indices[[mylake]]$indxdf
myscaleup <- indices[[mylake]]$scaleup
mystreamdf <- mystreamdf[mystreamdf$year >= YEARb, ]
myindxdf <- myindxdf[myindxdf$year >= YEARb, ]
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p[is.na(myindxdf$indxkeep), ] <- NA
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
mycol <- colkey$colx[match(dat$ls[match(colnames(p), substring(dat$strname, 1, 10))], colkey$ls)]
a <- barplot(t(p)/1000, las=1, col=mycol, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.03*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="Year", ylab="Index Adults  (thousands)", border=NA)
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2, las=1)
anntotals <- apply(p, 1, sum)
prt <- pretty(myscaleup*c(0, anntotals))/1000
axis(4, at=prt/myscaleup, labels=prt, las=1)
mtext("Lake-wide Adults  (thousands)", side=4, line=3, cex=1.2)
box()
legend("topleft", rev(colnames(p)), fill=rev(mycol[1:dim(p)[2]]), cex=0.8, bty="n", border=NA)
}
fig(3)
outcex <- 1.2
YEARb <- 2005
### bar plot of individual index stream PEs
fig <- function(mylake) {
windows(h=5.5, w=5.5)
par(mar=c(4, 4, 1, 4), yaxs="i", cex=1.2)
mymap <- mapL[[mylake]]
mystreamdf <- indices[[mylake]]$streamdf
myindxdf <- indices[[mylake]]$indxdf
myscaleup <- indices[[mylake]]$scaleup
mystreamdf <- mystreamdf[mystreamdf$year >= YEARb, ]
myindxdf <- myindxdf[myindxdf$year >= YEARb, ]
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p[is.na(myindxdf$indxkeep), ] <- NA
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
mycol <- colkey$colx[match(dat$ls[match(colnames(p), substring(dat$strname, 1, 10))], colkey$ls)]
a <- barplot(t(p)/1000, las=1, col=mycol, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.03*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="Year", ylab="Index Adults  (thousands)", border=NA)
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2, las=1)
anntotals <- apply(p, 1, sum)
prt <- pretty(myscaleup*c(0, anntotals))/1000
axis(4, at=prt/myscaleup, labels=prt, las=1)
mtext("Lake-wide Adults  (thousands)", side=4, line=3, cex=1.2)
box()
legend("topleft", rev(colnames(p)), fill=rev(mycol[1:dim(p)[2]]), cex=0.8, bty="n", border=NA)
}
fig(3)
graphics.off()
### spawner model and adult index time series overlaid
fig <- function(mylake) {
par(mar=c(4, 4, 1, 4), cex=1.2, yaxs="i")
mylk <- lk[lk$lake==i, ]# lake year PE lo hi
myindxdf <- indices[[mylake]]$indxdf# year lake indxraw n.mr indxkeep indxkeep.lo indxkeep.hi
convfac <- indices[[mylake]]$scaleup
x1 <- myindxdf$year
y1 <- myindxdf$indxkeep/1000
x2 <- mylk$year
y2 <- mylk$PE/convfac/1000
yr <- 1.05*range(0, y1, y2[x2>=YEAR1], na.rm=TRUE)
plot(1, 1, type="n", xlim=range(lk$year), ylim=yr, xlab="Year", ylab="Index Adults  (thousands)", axes=FALSE)
axis(1)
axis(2, col=blindcolz[7], col.axis=blindcolz[7], las=1)
par(mgp=c(3, 2.2, 0))
axis(4, at=pretty(convfac*yr)/convfac, labels=pretty(convfac*yr), col=blindcolz[3], col.axis=blindcolz[3], las=1, hadj=1)
par(mgp=c(3, 1, 0))
box()
abline(h=targets.sm$target[mylake]/convfac/1000, col=blindcolz[3], lty=2)
abline(h=targets.ai.adj$target[mylake]/1000, col=blindcolz[7], lty=2)
lines(x2, y2, col=blindcolz[3], type="o", pch=18, lwd=2)
lines(x1, y1, col=blindcolz[7], type="o", pch=17, lwd=2)
legend("center", c("Adult index", "Spawner model"), col=blindcolz[c(7, 3)], lwd=2, pch=c(17, 18))
}
fig(3)
### spawner model and adult index time series overlaid
fig <- function(mylake) {
windows(h=5.5, w=5.5)
par(mar=c(4, 4, 1, 4), yaxs="i", cex=1.2)
mylk <- lk[lk$lake==mylake, ]# lake year PE lo hi
myindxdf <- indices[[mylake]]$indxdf# year lake indxraw n.mr indxkeep indxkeep.lo indxkeep.hi
convfac <- indices[[mylake]]$scaleup
x1 <- myindxdf$year
y1 <- myindxdf$indxkeep/1000
x2 <- mylk$year
y2 <- mylk$PE/convfac/1000
yr <- 1.05*range(0, y1[x1>=YEARb], y2[x2>=YEARb], na.rm=TRUE)
plot(1, 1, type="n", xlim=range(lk$year[lk$year>=YEARb), ylim=yr, xlab="Year", ylab="Index Adults  (thousands)", axes=FALSE)
axis(1)
axis(2, col=blindcolz[7], col.axis=blindcolz[7], las=1)
par(mgp=c(3, 2.2, 0))
axis(4, at=pretty(convfac*yr)/convfac, labels=pretty(convfac*yr), col=blindcolz[3], col.axis=blindcolz[3], las=1, hadj=1)
par(mgp=c(3, 1, 0))
box()
abline(h=targets.sm$target[mylake]/convfac/1000, col=blindcolz[3], lty=2)
abline(h=targets.ai.adj$target[mylake]/1000, col=blindcolz[7], lty=2)
lines(x2, y2, col=blindcolz[3], type="o", pch=18, lwd=2)
lines(x1, y1, col=blindcolz[7], type="o", pch=17, lwd=2)
legend("center", c("Adult index", "Spawner model"), col=blindcolz[c(7, 3)], lwd=2, pch=c(17, 18))
}
fig(3)
### spawner model and adult index time series overlaid
fig <- function(mylake) {
windows(h=5.5, w=5.5)
par(mar=c(4, 4, 1, 4), yaxs="i", cex=1.2)
mylk <- lk[lk$lake==mylake, ]# lake year PE lo hi
myindxdf <- indices[[mylake]]$indxdf# year lake indxraw n.mr indxkeep indxkeep.lo indxkeep.hi
convfac <- indices[[mylake]]$scaleup
x1 <- myindxdf$year
y1 <- myindxdf$indxkeep/1000
x2 <- mylk$year
y2 <- mylk$PE/convfac/1000
yr <- 1.05*range(0, y1[x1>=YEARb], y2[x2>=YEARb], na.rm=TRUE)
plot(1, 1, type="n", xlim=range(lk$year[lk$year>=YEARb]), ylim=yr, xlab="Year", ylab="Index Adults  (thousands)", axes=FALSE)
axis(1)
axis(2, col=blindcolz[7], col.axis=blindcolz[7], las=1)
par(mgp=c(3, 2.2, 0))
axis(4, at=pretty(convfac*yr)/convfac, labels=pretty(convfac*yr), col=blindcolz[3], col.axis=blindcolz[3], las=1, hadj=1)
par(mgp=c(3, 1, 0))
box()
abline(h=targets.sm$target[mylake]/convfac/1000, col=blindcolz[3], lty=2)
abline(h=targets.ai.adj$target[mylake]/1000, col=blindcolz[7], lty=2)
lines(x2, y2, col=blindcolz[3], type="o", pch=18, lwd=2)
lines(x1, y1, col=blindcolz[7], type="o", pch=17, lwd=2)
legend("center", c("Adult index", "Spawner model"), col=blindcolz[c(7, 3)], lwd=2, pch=c(17, 18))
}
fig(3)
### spawner model and adult index time series overlaid
fig <- function(mylake) {
windows(h=5.5, w=5.5)
par(mar=c(4, 4, 1, 4), yaxs="i", cex=1.2)
mylk <- lk[lk$lake==mylake, ]# lake year PE lo hi
myindxdf <- indices[[mylake]]$indxdf# year lake indxraw n.mr indxkeep indxkeep.lo indxkeep.hi
convfac <- indices[[mylake]]$scaleup
x1 <- myindxdf$year
y1 <- myindxdf$indxkeep/1000
x2 <- mylk$year
y2 <- mylk$PE/convfac/1000
yr <- 1.05*range(0, y1[x1>=YEARb], y2[x2>=YEARb], na.rm=TRUE)
plot(1, 1, type="n", xlim=range(lk$year[lk$year>=YEARb]), ylim=yr, xlab="Year", ylab="Index Adults  (thousands)", axes=FALSE)
axis(1)
axis(2, col=blindcolz[7], col.axis=blindcolz[7], las=1)
par(mgp=c(3, 2.2, 0))
axis(4, at=pretty(convfac*yr)/convfac, labels=pretty(convfac*yr), col=blindcolz[3], col.axis=blindcolz[3], las=1, hadj=1)
par(mgp=c(3, 1, 0))
box()
abline(h=targets.sm$target[mylake]/convfac/1000, col=blindcolz[3], lty=2)
abline(h=targets.ai.adj$target[mylake]/1000, col=blindcolz[7], lty=2)
lines(x2, y2, col=blindcolz[3], type="o", pch=18, lwd=2)
lines(x1, y1, col=blindcolz[7], type="o", pch=17, lwd=2)
legend("botom", c("Adult index", "Spawner model"), col=blindcolz[c(7, 3)], lwd=2, pch=c(17, 18))
mtext("Lake-wide Adults  (thousands)", side=4, line=3, cex=1.2)
}
fig(3)
### spawner model and adult index time series overlaid
fig <- function(mylake) {
windows(h=5.5, w=5.5)
par(mar=c(4, 4, 1, 4), yaxs="i", cex=1.2)
mylk <- lk[lk$lake==mylake, ]# lake year PE lo hi
myindxdf <- indices[[mylake]]$indxdf# year lake indxraw n.mr indxkeep indxkeep.lo indxkeep.hi
convfac <- indices[[mylake]]$scaleup
x1 <- myindxdf$year
y1 <- myindxdf$indxkeep/1000
x2 <- mylk$year
y2 <- mylk$PE/convfac/1000
yr <- 1.05*range(0, y1[x1>=YEARb], y2[x2>=YEARb], na.rm=TRUE)
plot(1, 1, type="n", xlim=range(lk$year[lk$year>=YEARb]), ylim=yr, xlab="Year", ylab="Index Adults  (thousands)", axes=FALSE)
axis(1)
axis(2, col=blindcolz[7], col.axis=blindcolz[7], las=1)
par(mgp=c(3, 2.2, 0))
axis(4, at=pretty(convfac*yr)/convfac, labels=pretty(convfac*yr), col=blindcolz[3], col.axis=blindcolz[3], las=1, hadj=1)
par(mgp=c(3, 1, 0))
box()
abline(h=targets.sm$target[mylake]/convfac/1000, col=blindcolz[3], lty=2)
abline(h=targets.ai.adj$target[mylake]/1000, col=blindcolz[7], lty=2)
lines(x2, y2, col=blindcolz[3], type="o", pch=18, lwd=2)
lines(x1, y1, col=blindcolz[7], type="o", pch=17, lwd=2)
legend("bottom", c("Adult index", "Spawner model"), col=blindcolz[c(7, 3)], lwd=2, pch=c(17, 18))
mtext("Lake-wide Adults  (thousands)", side=4, line=3, cex=1.2)
}
fig(3)
windows(h=5.5, w=5.5)
par(mar=c(4, 4, 1, 4), yaxs="i", cex=1.2)
mylk <- lk[lk$lake==mylake, ]# lake year PE lo hi
myindxdf <- indices[[mylake]]$indxdf# year lake indxraw n.mr indxkeep indxkeep.lo indxkeep.hi
convfac <- indices[[mylake]]$scaleup
x1 <- myindxdf$year
y1 <- myindxdf$indxkeep/1000
x2 <- mylk$year
y2 <- mylk$PE/convfac/1000
yr <- 1.05*range(0, y1[x1>=YEARb], y2[x2>=YEARb], na.rm=TRUE)
plot(1, 1, type="n", xlim=range(lk$year[lk$year>=YEARb]), ylim=yr, xlab="Year", ylab="Index Adults  (thousands)", axes=FALSE)
axis(1)
axis(2, col=blindcolz[7], col.axis=blindcolz[7], las=1)
par(mgp=c(3, 2.2, 0))
axis(4, at=pretty(convfac*yr)/convfac, labels=pretty(convfac*yr), col=blindcolz[3], col.axis=blindcolz[3], las=1, hadj=1)
par(mgp=c(3, 1, 0))
box()
names(indices[[mylake]])
head(myindxdf)
arrows(x1, myindxdf$indxkeep.lo/1000, x1, myindxdf$indxkeep.hi/1000, length=0, angle=90, code=3, lwd=10, lend="square", col="#ffddc1")
windows(h=5.5, w=5.5)
par(mar=c(4, 4, 1, 4), yaxs="i", cex=1.2)
mylk <- lk[lk$lake==mylake, ]# lake year PE lo hi
myindxdf <- indices[[mylake]]$indxdf# year lake indxraw n.mr indxkeep indxkeep.lo indxkeep.hi
convfac <- indices[[mylake]]$scaleup
x1 <- myindxdf$year
y1 <- myindxdf$indxkeep/1000
x2 <- mylk$year
y2 <- mylk$PE/convfac/1000
yr <- 1.05*range(0, myindxdf$indxkeep.hi[x1>=YEARb]/1000, y2[x2>=YEARb], na.rm=TRUE)
plot(1, 1, type="n", xlim=range(lk$year[lk$year>=YEARb]), ylim=yr, xlab="Year", ylab="Index Adults  (thousands)", axes=FALSE)
axis(1)
axis(2, col=blindcolz[7], col.axis=blindcolz[7], las=1)
par(mgp=c(3, 2.2, 0))
axis(4, at=pretty(convfac*yr)/convfac, labels=pretty(convfac*yr), col=blindcolz[3], col.axis=blindcolz[3], las=1, hadj=1)
par(mgp=c(3, 1, 0))
box()
arrows(x1, myindxdf$indxkeep.lo/1000, x1, myindxdf$indxkeep.hi/1000, length=0, angle=90, code=3, lwd=10, lend="square", col="#ffddc1")
abline(h=targets.sm$target[mylake]/convfac/1000, col=blindcolz[3], lty=2)
abline(h=targets.ai.adj$target[mylake]/1000, col=blindcolz[7], lty=2)
lines(x2, y2, col=blindcolz[3], type="o", pch=18, lwd=2)
lines(x1, y1, col=blindcolz[7], type="o", pch=17, lwd=2)
legend("bottom", c("Adult index", "Spawner model"), col=blindcolz[c(7, 3)], lwd=2, pch=c(17, 18))
mtext("Lake-wide Adults  (thousands)", side=4, line=3, cex=1.2)
head(mylk)
blindcolz[3]
blindcolz[7]
arrows(x2, mylk$lo/1000, x1, mylk$hi/1000, length=1, angle=90, code=3, lwd=1, lend="square", col=blindcolz[3])
windows(h=5.5, w=5.5)
par(mar=c(4, 4, 1, 4), yaxs="i", cex=1.2)
mylk <- lk[lk$lake==mylake, ]# lake year PE lo hi
myindxdf <- indices[[mylake]]$indxdf# year lake indxraw n.mr indxkeep indxkeep.lo indxkeep.hi
convfac <- indices[[mylake]]$scaleup
x1 <- myindxdf$year
y1 <- myindxdf$indxkeep/1000
x2 <- mylk$year
y2 <- mylk$PE/convfac/1000
yr <- 1.05*range(0, myindxdf$indxkeep.hi[x1>=YEARb]/1000, mylk$hi[x2>=YEARb]/1000, na.rm=TRUE)
plot(1, 1, type="n", xlim=range(lk$year[lk$year>=YEARb]), ylim=yr, xlab="Year", ylab="Index Adults  (thousands)", axes=FALSE)
axis(1)
axis(2, col=blindcolz[7], col.axis=blindcolz[7], las=1)
par(mgp=c(3, 2.2, 0))
axis(4, at=pretty(convfac*yr)/convfac, labels=pretty(convfac*yr), col=blindcolz[3], col.axis=blindcolz[3], las=1, hadj=1)
par(mgp=c(3, 1, 0))
box()
arrows(x1, myindxdf$indxkeep.lo/1000, x1, myindxdf$indxkeep.hi/1000, length=0, angle=90, code=3, lwd=10, lend="square", col="#ffddc1")
arrows(x2, mylk$lo/1000, x1, mylk$hi/1000, length=0.1, angle=90, code=3, lwd=1, lend="square", col=blindcolz[3])
abline(h=targets.sm$target[mylake]/convfac/1000, col=blindcolz[3], lty=2)
abline(h=targets.ai.adj$target[mylake]/1000, col=blindcolz[7], lty=2)
lines(x2, y2, col=blindcolz[3], type="o", pch=18, lwd=2)
lines(x1, y1, col=blindcolz[7], type="o", pch=17, lwd=2)
legend("bottom", c("Adult index", "Spawner model"), col=blindcolz[c(7, 3)], lwd=2, pch=c(17, 18))
mtext("Lake-wide Adults  (thousands)", side=4, line=3, cex=1.2)
par(mar=c(4, 4, 1, 4), yaxs="i", cex=1.2)
mylk <- lk[lk$lake==mylake, ]# lake year PE lo hi
myindxdf <- indices[[mylake]]$indxdf# year lake indxraw n.mr indxkeep indxkeep.lo indxkeep.hi
convfac <- indices[[mylake]]$scaleup
x1 <- myindxdf$year
y1 <- myindxdf$indxkeep/1000
x2 <- mylk$year
y2 <- mylk$PE/convfac/1000
yr <- 1.05*range(0, myindxdf$indxkeep.hi[x1>=YEARb]/1000, mylk$hi[x2>=YEARb]/convfac/1000, na.rm=TRUE)
plot(1, 1, type="n", xlim=range(lk$year[lk$year>=YEARb]), ylim=yr, xlab="Year", ylab="Index Adults  (thousands)", axes=FALSE)
axis(1)
axis(2, col=blindcolz[7], col.axis=blindcolz[7], las=1)
par(mgp=c(3, 2.2, 0))
axis(4, at=pretty(convfac*yr)/convfac, labels=pretty(convfac*yr), col=blindcolz[3], col.axis=blindcolz[3], las=1, hadj=1)
par(mgp=c(3, 1, 0))
box()
arrows(x1, myindxdf$indxkeep.lo/1000, x1, myindxdf$indxkeep.hi/1000, length=0, angle=90, code=3, lwd=10, lend="square", col="#ffddc1")
arrows(x2, mylk$lo/convfac/1000, x1, mylk$hi/convfac/1000, length=0.1, angle=90, code=3, lwd=1, lend="square", col=blindcolz[3])
abline(h=targets.sm$target[mylake]/convfac/1000, col=blindcolz[3], lty=2)
abline(h=targets.ai.adj$target[mylake]/1000, col=blindcolz[7], lty=2)
lines(x2, y2, col=blindcolz[3], type="o", pch=18, lwd=2)
lines(x1, y1, col=blindcolz[7], type="o", pch=17, lwd=2)
legend("bottom", c("Adult index", "Spawner model"), col=blindcolz[c(7, 3)], lwd=2, pch=c(17, 18))
mtext("Lake-wide Adults  (thousands)", side=4, line=3, cex=1.2)
par(mar=c(4, 4, 1, 4), yaxs="i", cex=1.2)
mylk <- lk[lk$lake==mylake, ]# lake year PE lo hi
myindxdf <- indices[[mylake]]$indxdf# year lake indxraw n.mr indxkeep indxkeep.lo indxkeep.hi
convfac <- indices[[mylake]]$scaleup
x1 <- myindxdf$year
y1 <- myindxdf$indxkeep/1000
x2 <- mylk$year
y2 <- mylk$PE/convfac/1000
yr <- 1.05*range(0, myindxdf$indxkeep.hi[x1>=YEARb]/1000, mylk$hi[x2>=YEARb]/convfac/1000, na.rm=TRUE)
plot(1, 1, type="n", xlim=range(lk$year[lk$year>=YEARb]), ylim=yr, xlab="Year", ylab="Index Adults  (thousands)", axes=FALSE)
axis(1)
axis(2, col=blindcolz[7], col.axis=blindcolz[7], las=1)
par(mgp=c(3, 2.2, 0))
axis(4, at=pretty(convfac*yr)/convfac, labels=pretty(convfac*yr), col=blindcolz[3], col.axis=blindcolz[3], las=1, hadj=1)
par(mgp=c(3, 1, 0))
box()
arrows(x1, myindxdf$indxkeep.lo/1000, x1, myindxdf$indxkeep.hi/1000, length=0, angle=90, code=3, lwd=10, lend="square", col="#ffddc1")
arrows(x2, mylk$lo/convfac/1000, x1, mylk$hi/convfac/1000, length=0.05, angle=90, code=3, lwd=1, lend="square", col=blindcolz[3])
abline(h=targets.sm$target[mylake]/convfac/1000, col=blindcolz[3], lty=2)
abline(h=targets.ai.adj$target[mylake]/1000, col=blindcolz[7], lty=2)
lines(x2, y2, col=blindcolz[3], type="o", pch=18, lwd=2)
lines(x1, y1, col=blindcolz[7], type="o", pch=17, lwd=2)
legend("bottom", c("Adult index", "Spawner model"), col=blindcolz[c(7, 3)], lwd=2, pch=c(17, 18))
mtext("Lake-wide Adults  (thousands)", side=4, line=3, cex=1.2)
sp <- TRUE
windows(h=5.5, w=5.5)
par(mar=c(4, 4, 1, 4), yaxs="i", cex=1.2)
mylk <- lk[lk$lake==mylake, ]# lake year PE lo hi
myindxdf <- indices[[mylake]]$indxdf# year lake indxraw n.mr indxkeep indxkeep.lo indxkeep.hi
convfac <- indices[[mylake]]$scaleup
x1 <- myindxdf$year
y1 <- myindxdf$indxkeep/1000
x2 <- mylk$year
y2 <- mylk$PE/convfac/1000
yr <- 1.05*range(0, myindxdf$indxkeep.hi[x1>=YEARb]/1000, mylk$hi[x2>=YEARb]/convfac/1000, na.rm=TRUE)
plot(1, 1, type="n", xlim=range(lk$year[lk$year>=YEARb]), ylim=yr, xlab="Year", ylab="Index Adults  (thousands)", axes=FALSE)
axis(1)
axis(2, col=blindcolz[7], col.axis=blindcolz[7], las=1)
par(mgp=c(3, 2.2, 0))
axis(4, at=pretty(convfac*yr)/convfac, labels=pretty(convfac*yr), col=blindcolz[3], col.axis=blindcolz[3], las=1, hadj=1)
par(mgp=c(3, 1, 0))
box()
arrows(x1, myindxdf$indxkeep.lo/1000, x1, myindxdf$indxkeep.hi/1000, length=0, angle=90, code=3, lwd=10, lend="square", col="#ffddc1")
if(sp) {
arrows(x2, mylk$lo/convfac/1000, x1, mylk$hi/convfac/1000, length=0.05, angle=90, code=3, lwd=1, lend="square", col=blindcolz[3])
abline(h=targets.sm$target[mylake]/convfac/1000, col=blindcolz[3], lty=2)
legend("bottom", c("Adult index", "Spawner model"), col=blindcolz[c(7, 3)], lwd=2, pch=c(17, 18), bty="n")
}
abline(h=targets.ai.adj$target[mylake]/1000, col=blindcolz[7], lty=2)
if(sp) lines(x2, y2, col=blindcolz[3], type="o", pch=18, lwd=2)
lines(x1, y1, col=blindcolz[7], type="o", pch=17, lwd=2)
mtext("Lake-wide Adults  (thousands)", side=4, line=3, cex=1.2)
sp <- FALSE
windows(h=5.5, w=5.5)
par(mar=c(4, 4, 1, 4), yaxs="i", cex=1.2)
mylk <- lk[lk$lake==mylake, ]# lake year PE lo hi
myindxdf <- indices[[mylake]]$indxdf# year lake indxraw n.mr indxkeep indxkeep.lo indxkeep.hi
convfac <- indices[[mylake]]$scaleup
x1 <- myindxdf$year
y1 <- myindxdf$indxkeep/1000
x2 <- mylk$year
y2 <- mylk$PE/convfac/1000
yr <- 1.05*range(0, myindxdf$indxkeep.hi[x1>=YEARb]/1000, mylk$hi[x2>=YEARb]/convfac/1000, na.rm=TRUE)
plot(1, 1, type="n", xlim=range(lk$year[lk$year>=YEARb]), ylim=yr, xlab="Year", ylab="Index Adults  (thousands)", axes=FALSE)
axis(1)
axis(2, col=blindcolz[7], col.axis=blindcolz[7], las=1)
par(mgp=c(3, 2.2, 0))
axis(4, at=pretty(convfac*yr)/convfac, labels=pretty(convfac*yr), col=blindcolz[3], col.axis=blindcolz[3], las=1, hadj=1)
par(mgp=c(3, 1, 0))
box()
arrows(x1, myindxdf$indxkeep.lo/1000, x1, myindxdf$indxkeep.hi/1000, length=0, angle=90, code=3, lwd=10, lend="square", col="#ffddc1")
if(sp) {
arrows(x2, mylk$lo/convfac/1000, x1, mylk$hi/convfac/1000, length=0.05, angle=90, code=3, lwd=1, lend="square", col=blindcolz[3])
abline(h=targets.sm$target[mylake]/convfac/1000, col=blindcolz[3], lty=2)
legend("bottom", c("Adult index", "Spawner model"), col=blindcolz[c(7, 3)], lwd=2, pch=c(17, 18), bty="n")
}
abline(h=targets.ai.adj$target[mylake]/1000, col=blindcolz[7], lty=2)
if(sp) lines(x2, y2, col=blindcolz[3], type="o", pch=18, lwd=2)
lines(x1, y1, col=blindcolz[7], type="o", pch=17, lwd=2)
mtext("Lake-wide Adults  (thousands)", side=4, line=3, cex=1.2)
### spawner model and adult index time series overlaid
fig <- function(mylake, sp=TRUE) {
windows(h=5.5, w=5.5)
par(mar=c(4, 4, 1, 4), yaxs="i", cex=1.2)
mylk <- lk[lk$lake==mylake, ]# lake year PE lo hi
myindxdf <- indices[[mylake]]$indxdf# year lake indxraw n.mr indxkeep indxkeep.lo indxkeep.hi
convfac <- indices[[mylake]]$scaleup
x1 <- myindxdf$year
y1 <- myindxdf$indxkeep/1000
x2 <- mylk$year
y2 <- mylk$PE/convfac/1000
yr <- 1.05*range(0, myindxdf$indxkeep.hi[x1>=YEARb]/1000, mylk$hi[x2>=YEARb]/convfac/1000, na.rm=TRUE)
plot(1, 1, type="n", xlim=range(lk$year[lk$year>=YEARb]), ylim=yr, xlab="Year", ylab="Index Adults  (thousands)", axes=FALSE)
axis(1)
axis(2, las=1)
par(mgp=c(3, 2.2, 0))
axis(4, at=pretty(convfac*yr)/convfac, labels=pretty(convfac*yr), las=1, hadj=1)
par(mgp=c(3, 1, 0))
box()
arrows(x1, myindxdf$indxkeep.lo/1000, x1, myindxdf$indxkeep.hi/1000, length=0, angle=90, code=3, lwd=10, lend="square", col="#ffddc1")
if(sp) {
arrows(x2, mylk$lo/convfac/1000, x1, mylk$hi/convfac/1000, length=0.05, angle=90, code=3, lwd=1, lend="square", col=blindcolz[3])
abline(h=targets.sm$target[mylake]/convfac/1000, col=blindcolz[3], lty=2)
legend("bottom", c("Adult index", "Spawner model"), col=blindcolz[c(7, 3)], lwd=2, pch=c(17, 18), bty="n")
}
abline(h=targets.ai.adj$target[mylake]/1000, col=blindcolz[7], lty=2)
if(sp) lines(x2, y2, col=blindcolz[3], type="o", pch=18, lwd=2)
lines(x1, y1, col=blindcolz[7], type="o", pch=17, lwd=2)
mtext("Lake-wide Adults  (thousands)", side=4, line=3, cex=1.2)
}
fig(3, FALSE)
fig(3)
cleanup()
q()
# C:\JVA\GLFC\CLC\CLCAdultIndex.r
{ # functions
# the following seven plot.table related functions are from the Systematic Investor Toolbox
# load Systematic Investor Toolbox
# require(RCurl)
# sit = getURLContent("https://github.com/systematicinvestor/SIT/raw/master/sit.gz", binary=TRUE, followlocation=TRUE, ssl.verifypeer=FALSE)
# con = gzcon(rawConnection(sit, "rb"))
# source(con)
# close(con)
draw.cell <- function(title, r, c, text.cex = 1, bg.col = 'white', frame.cell = T) {
if(!frame.cell) bcol = bg.col else bcol = 'black'
rect((2*(c - 1) + .5), -(r - .5), (2*c + .5), -(r + .5), col = bg.col, border = bcol)
if( c == 1) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else if( r == 1 ) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else {
text((2*c + .5), -r, title, adj = 1, cex = text.cex)
}
}
plot.table.helper.auto.adjust.cex <- function(temp.table, keep.all.same.cex = FALSE) {
nr = nrow(temp.table)
nc = ncol(temp.table)
all.xrange = diff(par()$usr[1:2]) / nc
xrange = matrix( strwidth(paste('  ', temp.table), units = 'user', cex = 1), nc = nc)
all.yrange = diff(par()$usr[3:4]) / nr
yrange = matrix( 5/3 * strheight(temp.table, units = 'user', cex = 1), nc = nc)
plot.matrix.cex = pmin( round(all.yrange / yrange, 2) , round(all.xrange / xrange, 2) )
header.col.cex = min(plot.matrix.cex[1,-1])
header.row.cex = min(plot.matrix.cex[-1,1])
title.cex = plot.matrix.cex[1, 1]
data.cex = min(plot.matrix.cex[-1, -1])
if ( keep.all.same.cex ) {
plot.matrix.cex[] = min(plot.matrix.cex)
} else {
plot.matrix.cex[1,-1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,-1]= min(c(header.col.cex, header.row.cex, data.cex))
plot.matrix.cex[1,1]= min(c(header.col.cex, header.row.cex, data.cex, title.cex))
plot.matrix.cex[1,-1] = min(c(header.col.cex))
plot.matrix.cex[-1,1] = min(c(header.row.cex))
plot.matrix.cex[-1,-1]= min(c(data.cex))
plot.matrix.cex[1,1]= min(c(title.cex))
}
return(plot.matrix.cex)
}
make.table <- function(nr, nc) {
savepar = par(mar = rep(1, 4))
plot(c(0.5, nc*2 + 0.5), c(-0.5, -(nr + 0.5)), xaxs = 'i', yaxs = 'i',
type = 'n', xlab = '', ylab = '', axes = FALSE)
savepar
}
trim <- function(s) {
s = sub(pattern = '^ +', replacement = '', x = s)
s = sub(pattern = ' +$', replacement = '', x = s)
return(s)
}
plot.table.param <- function(plot.matrix, smain = '', plot.matrix.cex, plot.matrix_bg.col, frame.cell = T, keep.all.same.cex = FALSE) {
n = nrow(plot.matrix)
pages = unique(c(seq(0, n, by = 120), n))
for(p in 1:(length(pages)-1)) {
rindex = (pages[p]+1) : pages[p+1]
temp.table = matrix('', nr = length(rindex)+1, nc = ncol(plot.matrix)+1)
temp.table[-1, -1] = plot.matrix[rindex,]
temp.table[1, -1] = colnames(plot.matrix)
temp.table[-1, 1] = rownames(plot.matrix)[rindex]
temp.table[1, 1] = smain
nr = nrow(temp.table)
nc = ncol(temp.table)
par(mar = c(0, 0, 0, 0), cex = 0.5)
oldpar = make.table(nr, nc)
text.cex = plot.matrix.cex[c(1, 1 + rindex), ]
text.cex = plot.table.helper.auto.adjust.cex(temp.table, keep.all.same.cex)
bg.col = plot.matrix_bg.col[c(1, 1 + rindex), ]
for(r in 1:nr) {
for(c in 1:nc) {
draw.cell( paste('', temp.table[r,c], '', sep=' '), r, c,
text.cex = text.cex[r,c], bg.col = bg.col[r,c], frame.cell = frame.cell)
}}
}
}
plot.table <- function(plot.matrix, smain="", text.cex=1, frame.cell=TRUE, highlight=FALSE, colorbar=FALSE, keep_all.same.cex=FALSE) {
if( is.null(rownames(plot.matrix)) & is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
if( ncol(temp.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[-1, -1, drop = FALSE]
colnames(plot.matrix) = temp.matrix[1, -1]
rownames(plot.matrix) = temp.matrix[-1, 1]
smain = temp.matrix[1, 1]
} else if( is.null(rownames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( ncol(plot.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[, -1, drop = FALSE]
colnames(plot.matrix) = colnames(temp.matrix)[-1]
rownames(plot.matrix) = temp.matrix[,1]
smain = colnames(temp.matrix)[1]
} else if( is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
plot.matrix = temp.matrix[-1, , drop = FALSE]
rownames(plot.matrix) = rownames(temp.matrix)[-1]
colnames(plot.matrix) = temp.matrix[1, ]
smain = rownames(temp.matrix)[1]
}
plot.matrix[which(trim(plot.matrix) == "NA")] = ""
plot.matrix[which(trim(plot.matrix) == "NA%")] = ""
plot.matrix[which(is.na(plot.matrix))] = ""
nr = nrow(plot.matrix) + 1
nc = ncol(plot.matrix) + 1
is_highlight = TRUE
if(is.logical(highlight)) {
is_highlight = highlight
if(highlight) highlight = plot.table.helper.color(plot.matrix)
}
if(!is_highlight) {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[seq(1, nr, 2), ] = "yellow"
plot.matrix_bg.col[1,] = "gray";
plot.table.param( plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
} else {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[1,] = "gray"
plot.matrix_bg.col[2:nr,2:nc] = highlight
plot.table.param(plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
}
}
plot.table.helper.color <- function (temp) {
temp = matrix(as.double(gsub("[%,$]", "", temp)), nrow(temp), ncol(temp))
highlight = as.vector(temp)
cols = rep(NA, length(highlight))
ncols = length(highlight[!is.na(highlight)])
cols[1:ncols] = rev(rainbow(ncols, start=0.5/6, end=3.5/6))
o = sort.list(highlight, na.last = TRUE, decreasing = FALSE)
o1 = sort.list(o, na.last = TRUE, decreasing = FALSE)
highlight = matrix(cols[o1], nrow = nrow(temp))
highlight[is.na(temp)] = NA
return(highlight)
}
ModelEst <- function(fit, df) {
# derive regression estimates from log(y) fit
mse <- rev(as.matrix(summary(fit)[[1]])[, "Mean Sq"])[1]
plpe <- predict(fit, newdata=df, se.fit=T)
m <- plpe$fit
v <- plpe$se.fit^2 + mse
exp(m + v/2)
}
myrange <- function(x) {
if(all(is.na(x))) r <- c(NA, NA) else r <- range(x, na.rm=TRUE)
return(r)
}
jackindex <- function(m) {
# m is a matrix of numbers (stream PEs) with observations (years) as rows and individuals (streams) as columns
if(any(is.na(m))) stop("The input matrix may not have any missing values.")
# calculate the index as the sum of the columns for each row
rowsum <- apply(m, 1, sum)
# calculate the mean of the index
avgind <- mean(rowsum)
# recalculate the index, leaving out one individual at a time
loo <- apply(m, 2, function(column) (rowsum - column))
# rescale the loo index, relative to mean
looscaled <- apply(loo, 2, function(x) x/mean(x))
# convert to original scale
looscaled2 <- looscaled * avgind
# calculate range
ranges <- t(apply(looscaled2, 1, range))
cbind(index=rowsum, lo=ranges[, 1], hi=ranges[, 2])
}
# selstreams <- index.streams[[1]] 
# allstreamdf <- dat
# alllakedf <- lk 
# min.nmr=2 
# show=FALSE
index.est <- function(selstreams, allstreamdf, alllakedf, min.nmr=2, show=FALSE) {
# INDEX OF ADULT SEA LAMPREY ABUNDANCE
### INPUTS
# selstreams = vector of stream ids, e.g., 1.064 (lake + strcode/1000)
# allstreamdf = data frame of mark-recap estimates for all streams, with vars:  year lake ls Emr CVmr
# alllakedf = data frame of lake-wide PEs from Mullett et al. (2003) spawner model with vars:  lake year PE
# min.nmr = minimum number of mark-recapture estimates needed in a year to generate an index, default 2
# show = print out a brief summary of the results, default FALSE
### OUTPUTS
# indfit = simple model used to predict missing mark-recap estimates
# streamdf = original allstreamdf, subsetted by selstreams, with estimates for missing mark-recaps
# indxdf = original alllakedf, subsetted by lake, with annual index, including raw (indxraw), kept based on min.nmr (indxkeep, indxkeep.lo, indxkeep.hi)
# scaleup = conversion factor used to scale up annual index to spawner model PE
streamdf <- allstreamdf[allstreamdf$ls %in% selstreams, ]
# error checks
check1 <- var(streamdf$lake)
if(is.na(check1) | is.null(check1)) stop("Either no streams selected or critical data missing.") else if(check1 > 0) stop("Selected streams should be only from ONE lake.")
if(any(is.na(match(c("year", "lake", "ls", "Emr", "CVmr"), names(allstreamdf))))) stop("allstreamdf must include these variables: year lake ls Emr CVmr.")
if(any(is.na(match(c("year", "lake", "PE"), names(alllakedf))))) stop("alllakedf must include these variables: lake year PE.")
# fill in missing mark-recap data
indfit <- aov(log(Emr) ~ as.factor(ls) + as.factor(year), data=streamdf, weights=1/CVmr^2)
# figure out estimable years (those with at least 1 m-r estimate)
n.mr <- tapply(!is.na(streamdf$Emr), streamdf$year, sum)
eyrs <- as.numeric(names(n.mr)[n.mr > 0.5])
estimable <- streamdf$year %in% eyrs
streamdf$Pmr <- NA
streamdf$Pmr[estimable] <- ModelEst(fit=indfit, df=streamdf[estimable, ])
streamdf$COMBmr <- ifelse(is.na(streamdf$Emr), streamdf$Pmr, streamdf$Emr)
# annual index (sum across streams)
indxdf <- aggregate(COMBmr ~ year + lake, streamdf, sum, na.rm=TRUE, na.action=na.pass)
names(indxdf)[names(indxdf)=="COMBmr"] <- "indxraw"
indxdf$indxraw[indxdf$indxraw==0] <- NA
# only keep lake-wide index for years with at least min.nmr mark-recap estimates
indxdf$n.mr <- n.mr
indxdf$indxkeep <- ifelse(indxdf$n.mr > (min.nmr - 0.5), indxdf$indxraw, NA)
indxdf$indxkeep.lo <- NA
indxdf$indxkeep.hi <- NA
# matrix of stream estimates (rows = years, columns = index streams)
streamests <- with(streamdf, tapply(COMBmr, list(year, ls), mean))
# selection of only those streams with a keepable index
selkeep <- !is.na(indxdf$indxkeep)
jack <- jackindex(streamests[selkeep, ])
indxdf$indxkeep.lo[selkeep] <- jack[, "lo"]
indxdf$indxkeep.hi[selkeep] <- jack[, "hi"]
# scale up the index to the spawner model PE
lk1 <- lk[lk$lake == streamdf$lake[1], ]
indxdf2 <- merge(lk1, indxdf, all=TRUE)
scaleup <- median(indxdf2$PE / indxdf2$indxkeep, na.rm=TRUE)
if(show) {
cat("\nindfit\n")
print(summary(indfit))
cat("\nstreamdf\n")
print(tail(streamdf[, c("lake", "year", "ls", "Emr", "CVmr", "Pmr", "COMBmr")]))
cat("\nscaleup\n")
print(scaleup)
cat("\nindxdf\n")
print(tail(indxdf[, c("lake", "year", "n.mr", "indxraw", "indxkeep", "indxkeep.lo", "indxkeep.hi")]))
}
list(indfit=indfit, streamdf=streamdf, scaleup=scaleup, indxdf=indxdf)
}
calctarg <- function(lakenum, adults, year, targyears, adjust=c(1, 1, 0.25, 1, 1)) {
# lakenum = vector of lake numbers (1-5)
# adults = vector of lakewide adult sea lamprey estimates
# year = vector of years
# targyears = list (length 5) of selected years from which to calculate targets
# lake huron target is 25% of
targets <- data.frame(lake=1:5, target=rep(NA, 5), lo=rep(NA, 5), hi=rep(NA, 5))
for(i in 1:5) {
pick5 <- adults[lakenum==i & is.element(year, targyears[[i]]) & !is.na(adults)]
if(length(pick5) > 0) {
targets$target[i] <- mean(pick5)
n <- length(pick5)
ci <- qnorm(1 - 0.05/2) * sqrt(var(pick5)) / sqrt(n)
targets[i, c("lo", "hi")] <- mean(pick5) + c(-1, 1)*ci# using z dist (known variance)
targets[i, c("target", "lo", "hi")] <- adjust[i]*targets[i, c("target", "lo", "hi")]
} else {
targets[i, c("target", "lo", "hi")] <- c(NA, NA, NA)
}
}
targets
}
}
# bring in lake-wide spawner data
lk <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/LakePEdynamic.csv", as.is=T)
# bring in stream-specific data
dat <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/StreamPEdynamicALLCOLS.csv", as.is=T)
dat$ls <- dat$lscode
attach(dat)
colz <- rep(c(brewer.pal(8, "Dark2"), brewer.pal(8, "Set2")), 4)
### map of trapped and untrapped streams
selm <- year==2014 & est.source=="model"
selo <- year==2014 & est.source!="model"
windows(h=6, w=10)
par(mar=rep(0, 4))
map(xlim=range(map5$x, na.rm=T), ylim=range(map5$y, na.rm=T), col=NA, mar=rep(0, 4))
lines(map5$x, map5$y, col="darkgray", lwd=0.5)
windows(h=6, w=10)
par(mar=rep(0, 4))
map(xlim=range(map5$x, na.rm=T), ylim=range(map5$y, na.rm=T), col=NA, mar=rep(0, 4))
points(long[selo], lat[selo], col=colz[2], cex=3, lwd=2)
windows(h=6, w=10)
par(mar=rep(0, 4))
map(xlim=range(map5$x, na.rm=T), ylim=range(map5$y, na.rm=T), col=NA, mar=rep(0, 4))
points(long[selm], lat[selm], col=colz[1], cex=2, lwd=2)
legend("right", c("Trapped", "Untrapped"), pt.cex=c(3, 2), pt.lwd=2, col=colz[2:1], pch=1, bty="n")
### index streams
# 2014-04-09 Jess and Gale agreed that the East Au Gres (38) should be replaced with the Au Sable (36) in Lake Huron
# 2014-04-10 Jess thinks that we should just stick with the East Au Gres (38)
index.streams <- list(
Sup = c(1, 2, 9, 29, 31, 32, 62),
Mic = c(5, 6, 15, 24, 26, 35),
Hur = c(10, 16, 27, 32, 999, 38),
Eri = c(1, 2, 3, 7, 9),
Ont = c(5, 9, 22, 23, 36)
)
index.streams <- lapply(1:5, function(i) i + index.streams[[i]]/1000)
### plots of time series
look <- table(ls, year, est.source=="model")
# just last 10 years
look2 <- apply(look[, 29:38, ], c(1, 3), sum)
look3 <- look2[look2[, 1]>0 & look2[, 2]>0, ]
look3[order(look3[, 1] - look3[, 2]), ]
dat[match(rownames(look3), ls), 1:10]
#dat[match(unlist(index.streams), ls), 1:10]
plotit <- function(mylake, lss, llog="y", yrcut=2004.5, ...) {
selall <- lake==mylake & year > yrcut
lss2 <- ls[lake==mylake & year==2014 & ls %in% lss]
windows(h=5.5, w=3.3)
par(mar=c(4, 4, 1, 1))
if(llog=="y") {
fac <- 1
ylabb <- "Adults"
} else {
fac <- 1000
ylabb <- "Adults  (thousands)"
}
plot(year[selall], combPE[selall]/fac, type="n", las=1, log=llog, xlab="Year", ylab=ylabb, ...)
for(i in seq(lss2)) {
sel2 <- lake==mylake & year > yrcut & ls==lss2[i]
lines(year[sel2], combPE[sel2]/fac, col=colkey$colx[colkey$ls==lss2[i]], lty=2)
y <- ifelse(est.source[sel2]=="model", NA, combPE[sel2])
lines(year[sel2], y/fac, col=colkey$colx[colkey$ls==lss2[i]], type="o", pch=16, cex=1.2, lwd=2)
}
}
mapit <- function(mylake, lss, ...) {
lss2 <- ls[lake==mylake & year==2014 & ls %in% lss]
windows(h=5, w=8)
par(mar=c(0, 6, 0, 6))
map(xlim=range(mapL[[mylake]]$x, na.rm=T), ylim=range(mapL[[mylake]]$y, na.rm=T), col=NA, mar=c(0, 6, 0, 6))
lines(mapL[[mylake]]$x, mapL[[mylake]]$y, col="darkgray", lwd=0.5)
par(xpd=NA)
for(i in seq(lss2)) {
sel <- lake==mylake & year==2014 & ls==lss2[i]
points(long[sel], lat[sel], col=colkey$colx[colkey$ls==lss2[i]], pch=16, cex=1.5)
text(long[sel], lat[sel], strname[sel], col=colkey$colx[colkey$ls==lss2[i]], ...)
}
}
# all non-model time series
lsbest <- as.numeric(rownames(look2[look2[, "TRUE"]==0, ]))
# all model time series
lsmodel <- as.numeric(rownames(look2[look2[, "FALSE"]==0, ]))
# mixed time series
lsmixed <- as.numeric(rownames(look2[look2[, "TRUE"]!=0 & look2[, "FALSE"]!=0, ]))
# create a color key
sub <- dat[year > yrcut, c("year", "ls", "combPE")]
medPE <- tapply(sub$combPE, sub$ls, median)
df1 <- cbind(medPE, ls=as.numeric(names(medPE)))
df2 <- cbind(ls=c(lsbest, lsmodel, lsmixed), group=rep(c("1best", "2model", "3mixed"), c(length(lsbest), length(lsmodel), length(lsmixed))))
colkey <- merge(df1, df2)
colkey$lake <- floor(colkey$ls)
colkey <- colkey[order(colkey$lake, colkey$group, -colkey$medPE), ]
colkey$lg <- paste(colkey$lake, colkey$group)
colkey$coli <- unlist(tapply(-colkey$medPE, colkey$lg, rank, ties.method="random"))
colkey$colx <- colz[colkey$coli]
head(colkey)
plotit(3, lsbest)
plotit(3, lsmodel)
plotit(3, lsmixed)
plotit(3, lsbest, "")
plotit(3, lsmodel, "")
plotit(3, lsmixed, "")
dat[lake==3 & year==2008 & combPE > 6000, ]
dat[lake==3 & year>2004.5 & strname=="Garden", ]
plotit(3, lsbest[!(lsbest %in% index.streams[[3]])], "", ylim=range(combPE[lake==mylake & year > yrcut & ls %in% lsbest])/1000)
plotit(3, lsbest[lsbest %in% index.streams[[3]]], "", ylim=range(combPE[lake==mylake & year > yrcut & ls %in% lsbest])/1000)
mapit(3, lsbest[!(lsbest %in% index.streams[[3]])], pos=2, font=1, cex=1.2)
mapit(3, lsbest[lsbest %in% index.streams[[3]]], pos=4, font=2, cex=1.5)
# estimate adult index of abundance for each lake using index streams
indices <- lapply(index.streams, index.est, dat, lk)
# combine index data for all lakes in one dataframe
indxall <- do.call(rbind, lapply(indices, "[[", "indxdf"))
# calculate targets 
sptargyrz <- list(1994:1998, 1988:1992, 1989:1993, 1991:1995, 1999:2003)
targyrz <- apply(sapply(sptargyrz, range), 2, paste, collapse="-")
# spawner model
targets.sm <- calctarg(lakenum=lk$lake, adults=lk$PE, year=lk$year, targyears=sptargyrz)
# adult index
targets.ai <- calctarg(lakenum=indxall$lake, adults=indxall$indxkeep, year=indxall$year, targyears=sptargyrz)
# spawner model targets scaled down to adult index
targets.sm.su <- cbind(lake=targets.sm[, 1], (1/sapply(indices, "[[", "scaleup")) * targets.sm[, -1])
# adult index adjusted
targets.ai.adj <- targets.ai
targets.ai.adj[is.na(targets.ai$target), ] <- targets.sm.su[is.na(targets.ai$target), ]
YEAR1 <- 1984
outcex <- 1.2
YEARb <- 2005
### bar plot of individual index stream PEs
fig <- function(mylake) {
windows(h=5.5, w=5.5)
par(mar=c(4, 4, 1, 4), yaxs="i", cex=1.2)
mystreamdf <- indices[[mylake]]$streamdf
myindxdf <- indices[[mylake]]$indxdf
convfac <- indices[[mylake]]$scaleup
mystreamdf <- mystreamdf[mystreamdf$year >= YEARb, ]
myindxdf <- myindxdf[myindxdf$year >= YEARb, ]
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p[is.na(myindxdf$indxkeep), ] <- NA
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
mycol <- colkey$colx[match(dat$ls[match(colnames(p), substring(dat$strname, 1, 10))], colkey$ls)]
a <- barplot(t(p)/1000, las=1, col=mycol, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.03*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="Year", ylab="Index Adults  (thousands)", border=NA)
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2, las=1)
anntotals <- apply(p, 1, sum)
prt <- pretty(convfac*c(0, anntotals))/1000
axis(4, at=prt/convfac, labels=prt, las=1)
mtext("Lake-wide Adults  (thousands)", side=4, line=3, cex=1.2)
box()
legend("topleft", rev(colnames(p)), fill=rev(mycol[1:dim(p)[2]]), cex=0.8, bty="n", border=NA)
}
fig(3)
### spawner model and adult index time series overlaid
fig <- function(mylake, sp=TRUE) {
windows(h=5.5, w=5.5)
par(mar=c(4, 4, 1, 4), yaxs="i", cex=1.2)
mylk <- lk[lk$lake==mylake, ]# lake year PE lo hi
myindxdf <- indices[[mylake]]$indxdf# year lake indxraw n.mr indxkeep indxkeep.lo indxkeep.hi
convfac <- indices[[mylake]]$scaleup
x1 <- myindxdf$year
y1 <- myindxdf$indxkeep/1000
x2 <- mylk$year
y2 <- mylk$PE/convfac/1000
yr <- 1.05*range(0, myindxdf$indxkeep.hi[x1>=YEARb]/1000, mylk$hi[x2>=YEARb]/convfac/1000, na.rm=TRUE)
plot(1, 1, type="n", xlim=range(lk$year[lk$year>=YEARb]), ylim=yr, xlab="Year", ylab="Index Adults  (thousands)", axes=FALSE)
axis(1)
axis(2, las=1)
par(mgp=c(3, 2.2, 0))
axis(4, at=pretty(convfac*yr)/convfac, labels=pretty(convfac*yr), las=1, hadj=1)
par(mgp=c(3, 1, 0))
box()
arrows(x1, myindxdf$indxkeep.lo/1000, x1, myindxdf$indxkeep.hi/1000, length=0, angle=90, code=3, lwd=10, lend="square", col="#ffddc1")
if(sp) {
arrows(x2, mylk$lo/convfac/1000, x1, mylk$hi/convfac/1000, length=0.05, angle=90, code=3, lwd=1, lend="square", col=blindcolz[3])
abline(h=targets.sm$target[mylake]/convfac/1000, col=blindcolz[3], lty=2)
legend("bottom", c("Adult index", "Current method"), col=blindcolz[c(7, 3)], lwd=2, pch=c(17, 18), bty="n")
}
abline(h=targets.ai.adj$target[mylake]/1000, col=blindcolz[7], lty=2)
if(sp) lines(x2, y2, col=blindcolz[3], type="o", pch=18, lwd=2)
lines(x1, y1, col=blindcolz[7], type="o", pch=17, lwd=2)
mtext("Lake-wide Adults  (thousands)", side=4, line=3, cex=1.2)
}
fig(3, FALSE)
fig(3)
cleanup()
search()
detach()
graphics.off()
# C:\JVA\GLFC\CLC\CLCAdultIndex.r
{ # functions
# the following seven plot.table related functions are from the Systematic Investor Toolbox
# load Systematic Investor Toolbox
# require(RCurl)
# sit = getURLContent("https://github.com/systematicinvestor/SIT/raw/master/sit.gz", binary=TRUE, followlocation=TRUE, ssl.verifypeer=FALSE)
# con = gzcon(rawConnection(sit, "rb"))
# source(con)
# close(con)
draw.cell <- function(title, r, c, text.cex = 1, bg.col = 'white', frame.cell = T) {
if(!frame.cell) bcol = bg.col else bcol = 'black'
rect((2*(c - 1) + .5), -(r - .5), (2*c + .5), -(r + .5), col = bg.col, border = bcol)
if( c == 1) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else if( r == 1 ) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else {
text((2*c + .5), -r, title, adj = 1, cex = text.cex)
}
}
plot.table.helper.auto.adjust.cex <- function(temp.table, keep.all.same.cex = FALSE) {
nr = nrow(temp.table)
nc = ncol(temp.table)
all.xrange = diff(par()$usr[1:2]) / nc
xrange = matrix( strwidth(paste('  ', temp.table), units = 'user', cex = 1), nc = nc)
all.yrange = diff(par()$usr[3:4]) / nr
yrange = matrix( 5/3 * strheight(temp.table, units = 'user', cex = 1), nc = nc)
plot.matrix.cex = pmin( round(all.yrange / yrange, 2) , round(all.xrange / xrange, 2) )
header.col.cex = min(plot.matrix.cex[1,-1])
header.row.cex = min(plot.matrix.cex[-1,1])
title.cex = plot.matrix.cex[1, 1]
data.cex = min(plot.matrix.cex[-1, -1])
if ( keep.all.same.cex ) {
plot.matrix.cex[] = min(plot.matrix.cex)
} else {
plot.matrix.cex[1,-1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,-1]= min(c(header.col.cex, header.row.cex, data.cex))
plot.matrix.cex[1,1]= min(c(header.col.cex, header.row.cex, data.cex, title.cex))
plot.matrix.cex[1,-1] = min(c(header.col.cex))
plot.matrix.cex[-1,1] = min(c(header.row.cex))
plot.matrix.cex[-1,-1]= min(c(data.cex))
plot.matrix.cex[1,1]= min(c(title.cex))
}
return(plot.matrix.cex)
}
make.table <- function(nr, nc) {
savepar = par(mar = rep(1, 4))
plot(c(0.5, nc*2 + 0.5), c(-0.5, -(nr + 0.5)), xaxs = 'i', yaxs = 'i',
type = 'n', xlab = '', ylab = '', axes = FALSE)
savepar
}
trim <- function(s) {
s = sub(pattern = '^ +', replacement = '', x = s)
s = sub(pattern = ' +$', replacement = '', x = s)
return(s)
}
plot.table.param <- function(plot.matrix, smain = '', plot.matrix.cex, plot.matrix_bg.col, frame.cell = T, keep.all.same.cex = FALSE) {
n = nrow(plot.matrix)
pages = unique(c(seq(0, n, by = 120), n))
for(p in 1:(length(pages)-1)) {
rindex = (pages[p]+1) : pages[p+1]
temp.table = matrix('', nr = length(rindex)+1, nc = ncol(plot.matrix)+1)
temp.table[-1, -1] = plot.matrix[rindex,]
temp.table[1, -1] = colnames(plot.matrix)
temp.table[-1, 1] = rownames(plot.matrix)[rindex]
temp.table[1, 1] = smain
nr = nrow(temp.table)
nc = ncol(temp.table)
par(mar = c(0, 0, 0, 0), cex = 0.5)
oldpar = make.table(nr, nc)
text.cex = plot.matrix.cex[c(1, 1 + rindex), ]
text.cex = plot.table.helper.auto.adjust.cex(temp.table, keep.all.same.cex)
bg.col = plot.matrix_bg.col[c(1, 1 + rindex), ]
for(r in 1:nr) {
for(c in 1:nc) {
draw.cell( paste('', temp.table[r,c], '', sep=' '), r, c,
text.cex = text.cex[r,c], bg.col = bg.col[r,c], frame.cell = frame.cell)
}}
}
}
plot.table <- function(plot.matrix, smain="", text.cex=1, frame.cell=TRUE, highlight=FALSE, colorbar=FALSE, keep_all.same.cex=FALSE) {
if( is.null(rownames(plot.matrix)) & is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
if( ncol(temp.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[-1, -1, drop = FALSE]
colnames(plot.matrix) = temp.matrix[1, -1]
rownames(plot.matrix) = temp.matrix[-1, 1]
smain = temp.matrix[1, 1]
} else if( is.null(rownames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( ncol(plot.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[, -1, drop = FALSE]
colnames(plot.matrix) = colnames(temp.matrix)[-1]
rownames(plot.matrix) = temp.matrix[,1]
smain = colnames(temp.matrix)[1]
} else if( is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
plot.matrix = temp.matrix[-1, , drop = FALSE]
rownames(plot.matrix) = rownames(temp.matrix)[-1]
colnames(plot.matrix) = temp.matrix[1, ]
smain = rownames(temp.matrix)[1]
}
plot.matrix[which(trim(plot.matrix) == "NA")] = ""
plot.matrix[which(trim(plot.matrix) == "NA%")] = ""
plot.matrix[which(is.na(plot.matrix))] = ""
nr = nrow(plot.matrix) + 1
nc = ncol(plot.matrix) + 1
is_highlight = TRUE
if(is.logical(highlight)) {
is_highlight = highlight
if(highlight) highlight = plot.table.helper.color(plot.matrix)
}
if(!is_highlight) {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[seq(1, nr, 2), ] = "yellow"
plot.matrix_bg.col[1,] = "gray";
plot.table.param( plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
} else {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[1,] = "gray"
plot.matrix_bg.col[2:nr,2:nc] = highlight
plot.table.param(plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
}
}
plot.table.helper.color <- function (temp) {
temp = matrix(as.double(gsub("[%,$]", "", temp)), nrow(temp), ncol(temp))
highlight = as.vector(temp)
cols = rep(NA, length(highlight))
ncols = length(highlight[!is.na(highlight)])
cols[1:ncols] = rev(rainbow(ncols, start=0.5/6, end=3.5/6))
o = sort.list(highlight, na.last = TRUE, decreasing = FALSE)
o1 = sort.list(o, na.last = TRUE, decreasing = FALSE)
highlight = matrix(cols[o1], nrow = nrow(temp))
highlight[is.na(temp)] = NA
return(highlight)
}
ModelEst <- function(fit, df) {
# derive regression estimates from log(y) fit
mse <- rev(as.matrix(summary(fit)[[1]])[, "Mean Sq"])[1]
plpe <- predict(fit, newdata=df, se.fit=T)
m <- plpe$fit
v <- plpe$se.fit^2 + mse
exp(m + v/2)
}
myrange <- function(x) {
if(all(is.na(x))) r <- c(NA, NA) else r <- range(x, na.rm=TRUE)
return(r)
}
jackindex <- function(m) {
# m is a matrix of numbers (stream PEs) with observations (years) as rows and individuals (streams) as columns
if(any(is.na(m))) stop("The input matrix may not have any missing values.")
# calculate the index as the sum of the columns for each row
rowsum <- apply(m, 1, sum)
# calculate the mean of the index
avgind <- mean(rowsum)
# recalculate the index, leaving out one individual at a time
loo <- apply(m, 2, function(column) (rowsum - column))
# rescale the loo index, relative to mean
looscaled <- apply(loo, 2, function(x) x/mean(x))
# convert to original scale
looscaled2 <- looscaled * avgind
# calculate range
ranges <- t(apply(looscaled2, 1, range))
cbind(index=rowsum, lo=ranges[, 1], hi=ranges[, 2])
}
# selstreams <- index.streams[[1]] 
# allstreamdf <- dat
# alllakedf <- lk 
# min.nmr=2 
# show=FALSE
index.est <- function(selstreams, allstreamdf, alllakedf, min.nmr=2, show=FALSE) {
# INDEX OF ADULT SEA LAMPREY ABUNDANCE
### INPUTS
# selstreams = vector of stream ids, e.g., 1.064 (lake + strcode/1000)
# allstreamdf = data frame of mark-recap estimates for all streams, with vars:  year lake ls Emr CVmr
# alllakedf = data frame of lake-wide PEs from Mullett et al. (2003) spawner model with vars:  lake year PE
# min.nmr = minimum number of mark-recapture estimates needed in a year to generate an index, default 2
# show = print out a brief summary of the results, default FALSE
### OUTPUTS
# indfit = simple model used to predict missing mark-recap estimates
# streamdf = original allstreamdf, subsetted by selstreams, with estimates for missing mark-recaps
# indxdf = original alllakedf, subsetted by lake, with annual index, including raw (indxraw), kept based on min.nmr (indxkeep, indxkeep.lo, indxkeep.hi)
# scaleup = conversion factor used to scale up annual index to spawner model PE
streamdf <- allstreamdf[allstreamdf$ls %in% selstreams, ]
# error checks
check1 <- var(streamdf$lake)
if(is.na(check1) | is.null(check1)) stop("Either no streams selected or critical data missing.") else if(check1 > 0) stop("Selected streams should be only from ONE lake.")
if(any(is.na(match(c("year", "lake", "ls", "Emr", "CVmr"), names(allstreamdf))))) stop("allstreamdf must include these variables: year lake ls Emr CVmr.")
if(any(is.na(match(c("year", "lake", "PE"), names(alllakedf))))) stop("alllakedf must include these variables: lake year PE.")
# fill in missing mark-recap data
indfit <- aov(log(Emr) ~ as.factor(ls) + as.factor(year), data=streamdf, weights=1/CVmr^2)
# figure out estimable years (those with at least 1 m-r estimate)
n.mr <- tapply(!is.na(streamdf$Emr), streamdf$year, sum)
eyrs <- as.numeric(names(n.mr)[n.mr > 0.5])
estimable <- streamdf$year %in% eyrs
streamdf$Pmr <- NA
streamdf$Pmr[estimable] <- ModelEst(fit=indfit, df=streamdf[estimable, ])
streamdf$COMBmr <- ifelse(is.na(streamdf$Emr), streamdf$Pmr, streamdf$Emr)
# annual index (sum across streams)
indxdf <- aggregate(COMBmr ~ year + lake, streamdf, sum, na.rm=TRUE, na.action=na.pass)
names(indxdf)[names(indxdf)=="COMBmr"] <- "indxraw"
indxdf$indxraw[indxdf$indxraw==0] <- NA
# only keep lake-wide index for years with at least min.nmr mark-recap estimates
indxdf$n.mr <- n.mr
indxdf$indxkeep <- ifelse(indxdf$n.mr > (min.nmr - 0.5), indxdf$indxraw, NA)
indxdf$indxkeep.lo <- NA
indxdf$indxkeep.hi <- NA
# matrix of stream estimates (rows = years, columns = index streams)
streamests <- with(streamdf, tapply(COMBmr, list(year, ls), mean))
# selection of only those streams with a keepable index
selkeep <- !is.na(indxdf$indxkeep)
jack <- jackindex(streamests[selkeep, ])
indxdf$indxkeep.lo[selkeep] <- jack[, "lo"]
indxdf$indxkeep.hi[selkeep] <- jack[, "hi"]
# scale up the index to the spawner model PE
lk1 <- lk[lk$lake == streamdf$lake[1], ]
indxdf2 <- merge(lk1, indxdf, all=TRUE)
scaleup <- median(indxdf2$PE / indxdf2$indxkeep, na.rm=TRUE)
if(show) {
cat("\nindfit\n")
print(summary(indfit))
cat("\nstreamdf\n")
print(tail(streamdf[, c("lake", "year", "ls", "Emr", "CVmr", "Pmr", "COMBmr")]))
cat("\nscaleup\n")
print(scaleup)
cat("\nindxdf\n")
print(tail(indxdf[, c("lake", "year", "n.mr", "indxraw", "indxkeep", "indxkeep.lo", "indxkeep.hi")]))
}
list(indfit=indfit, streamdf=streamdf, scaleup=scaleup, indxdf=indxdf)
}
calctarg <- function(lakenum, adults, year, targyears, adjust=c(1, 1, 0.25, 1, 1)) {
# lakenum = vector of lake numbers (1-5)
# adults = vector of lakewide adult sea lamprey estimates
# year = vector of years
# targyears = list (length 5) of selected years from which to calculate targets
# lake huron target is 25% of
targets <- data.frame(lake=1:5, target=rep(NA, 5), lo=rep(NA, 5), hi=rep(NA, 5))
for(i in 1:5) {
pick5 <- adults[lakenum==i & is.element(year, targyears[[i]]) & !is.na(adults)]
if(length(pick5) > 0) {
targets$target[i] <- mean(pick5)
n <- length(pick5)
ci <- qnorm(1 - 0.05/2) * sqrt(var(pick5)) / sqrt(n)
targets[i, c("lo", "hi")] <- mean(pick5) + c(-1, 1)*ci# using z dist (known variance)
targets[i, c("target", "lo", "hi")] <- adjust[i]*targets[i, c("target", "lo", "hi")]
} else {
targets[i, c("target", "lo", "hi")] <- c(NA, NA, NA)
}
}
targets
}
}
# bring in lake-wide spawner data
lk <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/LakePEdynamic.csv", as.is=T)
# bring in stream-specific data
dat <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/StreamPEdynamicALLCOLS.csv", as.is=T)
dat$ls <- dat$lscode
attach(dat)
colz <- rep(c(brewer.pal(8, "Dark2"), brewer.pal(8, "Set2")), 4)
### map of trapped and untrapped streams
selm <- year==2014 & est.source=="model"
selo <- year==2014 & est.source!="model"
windows(h=6, w=10)
par(mar=rep(0, 4))
map(xlim=range(map5$x, na.rm=T), ylim=range(map5$y, na.rm=T), col=NA, mar=rep(0, 4))
lines(map5$x, map5$y, col="darkgray", lwd=0.5)
windows(h=6, w=10)
par(mar=rep(0, 4))
map(xlim=range(map5$x, na.rm=T), ylim=range(map5$y, na.rm=T), col=NA, mar=rep(0, 4))
points(long[selo], lat[selo], col=colz[2], cex=3, lwd=2)
windows(h=6, w=10)
par(mar=rep(0, 4))
map(xlim=range(map5$x, na.rm=T), ylim=range(map5$y, na.rm=T), col=NA, mar=rep(0, 4))
points(long[selm], lat[selm], col=colz[1], cex=2, lwd=2)
legend("right", c("Trapped", "Untrapped"), pt.cex=c(3, 2), pt.lwd=2, col=colz[2:1], pch=1, bty="n")
### index streams
# 2014-04-09 Jess and Gale agreed that the East Au Gres (38) should be replaced with the Au Sable (36) in Lake Huron
# 2014-04-10 Jess thinks that we should just stick with the East Au Gres (38)
index.streams <- list(
Sup = c(1, 2, 9, 29, 31, 32, 62),
Mic = c(5, 6, 15, 24, 26, 35),
Hur = c(10, 16, 27, 32, 999, 38),
Eri = c(1, 2, 3, 7, 9),
Ont = c(5, 9, 22, 23, 36)
)
index.streams <- lapply(1:5, function(i) i + index.streams[[i]]/1000)
### plots of time series
look <- table(ls, year, est.source=="model")
# just last 10 years
look2 <- apply(look[, 29:38, ], c(1, 3), sum)
look3 <- look2[look2[, 1]>0 & look2[, 2]>0, ]
look3[order(look3[, 1] - look3[, 2]), ]
dat[match(rownames(look3), ls), 1:10]
#dat[match(unlist(index.streams), ls), 1:10]
plotit <- function(mylake, lss, llog="y", yrcut=2004.5, ...) {
selall <- lake==mylake & year > yrcut
lss2 <- ls[lake==mylake & year==2014 & ls %in% lss]
windows(h=5.5, w=3.3)
par(mar=c(4, 4, 1, 1))
if(llog=="y") {
fac <- 1
ylabb <- "Adults"
} else {
fac <- 1000
ylabb <- "Adults  (thousands)"
}
plot(year[selall], combPE[selall]/fac, type="n", las=1, log=llog, xlab="Year", ylab=ylabb, ...)
for(i in seq(lss2)) {
sel2 <- lake==mylake & year > yrcut & ls==lss2[i]
lines(year[sel2], combPE[sel2]/fac, col=colkey$colx[colkey$ls==lss2[i]], lty=2)
y <- ifelse(est.source[sel2]=="model", NA, combPE[sel2])
lines(year[sel2], y/fac, col=colkey$colx[colkey$ls==lss2[i]], type="o", pch=16, cex=1.2, lwd=2)
}
}
mapit <- function(mylake, lss, ...) {
lss2 <- ls[lake==mylake & year==2014 & ls %in% lss]
windows(h=5, w=8)
par(mar=c(0, 6, 0, 6))
map(xlim=range(mapL[[mylake]]$x, na.rm=T), ylim=range(mapL[[mylake]]$y, na.rm=T), col=NA, mar=c(0, 6, 0, 6))
lines(mapL[[mylake]]$x, mapL[[mylake]]$y, col="darkgray", lwd=0.5)
par(xpd=NA)
for(i in seq(lss2)) {
sel <- lake==mylake & year==2014 & ls==lss2[i]
points(long[sel], lat[sel], col=colkey$colx[colkey$ls==lss2[i]], pch=16, cex=1.5)
text(long[sel], lat[sel], strname[sel], col=colkey$colx[colkey$ls==lss2[i]], ...)
}
}
# all non-model time series
lsbest <- as.numeric(rownames(look2[look2[, "TRUE"]==0, ]))
# all model time series
lsmodel <- as.numeric(rownames(look2[look2[, "FALSE"]==0, ]))
# mixed time series
lsmixed <- as.numeric(rownames(look2[look2[, "TRUE"]!=0 & look2[, "FALSE"]!=0, ]))
# create a color key
yrcut <- 2004.5
sub <- dat[year > yrcut, c("year", "ls", "combPE")]
medPE <- tapply(sub$combPE, sub$ls, median)
df1 <- cbind(medPE, ls=as.numeric(names(medPE)))
df2 <- cbind(ls=c(lsbest, lsmodel, lsmixed), group=rep(c("1best", "2model", "3mixed"), c(length(lsbest), length(lsmodel), length(lsmixed))))
colkey <- merge(df1, df2)
colkey$lake <- floor(colkey$ls)
colkey <- colkey[order(colkey$lake, colkey$group, -colkey$medPE), ]
colkey$lg <- paste(colkey$lake, colkey$group)
colkey$coli <- unlist(tapply(-colkey$medPE, colkey$lg, rank, ties.method="random"))
colkey$colx <- colz[colkey$coli]
head(colkey)
plotit(3, lsbest)
plotit(3, lsmodel)
plotit(3, lsmixed)
plotit(3, lsbest, "")
plotit(3, lsmodel, "")
plotit(3, lsmixed, "")
dat[lake==3 & year==2008 & combPE > 6000, ]
dat[lake==3 & year>2004.5 & strname=="Garden", ]
plotit(3, lsbest[!(lsbest %in% index.streams[[3]])], "", ylim=range(combPE[lake==mylake & year > yrcut & ls %in% lsbest])/1000)
plotit(3, lsbest[lsbest %in% index.streams[[3]]], "", ylim=range(combPE[lake==mylake & year > yrcut & ls %in% lsbest])/1000)
mapit(3, lsbest[!(lsbest %in% index.streams[[3]])], pos=2, font=1, cex=1.2)
mapit(3, lsbest[lsbest %in% index.streams[[3]]], pos=4, font=2, cex=1.5)
# estimate adult index of abundance for each lake using index streams
indices <- lapply(index.streams, index.est, dat, lk)
# combine index data for all lakes in one dataframe
indxall <- do.call(rbind, lapply(indices, "[[", "indxdf"))
# calculate targets 
sptargyrz <- list(1994:1998, 1988:1992, 1989:1993, 1991:1995, 1999:2003)
targyrz <- apply(sapply(sptargyrz, range), 2, paste, collapse="-")
# spawner model
targets.sm <- calctarg(lakenum=lk$lake, adults=lk$PE, year=lk$year, targyears=sptargyrz)
# adult index
targets.ai <- calctarg(lakenum=indxall$lake, adults=indxall$indxkeep, year=indxall$year, targyears=sptargyrz)
# spawner model targets scaled down to adult index
targets.sm.su <- cbind(lake=targets.sm[, 1], (1/sapply(indices, "[[", "scaleup")) * targets.sm[, -1])
# adult index adjusted
targets.ai.adj <- targets.ai
targets.ai.adj[is.na(targets.ai$target), ] <- targets.sm.su[is.na(targets.ai$target), ]
YEAR1 <- 1984
outcex <- 1.2
YEARb <- 2005
### bar plot of individual index stream PEs
fig <- function(mylake) {
windows(h=5.5, w=5.5)
par(mar=c(4, 4, 1, 4), yaxs="i", cex=1.2)
mystreamdf <- indices[[mylake]]$streamdf
myindxdf <- indices[[mylake]]$indxdf
convfac <- indices[[mylake]]$scaleup
mystreamdf <- mystreamdf[mystreamdf$year >= YEARb, ]
myindxdf <- myindxdf[myindxdf$year >= YEARb, ]
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p[is.na(myindxdf$indxkeep), ] <- NA
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
mycol <- colkey$colx[match(dat$ls[match(colnames(p), substring(dat$strname, 1, 10))], colkey$ls)]
a <- barplot(t(p)/1000, las=1, col=mycol, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.03*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="Year", ylab="Index Adults  (thousands)", border=NA)
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2, las=1)
anntotals <- apply(p, 1, sum)
prt <- pretty(convfac*c(0, anntotals))/1000
axis(4, at=prt/convfac, labels=prt, las=1)
mtext("Lake-wide Adults  (thousands)", side=4, line=3, cex=1.2)
box()
legend("topleft", rev(colnames(p)), fill=rev(mycol[1:dim(p)[2]]), cex=0.8, bty="n", border=NA)
}
fig(3)
### spawner model and adult index time series overlaid
fig <- function(mylake, sp=TRUE) {
windows(h=5.5, w=5.5)
par(mar=c(4, 4, 1, 4), yaxs="i", cex=1.2)
mylk <- lk[lk$lake==mylake, ]# lake year PE lo hi
myindxdf <- indices[[mylake]]$indxdf# year lake indxraw n.mr indxkeep indxkeep.lo indxkeep.hi
convfac <- indices[[mylake]]$scaleup
x1 <- myindxdf$year
y1 <- myindxdf$indxkeep/1000
x2 <- mylk$year
y2 <- mylk$PE/convfac/1000
yr <- 1.05*range(0, myindxdf$indxkeep.hi[x1>=YEARb]/1000, mylk$hi[x2>=YEARb]/convfac/1000, na.rm=TRUE)
plot(1, 1, type="n", xlim=range(lk$year[lk$year>=YEARb]), ylim=yr, xlab="Year", ylab="Index Adults  (thousands)", axes=FALSE)
axis(1)
axis(2, las=1)
par(mgp=c(3, 2.2, 0))
axis(4, at=pretty(convfac*yr)/convfac, labels=pretty(convfac*yr), las=1, hadj=1)
par(mgp=c(3, 1, 0))
box()
arrows(x1, myindxdf$indxkeep.lo/1000, x1, myindxdf$indxkeep.hi/1000, length=0, angle=90, code=3, lwd=10, lend="square", col="#ffddc1")
if(sp) {
arrows(x2, mylk$lo/convfac/1000, x1, mylk$hi/convfac/1000, length=0.05, angle=90, code=3, lwd=1, lend="square", col=blindcolz[3])
abline(h=targets.sm$target[mylake]/convfac/1000, col=blindcolz[3], lty=2)
legend("bottom", c("Adult index", "Current method"), col=blindcolz[c(7, 3)], lwd=2, pch=c(17, 18), bty="n")
}
abline(h=targets.ai.adj$target[mylake]/1000, col=blindcolz[7], lty=2)
if(sp) lines(x2, y2, col=blindcolz[3], type="o", pch=18, lwd=2)
lines(x1, y1, col=blindcolz[7], type="o", pch=17, lwd=2)
mtext("Lake-wide Adults  (thousands)", side=4, line=3, cex=1.2)
}
fig(3, FALSE)
fig(3)
graphics.off()
search()
detach()
cleanup()
# C:\JVA\GLFC\CLC\CLCAdultIndex.r
{ # functions
# the following seven plot.table related functions are from the Systematic Investor Toolbox
# load Systematic Investor Toolbox
# require(RCurl)
# sit = getURLContent("https://github.com/systematicinvestor/SIT/raw/master/sit.gz", binary=TRUE, followlocation=TRUE, ssl.verifypeer=FALSE)
# con = gzcon(rawConnection(sit, "rb"))
# source(con)
# close(con)
draw.cell <- function(title, r, c, text.cex = 1, bg.col = 'white', frame.cell = T) {
if(!frame.cell) bcol = bg.col else bcol = 'black'
rect((2*(c - 1) + .5), -(r - .5), (2*c + .5), -(r + .5), col = bg.col, border = bcol)
if( c == 1) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else if( r == 1 ) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else {
text((2*c + .5), -r, title, adj = 1, cex = text.cex)
}
}
plot.table.helper.auto.adjust.cex <- function(temp.table, keep.all.same.cex = FALSE) {
nr = nrow(temp.table)
nc = ncol(temp.table)
all.xrange = diff(par()$usr[1:2]) / nc
xrange = matrix( strwidth(paste('  ', temp.table), units = 'user', cex = 1), nc = nc)
all.yrange = diff(par()$usr[3:4]) / nr
yrange = matrix( 5/3 * strheight(temp.table, units = 'user', cex = 1), nc = nc)
plot.matrix.cex = pmin( round(all.yrange / yrange, 2) , round(all.xrange / xrange, 2) )
header.col.cex = min(plot.matrix.cex[1,-1])
header.row.cex = min(plot.matrix.cex[-1,1])
title.cex = plot.matrix.cex[1, 1]
data.cex = min(plot.matrix.cex[-1, -1])
if ( keep.all.same.cex ) {
plot.matrix.cex[] = min(plot.matrix.cex)
} else {
plot.matrix.cex[1,-1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,-1]= min(c(header.col.cex, header.row.cex, data.cex))
plot.matrix.cex[1,1]= min(c(header.col.cex, header.row.cex, data.cex, title.cex))
plot.matrix.cex[1,-1] = min(c(header.col.cex))
plot.matrix.cex[-1,1] = min(c(header.row.cex))
plot.matrix.cex[-1,-1]= min(c(data.cex))
plot.matrix.cex[1,1]= min(c(title.cex))
}
return(plot.matrix.cex)
}
make.table <- function(nr, nc) {
savepar = par(mar = rep(1, 4))
plot(c(0.5, nc*2 + 0.5), c(-0.5, -(nr + 0.5)), xaxs = 'i', yaxs = 'i',
type = 'n', xlab = '', ylab = '', axes = FALSE)
savepar
}
trim <- function(s) {
s = sub(pattern = '^ +', replacement = '', x = s)
s = sub(pattern = ' +$', replacement = '', x = s)
return(s)
}
plot.table.param <- function(plot.matrix, smain = '', plot.matrix.cex, plot.matrix_bg.col, frame.cell = T, keep.all.same.cex = FALSE) {
n = nrow(plot.matrix)
pages = unique(c(seq(0, n, by = 120), n))
for(p in 1:(length(pages)-1)) {
rindex = (pages[p]+1) : pages[p+1]
temp.table = matrix('', nr = length(rindex)+1, nc = ncol(plot.matrix)+1)
temp.table[-1, -1] = plot.matrix[rindex,]
temp.table[1, -1] = colnames(plot.matrix)
temp.table[-1, 1] = rownames(plot.matrix)[rindex]
temp.table[1, 1] = smain
nr = nrow(temp.table)
nc = ncol(temp.table)
par(mar = c(0, 0, 0, 0), cex = 0.5)
oldpar = make.table(nr, nc)
text.cex = plot.matrix.cex[c(1, 1 + rindex), ]
text.cex = plot.table.helper.auto.adjust.cex(temp.table, keep.all.same.cex)
bg.col = plot.matrix_bg.col[c(1, 1 + rindex), ]
for(r in 1:nr) {
for(c in 1:nc) {
draw.cell( paste('', temp.table[r,c], '', sep=' '), r, c,
text.cex = text.cex[r,c], bg.col = bg.col[r,c], frame.cell = frame.cell)
}}
}
}
plot.table <- function(plot.matrix, smain="", text.cex=1, frame.cell=TRUE, highlight=FALSE, colorbar=FALSE, keep_all.same.cex=FALSE) {
if( is.null(rownames(plot.matrix)) & is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
if( ncol(temp.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[-1, -1, drop = FALSE]
colnames(plot.matrix) = temp.matrix[1, -1]
rownames(plot.matrix) = temp.matrix[-1, 1]
smain = temp.matrix[1, 1]
} else if( is.null(rownames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( ncol(plot.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[, -1, drop = FALSE]
colnames(plot.matrix) = colnames(temp.matrix)[-1]
rownames(plot.matrix) = temp.matrix[,1]
smain = colnames(temp.matrix)[1]
} else if( is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
plot.matrix = temp.matrix[-1, , drop = FALSE]
rownames(plot.matrix) = rownames(temp.matrix)[-1]
colnames(plot.matrix) = temp.matrix[1, ]
smain = rownames(temp.matrix)[1]
}
plot.matrix[which(trim(plot.matrix) == "NA")] = ""
plot.matrix[which(trim(plot.matrix) == "NA%")] = ""
plot.matrix[which(is.na(plot.matrix))] = ""
nr = nrow(plot.matrix) + 1
nc = ncol(plot.matrix) + 1
is_highlight = TRUE
if(is.logical(highlight)) {
is_highlight = highlight
if(highlight) highlight = plot.table.helper.color(plot.matrix)
}
if(!is_highlight) {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[seq(1, nr, 2), ] = "yellow"
plot.matrix_bg.col[1,] = "gray";
plot.table.param( plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
} else {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[1,] = "gray"
plot.matrix_bg.col[2:nr,2:nc] = highlight
plot.table.param(plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
}
}
plot.table.helper.color <- function (temp) {
temp = matrix(as.double(gsub("[%,$]", "", temp)), nrow(temp), ncol(temp))
highlight = as.vector(temp)
cols = rep(NA, length(highlight))
ncols = length(highlight[!is.na(highlight)])
cols[1:ncols] = rev(rainbow(ncols, start=0.5/6, end=3.5/6))
o = sort.list(highlight, na.last = TRUE, decreasing = FALSE)
o1 = sort.list(o, na.last = TRUE, decreasing = FALSE)
highlight = matrix(cols[o1], nrow = nrow(temp))
highlight[is.na(temp)] = NA
return(highlight)
}
ModelEst <- function(fit, df) {
# derive regression estimates from log(y) fit
mse <- rev(as.matrix(summary(fit)[[1]])[, "Mean Sq"])[1]
plpe <- predict(fit, newdata=df, se.fit=T)
m <- plpe$fit
v <- plpe$se.fit^2 + mse
exp(m + v/2)
}
myrange <- function(x) {
if(all(is.na(x))) r <- c(NA, NA) else r <- range(x, na.rm=TRUE)
return(r)
}
jackindex <- function(m) {
# m is a matrix of numbers (stream PEs) with observations (years) as rows and individuals (streams) as columns
if(any(is.na(m))) stop("The input matrix may not have any missing values.")
# calculate the index as the sum of the columns for each row
rowsum <- apply(m, 1, sum)
# calculate the mean of the index
avgind <- mean(rowsum)
# recalculate the index, leaving out one individual at a time
loo <- apply(m, 2, function(column) (rowsum - column))
# rescale the loo index, relative to mean
looscaled <- apply(loo, 2, function(x) x/mean(x))
# convert to original scale
looscaled2 <- looscaled * avgind
# calculate range
ranges <- t(apply(looscaled2, 1, range))
cbind(index=rowsum, lo=ranges[, 1], hi=ranges[, 2])
}
# selstreams <- index.streams[[1]] 
# allstreamdf <- dat
# alllakedf <- lk 
# min.nmr=2 
# show=FALSE
index.est <- function(selstreams, allstreamdf, alllakedf, min.nmr=2, show=FALSE) {
# INDEX OF ADULT SEA LAMPREY ABUNDANCE
### INPUTS
# selstreams = vector of stream ids, e.g., 1.064 (lake + strcode/1000)
# allstreamdf = data frame of mark-recap estimates for all streams, with vars:  year lake ls Emr CVmr
# alllakedf = data frame of lake-wide PEs from Mullett et al. (2003) spawner model with vars:  lake year PE
# min.nmr = minimum number of mark-recapture estimates needed in a year to generate an index, default 2
# show = print out a brief summary of the results, default FALSE
### OUTPUTS
# indfit = simple model used to predict missing mark-recap estimates
# streamdf = original allstreamdf, subsetted by selstreams, with estimates for missing mark-recaps
# indxdf = original alllakedf, subsetted by lake, with annual index, including raw (indxraw), kept based on min.nmr (indxkeep, indxkeep.lo, indxkeep.hi)
# scaleup = conversion factor used to scale up annual index to spawner model PE
streamdf <- allstreamdf[allstreamdf$ls %in% selstreams, ]
# error checks
check1 <- var(streamdf$lake)
if(is.na(check1) | is.null(check1)) stop("Either no streams selected or critical data missing.") else if(check1 > 0) stop("Selected streams should be only from ONE lake.")
if(any(is.na(match(c("year", "lake", "ls", "Emr", "CVmr"), names(allstreamdf))))) stop("allstreamdf must include these variables: year lake ls Emr CVmr.")
if(any(is.na(match(c("year", "lake", "PE"), names(alllakedf))))) stop("alllakedf must include these variables: lake year PE.")
# fill in missing mark-recap data
indfit <- aov(log(Emr) ~ as.factor(ls) + as.factor(year), data=streamdf, weights=1/CVmr^2)
# figure out estimable years (those with at least 1 m-r estimate)
n.mr <- tapply(!is.na(streamdf$Emr), streamdf$year, sum)
eyrs <- as.numeric(names(n.mr)[n.mr > 0.5])
estimable <- streamdf$year %in% eyrs
streamdf$Pmr <- NA
streamdf$Pmr[estimable] <- ModelEst(fit=indfit, df=streamdf[estimable, ])
streamdf$COMBmr <- ifelse(is.na(streamdf$Emr), streamdf$Pmr, streamdf$Emr)
# annual index (sum across streams)
indxdf <- aggregate(COMBmr ~ year + lake, streamdf, sum, na.rm=TRUE, na.action=na.pass)
names(indxdf)[names(indxdf)=="COMBmr"] <- "indxraw"
indxdf$indxraw[indxdf$indxraw==0] <- NA
# only keep lake-wide index for years with at least min.nmr mark-recap estimates
indxdf$n.mr <- n.mr
indxdf$indxkeep <- ifelse(indxdf$n.mr > (min.nmr - 0.5), indxdf$indxraw, NA)
indxdf$indxkeep.lo <- NA
indxdf$indxkeep.hi <- NA
# matrix of stream estimates (rows = years, columns = index streams)
streamests <- with(streamdf, tapply(COMBmr, list(year, ls), mean))
# selection of only those streams with a keepable index
selkeep <- !is.na(indxdf$indxkeep)
jack <- jackindex(streamests[selkeep, ])
indxdf$indxkeep.lo[selkeep] <- jack[, "lo"]
indxdf$indxkeep.hi[selkeep] <- jack[, "hi"]
# scale up the index to the spawner model PE
lk1 <- lk[lk$lake == streamdf$lake[1], ]
indxdf2 <- merge(lk1, indxdf, all=TRUE)
scaleup <- median(indxdf2$PE / indxdf2$indxkeep, na.rm=TRUE)
if(show) {
cat("\nindfit\n")
print(summary(indfit))
cat("\nstreamdf\n")
print(tail(streamdf[, c("lake", "year", "ls", "Emr", "CVmr", "Pmr", "COMBmr")]))
cat("\nscaleup\n")
print(scaleup)
cat("\nindxdf\n")
print(tail(indxdf[, c("lake", "year", "n.mr", "indxraw", "indxkeep", "indxkeep.lo", "indxkeep.hi")]))
}
list(indfit=indfit, streamdf=streamdf, scaleup=scaleup, indxdf=indxdf)
}
calctarg <- function(lakenum, adults, year, targyears, adjust=c(1, 1, 0.25, 1, 1)) {
# lakenum = vector of lake numbers (1-5)
# adults = vector of lakewide adult sea lamprey estimates
# year = vector of years
# targyears = list (length 5) of selected years from which to calculate targets
# lake huron target is 25% of
targets <- data.frame(lake=1:5, target=rep(NA, 5), lo=rep(NA, 5), hi=rep(NA, 5))
for(i in 1:5) {
pick5 <- adults[lakenum==i & is.element(year, targyears[[i]]) & !is.na(adults)]
if(length(pick5) > 0) {
targets$target[i] <- mean(pick5)
n <- length(pick5)
ci <- qnorm(1 - 0.05/2) * sqrt(var(pick5)) / sqrt(n)
targets[i, c("lo", "hi")] <- mean(pick5) + c(-1, 1)*ci# using z dist (known variance)
targets[i, c("target", "lo", "hi")] <- adjust[i]*targets[i, c("target", "lo", "hi")]
} else {
targets[i, c("target", "lo", "hi")] <- c(NA, NA, NA)
}
}
targets
}
}
# bring in lake-wide spawner data
lk <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/LakePEdynamic.csv", as.is=T)
# bring in stream-specific data
dat <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/StreamPEdynamicALLCOLS.csv", as.is=T)
dat$ls <- dat$lscode
attach(dat)
colz <- rep(c(brewer.pal(8, "Dark2"), brewer.pal(8, "Set2")), 4)
### map of trapped and untrapped streams
selm <- year==2014 & est.source=="model"
selo <- year==2014 & est.source!="model"
windows(h=6, w=10)
par(mar=rep(0, 4))
map(xlim=range(map5$x, na.rm=T), ylim=range(map5$y, na.rm=T), col=NA, mar=rep(0, 4))
lines(map5$x, map5$y, col="darkgray", lwd=0.5)
windows(h=6, w=10)
par(mar=rep(0, 4))
map(xlim=range(map5$x, na.rm=T), ylim=range(map5$y, na.rm=T), col=NA, mar=rep(0, 4))
points(long[selo], lat[selo], col=colz[2], cex=3, lwd=2)
windows(h=6, w=10)
par(mar=rep(0, 4))
map(xlim=range(map5$x, na.rm=T), ylim=range(map5$y, na.rm=T), col=NA, mar=rep(0, 4))
points(long[selm], lat[selm], col=colz[1], cex=2, lwd=2)
legend("right", c("Trapped", "Untrapped"), pt.cex=c(3, 2), pt.lwd=2, col=colz[2:1], pch=1, bty="n")
### index streams
# 2014-04-09 Jess and Gale agreed that the East Au Gres (38) should be replaced with the Au Sable (36) in Lake Huron
# 2014-04-10 Jess thinks that we should just stick with the East Au Gres (38)
index.streams <- list(
Sup = c(1, 2, 9, 29, 31, 32, 62),
Mic = c(5, 6, 15, 24, 26, 35),
Hur = c(10, 16, 27, 32, 999, 38),
Eri = c(1, 2, 3, 7, 9),
Ont = c(5, 9, 22, 23, 36)
)
index.streams <- lapply(1:5, function(i) i + index.streams[[i]]/1000)
### plots of time series
look <- table(ls, year, est.source=="model")
# just last 10 years
look2 <- apply(look[, 29:38, ], c(1, 3), sum)
look3 <- look2[look2[, 1]>0 & look2[, 2]>0, ]
look3[order(look3[, 1] - look3[, 2]), ]
dat[match(rownames(look3), ls), 1:10]
#dat[match(unlist(index.streams), ls), 1:10]
plotit <- function(mylake, lss, llog="y", yrcut=2004.5, ...) {
selall <- lake==mylake & year > yrcut
lss2 <- ls[lake==mylake & year==2014 & ls %in% lss]
windows(h=5.5, w=3.3)
par(mar=c(4, 4, 1, 1))
if(llog=="y") {
fac <- 1
ylabb <- "Adults"
} else {
fac <- 1000
ylabb <- "Adults  (thousands)"
}
plot(year[selall], combPE[selall]/fac, type="n", las=1, log=llog, xlab="Year", ylab=ylabb, ...)
for(i in seq(lss2)) {
sel2 <- lake==mylake & year > yrcut & ls==lss2[i]
lines(year[sel2], combPE[sel2]/fac, col=colkey$colx[colkey$ls==lss2[i]], lty=2)
y <- ifelse(est.source[sel2]=="model", NA, combPE[sel2])
lines(year[sel2], y/fac, col=colkey$colx[colkey$ls==lss2[i]], type="o", pch=16, cex=1.2, lwd=2)
}
}
mapit <- function(mylake, lss, ...) {
lss2 <- ls[lake==mylake & year==2014 & ls %in% lss]
windows(h=5, w=8)
par(mar=c(0, 6, 0, 6))
map(xlim=range(mapL[[mylake]]$x, na.rm=T), ylim=range(mapL[[mylake]]$y, na.rm=T), col=NA, mar=c(0, 6, 0, 6))
lines(mapL[[mylake]]$x, mapL[[mylake]]$y, col="darkgray", lwd=0.5)
par(xpd=NA)
for(i in seq(lss2)) {
sel <- lake==mylake & year==2014 & ls==lss2[i]
points(long[sel], lat[sel], col=colkey$colx[colkey$ls==lss2[i]], pch=16, cex=1.5)
text(long[sel], lat[sel], strname[sel], col=colkey$colx[colkey$ls==lss2[i]], ...)
}
}
# all non-model time series
lsbest <- as.numeric(rownames(look2[look2[, "TRUE"]==0, ]))
# all model time series
lsmodel <- as.numeric(rownames(look2[look2[, "FALSE"]==0, ]))
# mixed time series
lsmixed <- as.numeric(rownames(look2[look2[, "TRUE"]!=0 & look2[, "FALSE"]!=0, ]))
# create a color key
yrcut <- 2004.5
sub <- dat[year > yrcut, c("year", "ls", "combPE")]
medPE <- tapply(sub$combPE, sub$ls, median)
df1 <- cbind(medPE, ls=as.numeric(names(medPE)))
df2 <- cbind(ls=c(lsbest, lsmodel, lsmixed), group=rep(c("1best", "2model", "3mixed"), c(length(lsbest), length(lsmodel), length(lsmixed))))
colkey <- merge(df1, df2)
colkey$lake <- floor(colkey$ls)
colkey <- colkey[order(colkey$lake, colkey$group, -colkey$medPE), ]
colkey$lg <- paste(colkey$lake, colkey$group)
colkey$coli <- unlist(tapply(-colkey$medPE, colkey$lg, rank, ties.method="random"))
colkey$colx <- colz[colkey$coli]
head(colkey)
plotit(3, lsbest)
plotit(3, lsmodel)
plotit(3, lsmixed)
plotit(3, lsbest, "")
plotit(3, lsmodel, "")
plotit(3, lsmixed, "")
dat[lake==3 & year==2008 & combPE > 6000, ]
dat[lake==3 & year>2004.5 & strname=="Garden", ]
mylake <- 3
plotit(3, lsbest[!(lsbest %in% index.streams[[3]])], "", ylim=range(combPE[lake==mylake & year > yrcut & ls %in% lsbest])/1000)
plotit(3, lsbest[lsbest %in% index.streams[[3]]], "", ylim=range(combPE[lake==mylake & year > yrcut & ls %in% lsbest])/1000)
mapit(3, lsbest[!(lsbest %in% index.streams[[3]])], pos=2, font=1, cex=1.2)
mapit(3, lsbest[lsbest %in% index.streams[[3]]], pos=4, font=2, cex=1.5)
# estimate adult index of abundance for each lake using index streams
indices <- lapply(index.streams, index.est, dat, lk)
# combine index data for all lakes in one dataframe
indxall <- do.call(rbind, lapply(indices, "[[", "indxdf"))
# calculate targets 
sptargyrz <- list(1994:1998, 1988:1992, 1989:1993, 1991:1995, 1999:2003)
targyrz <- apply(sapply(sptargyrz, range), 2, paste, collapse="-")
# spawner model
targets.sm <- calctarg(lakenum=lk$lake, adults=lk$PE, year=lk$year, targyears=sptargyrz)
# adult index
targets.ai <- calctarg(lakenum=indxall$lake, adults=indxall$indxkeep, year=indxall$year, targyears=sptargyrz)
# spawner model targets scaled down to adult index
targets.sm.su <- cbind(lake=targets.sm[, 1], (1/sapply(indices, "[[", "scaleup")) * targets.sm[, -1])
# adult index adjusted
targets.ai.adj <- targets.ai
targets.ai.adj[is.na(targets.ai$target), ] <- targets.sm.su[is.na(targets.ai$target), ]
YEAR1 <- 1984
outcex <- 1.2
YEARb <- 2005
### bar plot of individual index stream PEs
fig <- function(mylake) {
windows(h=5.5, w=5.5)
par(mar=c(4, 4, 1, 4), yaxs="i", cex=1.2)
mystreamdf <- indices[[mylake]]$streamdf
myindxdf <- indices[[mylake]]$indxdf
convfac <- indices[[mylake]]$scaleup
mystreamdf <- mystreamdf[mystreamdf$year >= YEARb, ]
myindxdf <- myindxdf[myindxdf$year >= YEARb, ]
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p[is.na(myindxdf$indxkeep), ] <- NA
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
mycol <- colkey$colx[match(dat$ls[match(colnames(p), substring(dat$strname, 1, 10))], colkey$ls)]
a <- barplot(t(p)/1000, las=1, col=mycol, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.03*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="Year", ylab="Index Adults  (thousands)", border=NA)
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2, las=1)
anntotals <- apply(p, 1, sum)
prt <- pretty(convfac*c(0, anntotals))/1000
axis(4, at=prt/convfac, labels=prt, las=1)
mtext("Lake-wide Adults  (thousands)", side=4, line=3, cex=1.2)
box()
legend("topleft", rev(colnames(p)), fill=rev(mycol[1:dim(p)[2]]), cex=0.8, bty="n", border=NA)
}
fig(3)
### spawner model and adult index time series overlaid
fig <- function(mylake, sp=TRUE) {
windows(h=5.5, w=5.5)
par(mar=c(4, 4, 1, 4), yaxs="i", cex=1.2)
mylk <- lk[lk$lake==mylake, ]# lake year PE lo hi
myindxdf <- indices[[mylake]]$indxdf# year lake indxraw n.mr indxkeep indxkeep.lo indxkeep.hi
convfac <- indices[[mylake]]$scaleup
x1 <- myindxdf$year
y1 <- myindxdf$indxkeep/1000
x2 <- mylk$year
y2 <- mylk$PE/convfac/1000
yr <- 1.05*range(0, myindxdf$indxkeep.hi[x1>=YEARb]/1000, mylk$hi[x2>=YEARb]/convfac/1000, na.rm=TRUE)
plot(1, 1, type="n", xlim=range(lk$year[lk$year>=YEARb]), ylim=yr, xlab="Year", ylab="Index Adults  (thousands)", axes=FALSE)
axis(1)
axis(2, las=1)
par(mgp=c(3, 2.2, 0))
axis(4, at=pretty(convfac*yr)/convfac, labels=pretty(convfac*yr), las=1, hadj=1)
par(mgp=c(3, 1, 0))
box()
arrows(x1, myindxdf$indxkeep.lo/1000, x1, myindxdf$indxkeep.hi/1000, length=0, angle=90, code=3, lwd=10, lend="square", col="#ffddc1")
if(sp) {
arrows(x2, mylk$lo/convfac/1000, x1, mylk$hi/convfac/1000, length=0.05, angle=90, code=3, lwd=1, lend="square", col=blindcolz[3])
abline(h=targets.sm$target[mylake]/convfac/1000, col=blindcolz[3], lty=2)
legend("bottom", c("Adult index", "Current method"), col=blindcolz[c(7, 3)], lwd=2, pch=c(17, 18), bty="n")
}
abline(h=targets.ai.adj$target[mylake]/1000, col=blindcolz[7], lty=2)
if(sp) lines(x2, y2, col=blindcolz[3], type="o", pch=18, lwd=2)
lines(x1, y1, col=blindcolz[7], type="o", pch=17, lwd=2)
mtext("Lake-wide Adults  (thousands)", side=4, line=3, cex=1.2)
}
fig(3, FALSE)
fig(3)
cleanup()
q()
cm <- 0:20
dB <- 20*log10(cm) - 67.6
plot(dB, cm)
abline(v=-48)
plot(cm, dB)
plot(cm, dB, las=1)
par("usr")
cm <- 0:20
dB <- 20*log10(cm) - 67.6
dB66 <- 20*log10(6.6) - 67.6
cm48 <- 10^((-48 + 67.6)/20)
windows(h=3, w=4)
par(mar=c(4, 4, 1, 1), xaxs="i")
pusr <- par("usr")
plot(cm, dB, las=1, type="l", xlab="Total length  (cm)", ylab="Target strength  (dB)")
points(cm48, -48, col="blue")
lines(c(cm48, cm48, 0), c(pusr[3], -48, -48), lty=2, col="blue")
points(6.6, db66, col="red")
lines(c(6.6, 6.6, 0), c(pusr[3], db66, db66), lty=2, col="red")
> 
points(6.6, dB66, col="red")
lines(c(6.6, 6.6, 0), c(pusr[3], dB66, dB66), lty=2, col="red")
par(mar=c(4, 4, 1, 1), xaxs="i")
pusr <- par("usr")
plot(cm, dB, las=1, type="l", xlab="Total length  (cm)", ylab="Target strength  (dB)")
points(cm48, -48, col="blue")
lines(c(cm48, cm48, 0), c(pusr[4], -48, -48), lty=2, col="blue")
points(6.6, dB66, col="red")
lines(c(6.6, 6.6, 0), c(pusr[4], dB66, dB66), lty=2, col="red")
> pusr
pusr
par(mar=c(4, 4, 1, 1), xaxs="i")
pusr <- par("usr")
plot(cm, dB, las=1, type="l", xlab="Total length  (cm)", ylab="Target strength  (dB)")
points(cm48, -48, col="blue")
lines(c(cm48, cm48, 0), c(pusr[3], -48, -48), lty=2, col="blue")
points(6.6, dB66, col="red")
lines(c(6.6, 6.6, 0), c(pusr[3], dB66, dB66), lty=2, col="red")
par(mar=c(4, 4, 1, 1), xaxs="i", yaxs="i")
pusr <- par("usr")
plot(cm, dB, las=1, type="l", xlab="Total length  (cm)", ylab="Target strength  (dB)")
points(cm48, -48, col="blue")
lines(c(cm48, cm48, 0), c(pusr[3], -48, -48), lty=2, col="blue")
points(6.6, dB66, col="red")
lines(c(6.6, 6.6, 0), c(pusr[3], dB66, dB66), lty=2, col="red")
par(mar=c(4, 4, 1, 1), xaxs="i", yaxs="i")
pusr <- par("usr")
plot(cm, dB, las=1, type="l", xlab="Total length  (cm)", ylab="Target strength  (dB)")
points(cm48, -48, pch=16, col="blue")
text(cm48, -48, paste0("(", round(cm48, 1), "-48)"), col="blue", pos=4)
lines(c(cm48, cm48, 0), c(pusr[3], -48, -48), lty=2, col="blue")
points(6.6, dB66, pch=16, col="red")
text(6.6, dB66, paste0("(6.6, ", round(dB66, 1), ")"), col="red", pos=4)
lines(c(6.6, 6.6, 0), c(pusr[3], dB66, dB66), lty=2, col="red")
par(mar=c(4, 4, 1, 1), xaxs="i", yaxs="i")
pusr <- par("usr")
plot(cm, dB, las=1, type="l", xlab="Total length  (cm)", ylab="Target strength  (dB)")
points(cm48, -48, pch=16, col="blue")
text(cm48, -48, paste0("(", round(cm48, 1), ", -48.0)"), col="blue", pos=4)
lines(c(cm48, cm48, 0), c(pusr[3], -48, -48), lty=2, col="blue")
points(6.6, dB66, pch=16, col="red")
text(6.6, dB66, paste0("(6.6, ", round(dB66, 1), ")"), col="red", pos=4)
lines(c(6.6, 6.6, 0), c(pusr[3], dB66, dB66), lty=2, col="red")
cleanup()
q()
library(devtools)
?find_rtools
find_rtools()
find_rtools(TRUE)
?capwords
q()
# C:\JVA\Admin\Duties\TallyTally.r
# by default, the data will be summarized for the current fiscal year
FY <- as.numeric(rev(strsplit(date(), " ")[[1]])[1])
start <- paste0(FY-1, "-10-01")
end <- paste0(FY, "-09-30")
#start <- paste0(2014, "-07-01")
#end <- paste0(2014, "-09-30")
wb <- loadWorkbook("C:/JVA/Admin/Duties/NewTally.xlsx")
dat <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=3)
dat$Hours <- as.numeric(dat$Hours)
sub <- dat[substring(dat$Date, 1, 10) >= start & substring(dat$Date, 1, 10) <= end, ]
look <- aggregate(Hours ~ Agency + PersonTask, data=sub, sum)
look2 <- look[order(look$Agency, look$Hours, decreasing=TRUE), c(1, 3, 2)]
look2
write.csv(look2, "C:/JVA/Admin/Duties/latest.csv", row.names=FALSE)
cleanup()
q()
df1<-data.frame(area=c(1,2),group1=c(2,3),group2=c(1,5),group3=c(4,0))
df1
df2<-data.frame(person_id=seq(1:15),area=c(rep(1,7),rep(2,8)),group_num=c(1,1,2,3,3,3,3,1,1,1,2,2,2,2,2))
df2
q()
?cheat
# C:\JVA\Consult\Deines\ExploreChla.r
library(lubridate)
library(rtf)
# read in the data
dat <- read.csv("C:/JVA/Consult/Deines/master_harvest_chl_metadata.csv")
?save
FishSpecies <- dat
save(FishSpecies)
save(FishSpecies, FishSpecies.RData)
save(FishSpecies, "FishSpecies.RData")
save(FishSpecies, file="FishSpecies.RData")
?cheat
q()
install.packages("Deducer",,"http://rforge.net/")
library(Deducer)
q()
# C:\JVA\GLFC\People\Miehls\game.r
# Game with 29/294 vs. 0/66 to help get a sense of how different they really are ... Bayesian approach?  
# Assume some percentages and ask what the probability is of seeing this result?
c1 <- 294
r1 <- 29
c2 <- 66
r2 <- 0
m <- matrix(c1-r1, r1, c2-r2, r2, nrow=2)
chi(m)
m <- matrix(c(c1-r1, r1, c2-r2, r2), nrow=2)
chi(m)
ctot <- c1 + c2
rtot <- r1 + r2
ptot <- rtot/ctot
ptot
sample
ctot <- c1 + c2
rtot <- r1 + r2
ptot <- rtot/ctot
# Monte Carlo simulation
nsim <- 100
results <- data.frame(sr1=NA, sr2=NA)
for(i in 1:nsim) {
results$sr1[i] <- sample(0:1, size=c1, replace=TRUE, prob=c(1-ptot, ptot))
results$sr2[i] <- sample(0:1, size=c1, replace=TRUE, prob=c(1-ptot, ptot))
}
results
# Monte Carlo simulation
nsim <- 100
results <- data.frame(sr1=rep(NA, nsim), sr2=rep(NA, nsim))
for(i in 1:nsim) {
results$sr1[i] <- sample(0:1, size=c1, replace=TRUE, prob=c(1-ptot, ptot))
results$sr2[i] <- sample(0:1, size=c1, replace=TRUE, prob=c(1-ptot, ptot))
}
warnings()
# Monte Carlo simulation
nsim <- 100
results <- data.frame(sr1=rep(NA, nsim), sr2=rep(NA, nsim))
for(i in 1:nsim) {
results$sr1[i] <- sum(sample(0:1, size=c1, replace=TRUE, prob=c(1-ptot, ptot)))
results$sr2[i] <- sum(sample(0:1, size=c1, replace=TRUE, prob=c(1-ptot, ptot)))
}
head(results)
# Monte Carlo simulation
nsim <- 100
results <- data.frame(sr1=rep(NA, nsim), sr2=rep(NA, nsim))
for(i in 1:nsim) {
results$sr1[i] <- sum(sample(0:1, size=c1, replace=TRUE, prob=c(1-ptot, ptot)))
results$sr2[i] <- sum(sample(0:1, size=c2, replace=TRUE, prob=c(1-ptot, ptot)))
}
head(results)
results$extreme <- results$sr1 >= r1 & results$sr2 <= r2
table(results$extreme)
windows(h=8, w=6.5)
par(mfrow=c(2, 1), mar=c(4, 4, 1, 1))
hist(results$sr1)
hist(results$sr2)
hist
args(hist)
?hist
brks <- 0:max(results$sr1)
windows(h=8, w=6.5)
par(mfrow=c(2, 1), mar=c(4, 4, 1, 1))
hist(results$sr1, breaks=brks)
hist(results$sr2, breaks=brks)
par(mfrow=c(2, 1), mar=c(4, 4, 1, 1), las=1)
hist(results$sr1, breaks=brks, col="skyblue", xlab="Trap catch")
hist(results$sr2, breaks=brks, col="skyblue", xlab="Fish wheel catch")
par(mfrow=c(2, 1), mar=c(4, 4, 1, 1), las=1)
hist(results$sr1, breaks=brks, col="skyblue", xlab="Trap catch")
abline(v=r1, col="orange", lwd=2)
hist(results$sr2, breaks=brks, col="skyblue", xlab="Fish wheel catch")
abline(v=r2, col="orange", lwd=2)
brks <- seq(-0.5, max(results$sr1)+0.5, 1)
windows(h=8, w=6.5)
par(mfrow=c(2, 1), mar=c(4, 4, 1, 1), las=1)
hist(results$sr1, breaks=brks, col="skyblue", xlab="Trap catch")
abline(v=r1, col="orange", lwd=2)
hist(results$sr2, breaks=brks, col="skyblue", xlab="Fish wheel catch")
abline(v=r2, col="orange", lwd=2)
par(mfrow=c(2, 1), mar=c(4, 4, 1, 1), las=1)
hist(results$sr1, breaks=brks, col="skyblue", xlab="Trap catch", main="")
abline(v=r1, col="orange", lwd=2)
hist(results$sr2, breaks=brks, col="skyblue", xlab="Fish wheel catch", main="")
abline(v=r2, col="orange", lwd=2)
windows(h=8, w=6.5)
par(mfrow=c(2, 1), mar=c(4, 4, 1, 1), las=1, yaxs="i")
hist(results$sr1, breaks=brks, col="skyblue", xlab="Trap catch", main="")
abline(v=r1, col="orange", lwd=2)
hist(results$sr2, breaks=brks, col="skyblue", xlab="Fish wheel catch", main="")
abline(v=r2, col="orange", lwd=2)
box()
par(mfrow=c(2, 1), mar=c(3, 4, 2, 1), las=1, yaxs="i")
hist(results$sr1, breaks=brks, col="skyblue", xlab="Trap catch", main="")
abline(v=r1, col="orange", lwd=2)
hist(results$sr2, breaks=brks, col="skyblue", xlab="Fish wheel catch", main="")
abline(v=r2, col="orange", lwd=2)
par(mfrow=c(2, 1), mar=c(4, 4, 2, 1), oma=c(0, 1, 0, 0), las=1, yaxs="i")
hist(results$sr1, breaks=brks, col="skyblue", xlab="Trap catch", ylab="", main="")
abline(v=r1, col="orange", lwd=2)
hist(results$sr2, breaks=brks, col="skyblue", xlab="Fish wheel catch", ylab="", main="")
abline(v=r2, col="orange", lwd=2)
mtext("Frequency", side=2, outer=TRUE)
mtext("Frequency", side=2, outer=TRUE, las=0)
par(mfrow=c(2, 1), mar=c(4, 3, 2, 1), oma=c(0, 1, 0, 0), las=1, yaxs="i")
hist(results$sr1, breaks=brks, col="skyblue", xlab="Trap catch", ylab="", main="")
abline(v=r1, col="orange", lwd=2)
hist(results$sr2, breaks=brks, col="skyblue", xlab="Fish wheel catch", ylab="", main="")
abline(v=r2, col="orange", lwd=2)
mtext("Frequency", side=2, outer=TRUE, las=0)
# Randomization / Permutation Test
catch <- rep(c("Trap", "Wheel"), c(c1, c2))
recap <- sample(rep(0:1, c(c1+c2-r1-r2, r1+r2))
)
catch
recap
# Randomization / Permutation Test
catch <- rep(c("Trap", "Wheel"), c(c1, c2))
rp <- data.frame(sr1=rep(NA, nsim), sr2=rep(NA, nsim))
for(i in 1:nsim) {
recap <- sample(rep(0:1, c(c1+c2-r1-r2, r1+r2))
rp$sr1[i] <- sum(recap==0)
rp$sr2[i] <- sum(recap)
}
rp$extreme <- rp$sr1 >= r1 & rp$sr2 <= r2
table(rp$extreme)
# Randomization / Permutation Test
catch <- rep(c("Trap", "Wheel"), c(c1, c2))
rp <- data.frame(sr1=rep(NA, nsim), sr2=rep(NA, nsim))
for(i in 1:nsim) {
recap <- sample(rep(0:1, c(c1+c2-r1-r2, r1+r2)))
rp$sr1[i] <- sum(recap==0)
rp$sr2[i] <- sum(recap)
}
rp$extreme <- rp$sr1 >= r1 & rp$sr2 <= r2
table(rp$extreme)
brks <- seq(-0.5, max(rp$sr1)+0.5, 1)
windows(h=8, w=6.5)
par(mfrow=c(2, 1), mar=c(4, 3, 2, 1), oma=c(0, 1, 0, 0), las=1, yaxs="i")
hist(rp$sr1, breaks=brks, col="skyblue", xlab="Trap catch", ylab="", main="")
abline(v=r1, col="orange", lwd=2)
hist(rp$sr2, breaks=brks, col="skyblue", xlab="Fish wheel catch", ylab="", main="")
abline(v=r2, col="orange", lwd=2)
mtext("Frequency", side=2, outer=TRUE, las=0)
rp
# Randomization / Permutation Test
catch <- rep(c("Trap", "Wheel"), c(c1, c2))
rp <- data.frame(sr1=rep(NA, nsim), sr2=rep(NA, nsim))
for(i in 1:nsim) {
recap <- sample(rep(0:1, c(c1+c2-r1-r2, r1+r2)))
rp$sr1[i] <- sum(recap[catch=="Trap"])
rp$sr2[i] <- sum(recap[catch=="Wheel"])
}
rp
apply(rp, 1, sum)
table(apply(rp, 1, sum))
# Randomization / Permutation Test
catch <- rep(c("Trap", "Wheel"), c(c1, c2))
rp <- data.frame(sr1=rep(NA, nsim), sr2=rep(NA, nsim))
for(i in 1:nsim) {
recap <- sample(rep(0:1, c(c1+c2-r1-r2, r1+r2)))
rp$sr1[i] <- sum(recap[catch=="Trap"])
rp$sr2[i] <- sum(recap[catch=="Wheel"])
}
rp$extreme <- rp$sr1 >= r1 & rp$sr2 <= r2
table(rp$extreme)
brks <- seq(-0.5, max(rp$sr1)+0.5, 1)
windows(h=8, w=6.5)
par(mfrow=c(2, 1), mar=c(4, 3, 2, 1), oma=c(0, 1, 0, 0), las=1, yaxs="i")
hist(rp$sr1, breaks=brks, col="skyblue", xlab="Trap catch", ylab="", main="")
abline(v=r1, col="orange", lwd=2)
hist(rp$sr2, breaks=brks, col="skyblue", xlab="Fish wheel catch", ylab="", main="")
abline(v=r2, col="orange", lwd=2)
mtext("Frequency", side=2, outer=TRUE, las=0)
graphics.off()
# C:\JVA\GLFC\People\Miehls\game.r
# Game with 29/294 vs. 0/66 to help get a sense of how different they really are ... Bayesian approach?  
# Assume some percentages and ask what the probability is of seeing this result?
c1 <- 294
r1 <- 29
c2 <- 66
r2 <- 0
m <- matrix(c(c1-r1, r1, c2-r2, r2), nrow=2)
chi(m)
ctot <- c1 + c2
rtot <- r1 + r2
ptot <- rtot/ctot
nsim <- 100
# Randomization / Permutation Test
catch <- rep(c("Trap", "Wheel"), c(c1, c2))
rp <- data.frame(sr1=rep(NA, nsim), sr2=rep(NA, nsim))
for(i in 1:nsim) {
recap <- sample(rep(0:1, c(c1+c2-r1-r2, r1+r2)))
rp$sr1[i] <- sum(recap[catch=="Trap"])
rp$sr2[i] <- sum(recap[catch=="Wheel"])
}
rp$extreme <- rp$sr1 >= r1 & rp$sr2 <= r2
table(rp$extreme)
brks <- seq(-0.5, max(rp$sr1)+0.5, 1)
windows(h=8, w=6.5)
par(mfrow=c(2, 1), mar=c(4, 3, 2, 1), oma=c(0, 1, 2, 0), las=1, yaxs="i")
hist(rp$sr1, breaks=brks, col="skyblue", xlab="Trap catch", ylab="", main="")
abline(v=r1, col="orange", lwd=2)
hist(rp$sr2, breaks=brks, col="skyblue", xlab="Fish wheel catch", ylab="", main="")
abline(v=r2, col="orange", lwd=2)
mtext("Frequency", side=2, outer=TRUE, las=0)
mtext("Randomization", side=3, outer=TRUE)
# Monte Carlo simulation
mc <- data.frame(sr1=rep(NA, nsim), sr2=rep(NA, nsim))
for(i in 1:nsim) {
mc$sr1[i] <- sum(sample(0:1, size=c1, replace=TRUE, prob=c(1-ptot, ptot)))
mc$sr2[i] <- sum(sample(0:1, size=c2, replace=TRUE, prob=c(1-ptot, ptot)))
}
mc$extreme <- mc$sr1 >= r1 & mc$sr2 <= r2
table(mc$extreme)
brks <- seq(-0.5, max(mc$sr1)+0.5, 1)
windows(h=8, w=6.5)
par(mfrow=c(2, 1), mar=c(4, 3, 2, 1), oma=c(0, 1, 2, 0), las=1, yaxs="i")
hist(mc$sr1, breaks=brks, col="skyblue", xlab="Trap catch", ylab="", main="")
abline(v=r1, col="orange", lwd=2)
hist(mc$sr2, breaks=brks, col="skyblue", xlab="Fish wheel catch", ylab="", main="")
abline(v=r2, col="orange", lwd=2)
mtext("Frequency", side=2, outer=TRUE, las=0)
mtext("Monte Carlo Simulation", side=3, outer=TRUE)
# C:\JVA\GLFC\People\Miehls\game.r
# Game with 29/294 vs. 0/66 to help get a sense of how different they really are ... Bayesian approach?  
# Assume some percentages and ask what the probability is of seeing this result?
c1 <- 294
r1 <- 29
c2 <- 66
r2 <- 0
m <- matrix(c(c1-r1, r1, c2-r2, r2), nrow=2)
chi(m)
ctot <- c1 + c2
rtot <- r1 + r2
ptot <- rtot/ctot
nsim <- 100
plotit <- function(df, title) {
windows(h=8, w=6.5)
par(mfrow=c(2, 1), mar=c(4, 3, 2, 1), oma=c(0, 1, 2, 0), las=1, yaxs="i")
hist(df$sr1, breaks=brks, col="skyblue", xlab="Trap catch", ylab="", main="")
abline(v=r1, col="orange", lwd=2)
hist(df$sr2, breaks=brks, col="skyblue", xlab="Fish wheel catch", ylab="", main="")
abline(v=r2, col="orange", lwd=2)
mtext("Frequency", side=2, outer=TRUE, las=0)
mtext(title, side=3, outer=TRUE)
}
# Randomization / Permutation Test
catch <- rep(c("Trap", "Wheel"), c(c1, c2))
rp <- data.frame(sr1=rep(NA, nsim), sr2=rep(NA, nsim))
for(i in 1:nsim) {
recap <- sample(rep(0:1, c(c1+c2-r1-r2, r1+r2)))
rp$sr1[i] <- sum(recap[catch=="Trap"])
rp$sr2[i] <- sum(recap[catch=="Wheel"])
}
rp$extreme <- rp$sr1 >= r1 & rp$sr2 <= r2
table(rp$extreme)
brks <- seq(-0.5, max(rp$sr1)+0.5, 1)
plotit(rp, "Randomization")
# Monte Carlo simulation
mc <- data.frame(sr1=rep(NA, nsim), sr2=rep(NA, nsim))
for(i in 1:nsim) {
mc$sr1[i] <- sum(sample(0:1, size=c1, replace=TRUE, prob=c(1-ptot, ptot)))
mc$sr2[i] <- sum(sample(0:1, size=c2, replace=TRUE, prob=c(1-ptot, ptot)))
}
mc$extreme <- mc$sr1 >= r1 & mc$sr2 <= r2
table(mc$extreme)
brks <- seq(-0.5, max(mc$sr1)+0.5, 1)
plotit(mc, "Monte Carlo Simulation")
?chi
chi <- function(x, rpct=0, print=TRUE, plot=TRUE) {
if(plot | print) {
sum1 <- apply(x, 1, sum)
sum2 <- apply(x, 2, sum)
exp <- outer(sum1, sum2)/sum(x) # contribution to chi square
cont <- (x - exp)^2/exp
cutoff <- qchisq(p=0.95, df=prod(dim(x)-1))
cont.ord <- sort(as.vector(cont))
major <- rev(cont.ord[cumsum(cont.ord)>cutoff])
}
if(plot) {
plot(sort(cont), pch = 16)
}
if(print) {
cat("\nExpected percentages\n")
print(round((100 * exp)/apply(exp, 1, sum), rpct))
cat("\nObserved percentages\n")
print(round((100 * x)/sum1, rpct))
cat("\nContribution to chi square\n")
print(round(cont, 1))
cat("\nCutoff\n")
print(cutoff)
cat("\nMajor players\n")
print(major)
}
chisq.test(x)
}
chi(m)
chi(m, plot=FALSE)
chi(m, print=FALSE)
chi(m, print=FALSE, plot=FALSE)
a <- chi(m, print=FALSE, plot=FALSE)
a
?cheat
library(devtools)
setwd("C:/JVA/GitHub/jvamisc")
document()
cleanup()
q()
