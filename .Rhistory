dimnames(m)[[2]] <- varnames
# right side of the formula
rightside <- apply(m, 1, function(row) paste(varnames[row==1], collapse=" + "))
# if no predictors, use 1 to represent intercept only model
rightside[rightside==""] <- "1"
form <- paste("amphibi ~", rightside)
fits <- lapply(form, function(f) lm(formula(f), dat=mydat))
# AIC table
aictab <- AICc(fits)
bigtab <- cbind(formula=rightside[aictab$model], aictab)
nmodzfit <- dim(bigtab)[1]
# top models
topmods <- bigtab[bigtab$daicc < 2, ]
# add coefficients to top model
coef <- lapply(fits[topmods$model], coef)
xmod <- unique(unlist(lapply(coef, names)))
topcoef <- t(sapply(coef, function(x) 
{
blank <- rep(0, length(xmod))
blank[match(names(x), xmod)] <- x
blank
}))
dimnames(topcoef)[[2]] <- xmod
topmods <- cbind(signif(topcoef, 3), round(topmods[, c("n", "p", "rmse", "aicc", "daicc", "aiccw")], 2))
# single best model
bestnum <- bigtab$model[1]
bestfit <- fits[[bestnum]]
xvarz <- varnames[m[bestnum, ]==1]
# output
out <- list(xvarz=xvarz, nmodzfit=nmodzfit, bestfit=bestfit, topmods=topmods, allfits=fits, allmods=bigtab, allpreds=m)
print(out[1:4])
out
}
assess.fit <- function(fit, newd) {
p <- predict(fit, newdata=newd)
y <- newd$amphibi
r <- p - y
rmse <- sqrt(mean(r^2))
r2 <- calcr2(fitted=p, observed=y, nparam=length(labels(terms(freshfita)))+1)
list(cbind(p=p, y=y, r=r), rmse=rmse, r2=r2)
}
# assign each observation to one of three groups
# ensure even distribution of groups across vegetation classes and latitudes
dat3 <- dat2[order(dat2$veg.class, dat2$lat.dd), ]
dat3$group <- rep(1:3, length.out=dim(dat2)[1])
df <- dat3
attach(df)
suv <- sort(unique(veg.class))
windows(h=6.5, w=6.5)
map("state", mar=c(1, 1, 1, 1), region= "ohio", col="darkgray", lwd=2)
for(i in seq(suv)) {
sel <- veg.class==suv[i]
points(lon.dd[sel], lat.dd[sel], cex=2, lwd=2, pch=c(2, 1)[i], col=group[sel]+1)
}
#legend("bottomright", capwords(suv), pch=c(2, 1), col=c("black", "gray"), pt.lwd=2, pt.cex=2, cex=1.15, title="Veg. Class")
par(usr=c(-126, 94, 21, 193), xpd=NA)
polygon(c(-128, -128, -64, -64, -128), c(22, 52, 52, 22, 22), col="white", lwd=2)
map("state", add=T, mar=c(0, 0, 0, 0)) 
map("state", region="ohio", fill=T, add=T) 
detach(df)
ls()
search()
detach()
attach(df)
suv <- sort(unique(veg.class))
windows(h=6.5, w=6.5)
map("state", mar=c(1, 1, 1, 1), region= "ohio", col="darkgray", lwd=2)
for(i in seq(suv)) {
sel <- veg.class==suv[i]
points(lon.dd[sel], lat.dd[sel], cex=2, lwd=2, pch=c(2, 1)[i], col=group[sel]+1)
}
#legend("bottomright", capwords(suv), pch=c(2, 1), col=c("black", "gray"), pt.lwd=2, pt.cex=2, cex=1.15, title="Veg. Class")
par(usr=c(-126, 94, 21, 193), xpd=NA)
polygon(c(-128, -128, -64, -64, -128), c(22, 52, 52, 22, 22), col="white", lwd=2)
map("state", add=T, mar=c(0, 0, 0, 0)) 
map("state", region="ohio", fill=T, add=T) 
detach(df)
graphics.off()
# step 1, select variables
# limit the number of variables in each model, such that no more than n/10 coefficients are estimated, following Burnham and Anderson (2002)
maxxvar <- round(dim(df)[1]/3/10)
ga <- select.varz(varnames=varz1, mydat=df[df$group==1, ], max.no.ind.var=maxxvar)
gb <- select.varz(varnames=varz1, mydat=df[df$group==2, ], max.no.ind.var=maxxvar)
gc <- select.varz(varnames=varz1, mydat=df[df$group==3, ], max.no.ind.var=maxxvar)
# step 1, select variables
# limit the number of variables in each model, such that no more than n/10 coefficients are estimated, following Burnham and Anderson (2002)
maxxvar <- round(dim(df)[1]/3/10)
ga <- select.varz(varnames=varz1, mydat=df[df$group==1, ], max.no.ind.var=maxxvar)
gb <- select.varz(varnames=varz1, mydat=df[df$group==2, ], max.no.ind.var=maxxvar)
gc <- select.varz(varnames=varz1, mydat=df[df$group==3, ], max.no.ind.var=maxxvar)
# step 1, select variables
# limit the number of variables in each model, such that no more than n/10 coefficients are estimated, following Burnham and Anderson (2002)
maxxvar <- round(dim(df)[1]/3/10)
ga <- select.varz(varnames=varz1, mydat=df[df$group==1, ], max.no.ind.var=maxxvar)
gb <- select.varz(varnames=varz1, mydat=df[df$group==2, ], max.no.ind.var=maxxvar)
gc <- select.varz(varnames=varz1, mydat=df[df$group==3, ], max.no.ind.var=maxxvar)
round(ct[rev(order(ct[, "r"])), ], 4)
0.05/length(varz1)
addedvar(Y=mtcars$hp, X=mtcars[, c("mpg", "disp", "wt")], main="Predicting horsepower from MPG, displacement, and weight")
addedvar(Y=df$amphibi[df$group==1], X=df[df$group==1, c("metric4", "metric6")], main="Predicting amphIBI")
windows(w=4, h=6)
with(df[df$group==1, ], {
plot(metric4, metric6, type="n")
symbols(metric4, metric6, circles=amphibi, inches=0.4)
})
windows(w=4, h=6)
addedvar(Y=df$amphibi[df$group==1], X=df[df$group==1, c("metric4", "metric6")], main="Predicting amphIBI")
addedvar
#' Added variable plots of predictors
#'
#' Produces an added variable plot given 1 response and 2 or more predictors.
#' @param Y a vector representing a single response
#' @param X two or more predictor columns in a matrix or dataframe
#' @param main subtitle for the plot
#' @return a plot is sent to the current graphics device (no value is returned)
#' @export
#' @examples addedvar(Y=mtcars$hp, X=mtcars[, c("mpg", "disp", "wt")], main="Predicting horsepower from MPG, displacement, and weight")
addedvar <- function(Y, X, main="") {
# Added variable plots of predictors
# Y is one response vector
# X is two or more predictor columns in a matrix or dataframe
# main is a subtitle for the plot
# calculate the number of predictors, and assign them names
p <- ncol(X)
if(p < 2) cat("There must be at least two predictors to construct added variable plots. \n")
if(is.null(dimnames(X)[[2]])) pnames <- paste("X", 1:p, sep="") else pnames <- dimnames(X)[[2]]
if(any(is.na(X))) cat("Observations with missing values will be excluded from procedure. \n")
# develop the full model with all predictors included
fullmodel <- "Y ~ X[, 1]"
if(p > 1) {
for(i in 2:p) fullmodel <- paste(fullmodel, " + X[, ", i, "]", sep="")
}
# fit the full model with each of the predictors excluded in turn
plotcols <- ceiling(sqrt(p - 1))
plotrows <- ceiling(p/plotcols)
par(mar = c(1, 1, 2, 1), mfrow = c(plotrows, plotcols), oma = c(3, 3, 5, 0), pty="s")
for(i in 1:p) {
noxk <- paste("~ . - X[, ", i, "]", sep="")
xkfory <- paste("X[, ", i, "] ~ .", sep="")
modelnoxk <- update(formula(fullmodel), noxk)
modelxkfory <- update(modelnoxk, xkfory)
resy <- residuals(lm(modelnoxk, na.action=na.omit))
resxk <- residuals(lm(modelxkfory, na.action=na.omit))
plot(resxk, resy, main=pnames[i], xlab="", ylab="", xaxt="n", yaxt="n")
abline(lsfit(resxk, resy))
}
mtext("Variability in the predictor not explained by other predictors", side=1, outer=T, line=1, cex=1)
mtext("Variability in the response not explained by other predictors", side=2, outer=T, line=1, cex=1, las=0)
mtext("Added variable plots for predictors", side=3, outer=T, line=3, cex=1.5)
mtext(main, side=3, outer=T, line=1.5, cex=1)
}
windows(w=4, h=6)
addedvar(Y=df$amphibi[df$group==1], X=df[df$group==1, c("metric4", "metric6")], main="Predicting amphIBI")
#' Added variable plots of predictors
#'
#' Produces an added variable plot given 1 response and 2 or more predictors.
#' @param Y a vector representing a single response
#' @param X two or more predictor columns in a matrix or dataframe
#' @param main subtitle for the plot
#' @return a plot is sent to the current graphics device (no value is returned)
#' @export
#' @examples addedvar(Y=mtcars$hp, X=mtcars[, c("mpg", "disp", "wt")], main="Predicting horsepower from MPG, displacement, and weight")
addedvar <- function(Y, X, main="") {
# Added variable plots of predictors
# Y is one response vector
# X is two or more predictor columns in a matrix or dataframe
# main is a subtitle for the plot
# calculate the number of predictors, and assign them names
p <- ncol(X)
if(p < 2) cat("There must be at least two predictors to construct added variable plots. \n")
if(is.null(dimnames(X)[[2]])) pnames <- paste("X", 1:p, sep="") else pnames <- dimnames(X)[[2]]
if(any(is.na(X))) cat("Observations with missing values will be excluded from procedure. \n")
# develop the full model with all predictors included
fullmodel <- "Y ~ X[, 1]"
if(p > 1) {
for(i in 2:p) fullmodel <- paste(fullmodel, " + X[, ", i, "]", sep="")
}
# fit the full model with each of the predictors excluded in turn
plotcols <- ceiling(sqrt(p - 1))
plotrows <- ceiling(p/plotcols)
par(mar = c(1, 1, 2, 1), mfrow = c(plotrows, plotcols), oma = c(3, 3, 3, 0), pty="s")
for(i in 1:p) {
noxk <- paste("~ . - X[, ", i, "]", sep="")
xkfory <- paste("X[, ", i, "] ~ .", sep="")
modelnoxk <- update(formula(fullmodel), noxk)
modelxkfory <- update(modelnoxk, xkfory)
resy <- residuals(lm(modelnoxk, na.action=na.omit))
resxk <- residuals(lm(modelxkfory, na.action=na.omit))
plot(resxk, resy, main=pnames[i], xlab="", ylab="", xaxt="n", yaxt="n")
abline(lsfit(resxk, resy))
}
mtext("Variability in xi not explained by other x!i", side=1, outer=T, line=1, cex=1)
mtext("Variability in y not explained by other x!i", side=2, outer=T, line=1, cex=1, las=0)
#mtext("Added variable plots for predictors", side=3, outer=T, line=3, cex=1.5)
mtext(main, side=3, outer=T, line=1.5, cex=1)
}
# exploring unexpected coefficient signs
# metric 6 had a positive correlation with amphibi, yet negative coeficient
windows(w=4, h=6)
addedvar(Y=df$amphibi[df$group==1], X=df[df$group==1, c("metric4", "metric6")], main="Predicting amphIBI")
#' Added variable plots of predictors
#'
#' Produces an added variable plot given 1 response and 2 or more predictors.
#' @param Y a vector representing a single response
#' @param X two or more predictor columns in a matrix or dataframe
#' @param main subtitle for the plot
#' @return a plot is sent to the current graphics device (no value is returned)
#' @export
#' @examples addedvar(Y=mtcars$hp, X=mtcars[, c("mpg", "disp", "wt")], main="Predicting horsepower from MPG, displacement, and weight")
addedvar <- function(Y, X, main="") {
# Added variable plots of predictors
# Y is one response vector
# X is two or more predictor columns in a matrix or dataframe
# main is a subtitle for the plot
# calculate the number of predictors, and assign them names
p <- ncol(X)
if(p < 2) cat("There must be at least two predictors to construct added variable plots. \n")
if(is.null(dimnames(X)[[2]])) pnames <- paste("X", 1:p, sep="") else pnames <- dimnames(X)[[2]]
if(any(is.na(X))) cat("Observations with missing values will be excluded from procedure. \n")
# develop the full model with all predictors included
fullmodel <- "Y ~ X[, 1]"
if(p > 1) {
for(i in 2:p) fullmodel <- paste(fullmodel, " + X[, ", i, "]", sep="")
}
# fit the full model with each of the predictors excluded in turn
plotcols <- ceiling(sqrt(p - 1))
plotrows <- ceiling(p/plotcols)
par(mar = c(1, 1, 1, 0), mfrow = c(plotrows, plotcols), oma = c(3, 3, 3, 0), pty="s")
for(i in 1:p) {
noxk <- paste("~ . - X[, ", i, "]", sep="")
xkfory <- paste("X[, ", i, "] ~ .", sep="")
modelnoxk <- update(formula(fullmodel), noxk)
modelxkfory <- update(modelnoxk, xkfory)
resy <- residuals(lm(modelnoxk, na.action=na.omit))
resxk <- residuals(lm(modelxkfory, na.action=na.omit))
plot(resxk, resy, main=pnames[i], xlab="", ylab="", xaxt="n", yaxt="n")
abline(lsfit(resxk, resy))
}
mtext("Variability in xi not explained by other x!i", side=1, outer=T, line=1, cex=1)
mtext("Variability in y not explained by other x!i", side=2, outer=T, line=1, cex=1, las=0)
#mtext("Added variable plots for predictors", side=3, outer=T, line=3, cex=1.5)
mtext(main, side=3, outer=T, line=1.5, cex=1)
}
# metric 6 had a positive correlation with amphibi, yet negative coeficient
windows(w=4, h=6)
addedvar(Y=df$amphibi[df$group==1], X=df[df$group==1, c("metric4", "metric6")], main="Predicting amphIBI")
#' Added variable plots of predictors
#'
#' Produces an added variable plot given 1 response and 2 or more predictors.
#' @param Y a vector representing a single response
#' @param X two or more predictor columns in a matrix or dataframe
#' @param main subtitle for the plot
#' @return a plot is sent to the current graphics device (no value is returned)
#' @export
#' @examples addedvar(Y=mtcars$hp, X=mtcars[, c("mpg", "disp", "wt")], main="Predicting horsepower from MPG, displacement, and weight")
addedvar <- function(Y, X, main="") {
# Added variable plots of predictors
# Y is one response vector
# X is two or more predictor columns in a matrix or dataframe
# main is a subtitle for the plot
# calculate the number of predictors, and assign them names
p <- ncol(X)
if(p < 2) cat("There must be at least two predictors to construct added variable plots. \n")
if(is.null(dimnames(X)[[2]])) pnames <- paste("X", 1:p, sep="") else pnames <- dimnames(X)[[2]]
if(any(is.na(X))) cat("Observations with missing values will be excluded from procedure. \n")
# develop the full model with all predictors included
fullmodel <- "Y ~ X[, 1]"
if(p > 1) {
for(i in 2:p) fullmodel <- paste(fullmodel, " + X[, ", i, "]", sep="")
}
# fit the full model with each of the predictors excluded in turn
plotcols <- ceiling(sqrt(p - 1))
plotrows <- ceiling(p/plotcols)
par(mar = c(0.5, 0.5, 1, 0), mfrow = c(plotrows, plotcols), oma = c(2, 2, 2, 0), pty="s")
for(i in 1:p) {
noxk <- paste("~ . - X[, ", i, "]", sep="")
xkfory <- paste("X[, ", i, "] ~ .", sep="")
modelnoxk <- update(formula(fullmodel), noxk)
modelxkfory <- update(modelnoxk, xkfory)
resy <- residuals(lm(modelnoxk, na.action=na.omit))
resxk <- residuals(lm(modelxkfory, na.action=na.omit))
plot(resxk, resy, main=pnames[i], xlab="", ylab="", xaxt="n", yaxt="n")
abline(lsfit(resxk, resy))
}
mtext("Variability in xi not explained by other x!i", side=1, outer=T, line=1, cex=1)
mtext("Variability in y not explained by other x!i", side=2, outer=T, line=1, cex=1, las=0)
#mtext("Added variable plots for predictors", side=3, outer=T, line=3, cex=1.5)
mtext(main, side=3, outer=T, line=1, cex=1)
}
# metric 6 had a positive correlation with amphibi, yet negative coeficient
windows(w=4, h=6)
addedvar(Y=df$amphibi[df$group==1], X=df[df$group==1, c("metric4", "metric6")], main="Predicting amphIBI")
# metric 6 had a positive correlation with amphibi, yet negative coeficient
windows(w=3, h=6)
addedvar(Y=df$amphibi[df$group==1], X=df[df$group==1, c("metric4", "metric6")], main="Predicting amphIBI")
# metric 6 had a positive correlation with amphibi, yet negative coeficient
windows(w=3.5, h=7)
addedvar(Y=df$amphibi[df$group==1], X=df[df$group==1, c("metric4", "metric6")], main="Predicting amphIBI")
# step 2, fit model
freshfita <- lm(ga$bestfit, dat=df[df$group==2, ])
freshfitb <- lm(gb$bestfit, dat=df[df$group==3, ])
freshfitc <- lm(gc$bestfit, dat=df[df$group==1, ])
summary(freshfita)
summary(freshfitb)
summary(freshfitc)
resa <- assess.fit(fit=freshfita, newd=df[df$group==3, ])
resb <- assess.fit(fit=freshfitb, newd=df[df$group==1, ])
resc <- assess.fit(fit=freshfitc, newd=df[df$group==2, ])
resa[-1]
resb[-1]
resc[-1]
xyr <- range(resa[[1]][, c("y", "p")], resb[[1]][, c("y", "p")], resc[[1]][, c("y", "p")])
windows()
par(mfrow=c(2, 2), pty="s", mar=c(3, 3, 2, 1), oma=c(2, 2, 0, 0))
plot(resa[[1]][, "y"], resa[[1]][, "p"], xlim=xyr, ylim=xyr, xlab="", ylab="", main="Group 3 predictions", las=1)
abline(0, 1)
plot(resb[[1]][, "y"], resb[[1]][, "p"], xlim=xyr, ylim=xyr, xlab="", ylab="", main="Group 1 predictions", las=1)
abline(0, 1)
plot(resc[[1]][, "y"], resc[[1]][, "p"], xlim=xyr, ylim=xyr, xlab="", ylab="", main="Group 2 predictions", las=1)
abline(0, 1)
mtext("Observed", side=1, outer=TRUE, cex=1.3)
mtext("Predicted", side=2, outer=TRUE, cex=1.3)
search()
attach(dat)
# several variables need to be log transformed
logk <- function(x) {
mx <- min(x, na.rm=TRUE)
if(mx<0) {
x <- x + abs(mx)
mx <- 0
}
k <- min(x[x>0], na.rm=TRUE)/2
print(k)
log(x + min(x[x>0], na.rm=TRUE)/2)
}
tranvar <- logk(as.vector(dat[, c("water", "forest", "wtld.forest", "wtld.emerg", "pasture", "row.crop", "suburban", "transitional", "rock", "urban")]))
choose(13, 1)
choose(13, 3)
choose(13, 2)
xyr <- range(resa[[1]][, c("y", "p")], resb[[1]][, c("y", "p")], resc[[1]][, c("y", "p")])
windows()
par(mfrow=c(2, 2), pty="s", mar=c(3, 3, 2, 1), oma=c(2, 2, 0, 0))
plot(resa[[1]][, "y"], resa[[1]][, "p"], xlim=xyr, ylim=xyr, xlab="", ylab="", main="Iteration A predictions", las=1)
abline(0, 1)
plot(resb[[1]][, "y"], resb[[1]][, "p"], xlim=xyr, ylim=xyr, xlab="", ylab="", main="Iteration B predictions", las=1)
abline(0, 1)
plot(resc[[1]][, "y"], resc[[1]][, "p"], xlim=xyr, ylim=xyr, xlab="", ylab="", main="Iteration C predictions", las=1)
abline(0, 1)
mtext("Observed", side=1, outer=TRUE, cex=1.3)
mtext("Predicted", side=2, outer=TRUE, cex=1.3)
cleanup()
search()
detach()
graphics.off()
?fread
??fread
require(data.table)
?fread
traps <- read.csv("C:\\JVA\\Lamprey\\Adults\\SpawnDisModel\\2009\\StreamPEDynamic.csv", as.is=T)
a <- read.csv("C:\\JVA\\Lamprey\\Adults\\SpawnDisModel\\2009\\StreamPEDynamic.csv", as.is=T)
b <- fread("C:\\JVA\\Lamprey\\Adults\\SpawnDisModel\\2009\\StreamPEDynamic.csv")
a <- read.csv("C:\\JVA\\Lamprey\\Adults\\SpawnDisModel\\2009\\StreamPEDynamic.csv", as.is=T)
b <- fread("C:\\JVA\\Lamprey\\Adults\\SpawnDisModel\\2009\\StreamPEDynamic.csv")
a <- read.csv("C:\\JVA\\Lamprey\\Adults\\SpawnDisModel\\2009\\StreamPEDynamic.csv", as.is=T)
b <- fread("C:\\JVA\\Lamprey\\Adults\\SpawnDisModel\\2009\\StreamPEDynamic.csv")
a <- read.csv("C:\\JVA\\Lamprey\\Adults\\SpawnDisModel\\2009\\StreamPEDynamic.csv", as.is=T)
b <- fread("C:\\JVA\\Lamprey\\Adults\\SpawnDisModel\\2009\\StreamPEDynamic.csv")
a <- read.csv("C:\\JVA\\Lamprey\\Adults\\SpawnDisModel\\2009\\StreamPEDynamic.csv", as.is=T)
b <- fread("C:\\JVA\\Lamprey\\Adults\\SpawnDisModel\\2009\\StreamPEDynamic.csv")
dim(a)
dim(b)
head(a)
head(b)
all.equal(a, b)
cleanup()
q()
search()
.First()
.First <- function() {
# this function is in the Rprofile.site text file
options(chmhelp=FALSE, scipen=4, stringsAsFactors=F)
.SavedPlots <- NULL
# attach packages
library(rJava)
library(XLConnect)
library(maps)
library(mapproj)
library(RColorBrewer)
library(abind)
library(boot)
library(mgcv)
library(MASS) 
library(jvamisc)
# my personal functions
already <- ls(".GlobalEnv")
if(FALSE) {
fdir <- "c:\\JVA\\R\\My R functions"
fvec <- list.files(fdir)
lapply(paste(fdir, fvec, sep="\\"), source)
now <- ls(".GlobalEnv")
save(list=now[!is.element(now, already)], file="c:\\JVA\\R\\.RData")
load(file="c:\\JVA\\R\\.RData", envir=attach(NULL, name="JVA.fcns"))
rm(list=ls("JVA.fcns"), envir=.GlobalEnv)
#vectorz()
}
print(already)
}
.First()
q()
search()
q()
# C:\JVA\Consult\Stapanian\Amphib\Next Subm 2\Three Group Approach 2.r
# which environmental variables best predict this index of amphibian biotic integrity
# relevant emails:
# 15 May 2013 - https://mail.google.com/mail/u/0/?shva=1#search/amphibian/13ea801401e50a84
#  8 Aug 2013 - https://mail.google.com/mail/u/1/?shva=1#inbox/1405defbc5969b40
# 27 Aug 2013 - https://mail.google.com/mail/u/1/?shva=1#inbox/140c042c5ba851fc
# bring in data and create initial figures
source("C:/JVA/Consult/Stapanian/Amphib/Next Subm 2/Explore Figs 2.r")
select.varz <- function(varnames, mydat, max.no.ind.var) {
# keep only those varnames that have at least two unique non-missing values
varnames <- varnames[apply(mydat[, varnames], 2, function(x) {
y <- var(x[!is.na(x)])
!is.na(y) & y>0
})]
m <- allcombs(length(varnames), 0, max.no.ind.var)
dimnames(m)[[2]] <- varnames
# right side of the formula
rightside <- apply(m, 1, function(row) paste(varnames[row==1], collapse=" + "))
# if no predictors, use 1 to represent intercept only model
rightside[rightside==""] <- "1"
form <- paste("amphibi ~", rightside)
fits <- lapply(form, function(f) lm(formula(f), dat=mydat))
# AIC table
aictab <- AICc(fits)
bigtab <- cbind(formula=rightside[aictab$model], aictab)
nmodzfit <- dim(bigtab)[1]
# top models
topmods <- bigtab[bigtab$daicc < 2, ]
# add coefficients to top model
coef <- lapply(fits[topmods$model], coef)
xmod <- unique(unlist(lapply(coef, names)))
topcoef <- t(sapply(coef, function(x) 
{
blank <- rep(0, length(xmod))
blank[match(names(x), xmod)] <- x
blank
}))
dimnames(topcoef)[[2]] <- xmod
topmods <- cbind(signif(topcoef, 3), round(topmods[, c("n", "p", "rmse", "aicc", "daicc", "aiccw")], 2))
# single best model
bestnum <- bigtab$model[1]
bestfit <- fits[[bestnum]]
xvarz <- varnames[m[bestnum, ]==1]
# output
out <- list(xvarz=xvarz, nmodzfit=nmodzfit, bestfit=bestfit, topmods=topmods, allfits=fits, allmods=bigtab, allpreds=m)
print(out[1:4])
out
}
assess.fit <- function(fit, newd) {
p <- predict(fit, newdata=newd)
y <- newd$amphibi
r <- p - y
rmse <- sqrt(mean(r^2))
r2 <- calcr2(fitted=p, observed=y, nparam=length(labels(terms(freshfita)))+1)
list(cbind(p=p, y=y, r=r), rmse=rmse, r2=r2)
}
# assign each observation to one of three groups
# ensure even distribution of groups across vegetation classes and latitudes
dat3 <- dat2[order(dat2$veg.class, dat2$lat.dd), ]
dat3$group <- rep(1:3, length.out=dim(dat2)[1])
df <- dat3
### map
attach(df)
suv <- sort(unique(veg.class))
windows(h=6.5, w=6.5)
map("state", mar=c(1, 1, 1, 1), region= "ohio", col="darkgray", lwd=2)
for(i in seq(suv)) {
sel <- veg.class==suv[i]
points(lon.dd[sel], lat.dd[sel], cex=2, lwd=2, pch=c(2, 1)[i], col=group[sel]+1)
}
#legend("bottomright", capwords(suv), pch=c(2, 1), col=c("black", "gray"), pt.lwd=2, pt.cex=2, cex=1.15, title="Veg. Class")
par(usr=c(-126, 94, 21, 193), xpd=NA)
polygon(c(-128, -128, -64, -64, -128), c(22, 52, 52, 22, 22), col="white", lwd=2)
map("state", add=T, mar=c(0, 0, 0, 0)) 
map("state", region="ohio", fill=T, add=T) 
detach(df)
# step 1, select variables
# limit the number of variables in each model, such that no more than n/10 coefficients are estimated, following Burnham and Anderson (2002)
maxxvar <- round(dim(df)[1]/3/10)
ga <- select.varz(varnames=varz1, mydat=df[df$group==1, ], max.no.ind.var=maxxvar)
gb <- select.varz(varnames=varz1, mydat=df[df$group==2, ], max.no.ind.var=maxxvar)
gc <- select.varz(varnames=varz1, mydat=df[df$group==3, ], max.no.ind.var=maxxvar)
round(ct[rev(order(ct[, "r"])), ], 4)
0.05/length(varz1)
#varnames=varz1; mydat=df[df$group==3, ]; max.no.ind.var=maxxvar;
cleanup()
q()
q <- function() quit(
quit
q <- function() quit(save=TRUE)
?quit
q()
q <- function() quit(save="yes")
q()
q
?quit
q()
library(devtools)
setwd("C:/JVA/GitHub/jvamisc")
document()
q()
