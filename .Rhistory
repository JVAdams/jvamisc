# color-blind friendly colors
# 1 black, 2 orange, 3 sky blue, 4 bluish green, 5 yellow, 6 blue, 7 vermillion, 8 reddish purple, 9 white
col.spa <- 6
col.day <- 2
col.tar <- 1
col.tfm <- 5
col.bayer <- 8
col.trt <- 3
col.wou <- 4
LAKENAMES <- c("Superior", "Michigan", "Huron", "Erie", "Ontario")
# aspect ratios for lake maps, height/width
ASPEX <- c(5/7, 7/5, 8/7, 4/7, 4/7)
TODAY <- format(Sys.time(), "%d-%b-%Y")
blindcolz <- rgb(c(0, 230, 86, 0, 240, 0, 213, 204, 255), c(0, 159, 180, 158, 228, 114, 94, 121, 255), 
c(0, 0, 233, 115, 66, 178, 0, 167, 255), maxColorValue=255)
addlinepoly <- function(x, ymn, ylo, yhi, subsel, kol, opq=c(20, 50)) {
# add a line with polygon for the upper and lower bounds
# x = x variable (year)
# ymn = y variable (metric) mean for line
# ylo, yhi = y variable bounds for polygon
# subsel = subset of data to use (e.g., lake==_)
# kol = color for the metric
# opq = opacity for the polygon (1) and the line (2)
subsel2 <- subsel & !is.na(ymn)
a <- spline(x[subsel2], ylo[subsel2], n=100)
b <- spline(x[subsel2], yhi[subsel2], n=100)
polygon(c(a$x, rev(b$x)), c(a$y, rev(b$y)), col=paste0(kol, opq[1]), border=NA)
lines(spline(x[subsel2], ymn[subsel2], n=100), col=paste0(kol, opq[2]), lwd=2)
}
GLMAPDATA <- function(file=paste0(FOLDER, GLSHORE), stclair=F) {
# creates two files with shoreline lat, longs
# map5 with all five Great Lakes
# mapL a list for each lake separately
map5 <- read.table(file)
names(map5) <- c("x", "y")
map5 <<- map5
mapS <- map5[map5$x < -84.312 & map5$y > 46.381, ]
mapM <- map5[map5$x < -84.739 & map5$y < 46.104, ]
mapH <- map5[map5$x > -84.777 & map5$x < -79.636 & map5$y > 42.965 & map5$y < 46.573 &
!(map5$x > -80.7 & map5$y < 43.9) & !(map5$x < -83.665 & map5$y < 43.570), ]
if(stclair==F) {
mapE <- map5[map5$x > -83.521 & map5$x < -78.827 & map5$y < 42.998 &
!(map5$x < -82.336 & map5$y > 42.263), ]
} else {
mapE <- map5[map5$x > -83.521 & map5$x < -78.827 & map5$y < 42.998, ]
}
mapO <- map5[map5$x > -79.823 & map5$x < -76.042 & map5$y > 43.111 & map5$y < 44.520 &
!(map5$x < -77.561 & map5$y > 44.086), ]
mapL <<- list(mapS, mapM, mapH, mapE, mapO)
invisible()
}
suln <- c(LAKENAMES, "All")
# map data
GLMAPDATA()
ls()
lss
lls
ll
lls <- function(pos=1, pat="") {
# modification of original function
# http://tolstoy.newcastle.edu.au/R/e2/help/07/01/8286.html
# Bendix Carstensen - 10 Jan 2007
# see also R.oo ll() function
dimx <- function(dd) if(is.null(dim(dd))) length(dd) else dim(dd)
lll <- ls(pos=pos, pat=pat)
if(length(lll) > 0) {
x <- data.frame(array(dim=c(length(lll), 3), dimnames=list(lll, c("class", "ndim", "size"))))
y <- rep(NA, length(lll))
for(i in 1:length(lll)) {
x$class[i] <- paste(eval(parse(t=paste("class(", lll[i], ")"))), collapse=" ")
x$ndim[i] <- length(eval(parse(t=paste("dimx(", lll[i], ")"))))
x$size[i] <- paste(eval(parse(t=paste("dimx(", lll[i], ")"))), collapse=" x ")
y[i] <- prod(eval(parse(t=paste("dimx(", lll[i], ")"))))
}
}
x$ndim[x$class=="function"] <- 0 
x[order(-x$ndim, -y, x$class), ]
}
lls()
a <- lls()
class(a)
head(a)
?save
save(mapL)
save(mapL, file=C:/JVA/GitHub/jvamisc/data/mapL.RData")
save(mapL, file="C:/JVA/GitHub/jvamisc/data/mapL.RData")
save(map5, file="C:/JVA/GitHub/jvamisc/data/map5.RData")
search()
blindcolz <- rgb(c(0, 230, 86, 0, 240, 0, 213, 204, 255), 
c(0, 159, 180, 158, 228, 114, 94, 121, 255), c(0, 0, 233, 115, 66, 178, 0, 167, 255), 
maxColorValue=255)
blindcolz
names(blindcolz) <- paste(1:9, c("black", "orange", "sky blue", "bluish green", "yellow", "blue", "vermillion", "reddish purple"))
blindcolz
# color-blind friendly colors
blindcolz <- rgb(c(0, 230, 86, 0, 240, 0, 213, 204, 255), 
c(0, 159, 180, 158, 228, 114, 94, 121, 255), c(0, 0, 233, 115, 66, 178, 0, 167, 255), 
maxColorValue=255)
names(blindcolz) <- paste(1:9, c("black", "orange", "sky blue", "bluish green", "yellow", "blue", "vermillion", "reddish purple", "white"))
blindcolz
cleanup()
# lake names
Lakenames <- c("Superior", "Michigan", "Huron", "Erie", "Ontario")
Lakeabbs <- c("S", "M", "H", "E", "O")
# color-blind friendly colors
blindcolz <- rgb(c(0, 230, 86, 0, 240, 0, 213, 204, 255), 
c(0, 159, 180, 158, 228, 114, 94, 121, 255), c(0, 0, 233, 115, 66, 178, 0, 167, 255), 
maxColorValue=255)
names(blindcolz) <- paste(1:9, c("black", "orange", "sky blue", "bluish green", "yellow", "blue", "vermillion", "reddish purple", "white"))
save(file="C:/JVA/GitHub/jvamisc/data/misc.RData")
cleanup
cleanup()
# lake names
Lakenames <- c("Superior", "Michigan", "Huron", "Erie", "Ontario")
Lakeabbs <- c("S", "M", "H", "E", "O")
# color-blind friendly colors
blindcolz <- rgb(c(0, 230, 86, 0, 240, 0, 213, 204, 255), 
c(0, 159, 180, 158, 228, 114, 94, 121, 255), c(0, 0, 233, 115, 66, 178, 0, 167, 255), 
maxColorValue=255)
names(blindcolz) <- paste(1:9, c("black", "orange", "sky blue", "bluish green", "yellow", "blue", "vermillion", "reddish purple", "white"))
save(file="C:/JVA/GitHub/jvamisc/data/misc.RData")
cleanup()
# lake names
Lakenames <- c("Superior", "Michigan", "Huron", "Erie", "Ontario")
Lakeabbs <- c("S", "M", "H", "E", "O")
# color-blind friendly colors
blindcolz <- rgb(c(0, 230, 86, 0, 240, 0, 213, 204, 255), 
c(0, 159, 180, 158, 228, 114, 94, 121, 255), c(0, 0, 233, 115, 66, 178, 0, 167, 255), 
maxColorValue=255)
names(blindcolz) <- paste(1:9, c("black", "orange", "sky blue", "bluish green", "yellow", "blue", "vermillion", "reddish purple", "white"))
save.image(file="C:/JVA/GitHub/jvamisc/data/misc.RData")
?letters
blindcolz
class(blindcolz)
Constants
?symbols
?symbols
## Note that  example(trees)  shows more sensible plots!
N <- nrow(trees)
with(trees, {
## Girth is diameter in inches
symbols(Height, Volume, circles = Girth/24, inches = FALSE,
        main = "Trees' Girth") # xlab and ylab automatically
## Colours too:
op <- palette(rainbow(N, end = 0.9))
symbols(Height, Volume, circles = Girth/16, inches = FALSE, bg = 1:N,
        fg = "gray30", main = "symbols(*, circles = Girth/16, bg = 1:N)")
palette(op)
})
with(trees, {
## Girth is diameter in inches
symbols(Height, Volume, circles = Girth/24, inches = FALSE,
        main = "Trees' Girth") # xlab and ylab automatically
}
}
with(trees, {
## Girth is diameter in inches
symbols(Height, Volume, circles = Girth/24, inches = FALSE,
        main = "Trees' Girth") # xlab and ylab automatically
})
my.circles <- function(x, y, z, data.range=range(z, na.rm=TRUE), circle.size.range=c(0.1, 1), outx=NA, outy=NA, ...) {
# control the plotting of circles
# fix the data range to be plotted (data.range)
# and fix the corresponding range of circle sizes (circle.size.range)
# rescale data range so it matches circle size range
newz <- ((z - data.range[1])/diff(data.range)) * diff(circle.size.range) + circle.size.range[1]
# add two data points that plot the min and max circle sizes outside the plot area
if(is.na(outx)) outx <- max(x) + 10 * diff(range(x))
if(is.na(outy)) outy <- max(y) + 10 * diff(range(y))
addx <- c(x, outx, outx)
addy <- c(y, outy, outy)
addz <- c(newz, circle.size.range)
# plot the circles
symbols(addx, addy, circles = addz, inches = circle.size.range[2], ...)
}
mycircles <- function(x, y, z, data.range=range(z, na.rm=TRUE), circle.size.range=c(0.1, 1), outx=NA, outy=NA, ...) {
# control the plotting of circles
# fix the data range to be plotted (data.range)
# and fix the corresponding range of circle sizes (circle.size.range)
# rescale data range so it matches circle size range
newz <- ((z - data.range[1])/diff(data.range)) * diff(circle.size.range) + circle.size.range[1]
# add two data points that plot the min and max circle sizes outside the plot area
if(is.na(outx)) outx <- max(x) + 10 * diff(range(x))
if(is.na(outy)) outy <- max(y) + 10 * diff(range(y))
addx <- c(x, outx, outx)
addy <- c(y, outy, outy)
addz <- c(newz, circle.size.range)
# plot the circles
symbols(addx, addy, circles = addz, inches = circle.size.range[2], ...)
}
?trees
mycircles(trees$Height, trees$Volume, trees$Girth, data.range=c(0, max(, trees$Girth)), circle.size.range=c(0, 1), main = "Trees' Girth"))
mycircles(trees$Height, trees$Volume, trees$Girth, data.range=c(0, max(, trees$Girth)), circle.size.range=c(0, 1), main="Trees' Girth")
mycircles(trees$Height, trees$Volume, trees$Girth, data.range=c(0, max(trees$Girth)), circle.size.range=c(0, 1), main="Trees' Girth")
mycircles(trees$Height, trees$Volume, trees$Girth, data.range=c(0, max(trees$Girth)), circle.size.range=c(0, 0.3), xlab="Height", ylab="Volumne", main="Trees' Girth")
## Girth is diameter in inches
plot(trees$Height, trees$Volume, xlab="Height", ylab="Volumne", main="Trees' Girth")
mycircles(trees$Height, trees$Volume, trees$Girth, data.range=c(0, max(trees$Girth)), circle.size.range=c(0, 0.3))
mycircles <- function(x, y, z, data.range=range(z, na.rm=TRUE), circle.size.range=c(0.1, 1), outx=NA, outy=NA, ...) {
# control the plotting of circles
# fix the data range to be plotted (data.range)
# and fix the corresponding range of circle sizes (circle.size.range)
# rescale data range so it matches circle size range
newz <- ((z - data.range[1])/diff(data.range)) * diff(circle.size.range) + circle.size.range[1]
# add two data points that plot the min and max circle sizes outside the plot area
if(is.na(outx)) outx <- max(x) + 10 * diff(range(x))
if(is.na(outy)) outy <- max(y) + 10 * diff(range(y))
addx <- c(x, outx, outx)
addy <- c(y, outy, outy)
addz <- c(newz, circle.size.range)
# plot the circles
symbols(addx, addy, circles = addz, inches = circle.size.range[2], add=TRUE, ...)
}
## Girth is diameter in inches
plot(trees$Height, trees$Volume, xlab="Height", ylab="Volumne", main="Trees' Girth")
mycircles(trees$Height, trees$Volume, trees$Girth, data.range=c(0, max(trees$Girth)), circle.size.range=c(0, 0.3))
## Girth is diameter in inches
plot(trees$Height, trees$Volume, type="n", xlab="Height", ylab="Volumne", main="Trees' Girth")
mycircles(trees$Height, trees$Volume, trees$Girth, data.range=c(0, max(trees$Girth)), circle.size.range=c(0, 0.3))
head(trees)
?trees
## Girth is diameter in inches
plot(trees$Height, trees$Girth, type="n", xlab="Height (ft)", ylab="Diameter (in)", main="Trees' Volume")
mycircles(trees$Height, trees$Girth, trees$Volume, data.range=sqrt(c(0, max(trees$Volume))), circle.size.range=c(0, 0.3))
symbols
extendrange
?extendrange
mycircles <- function(x, y, z, data.range=range(z, na.rm=TRUE), circle.size.range=c(0.1, 1), outx=NA, outy=NA, ...) {
# control the plotting of circles
# fix the data range to be plotted (data.range)
# and fix the corresponding range of circle sizes (circle.size.range)
# rescale data range so it matches circle size range
newz <- ((z - data.range[1])/diff(data.range)) * diff(circle.size.range) + circle.size.range[1]
# add two data points that plot the min and max circle sizes outside the plot area
if(is.na(outx)) outx <- max(x) + 10 * diff(range(x))
if(is.na(outy)) outy <- max(y) + 10 * diff(range(y))
addx <- c(x, outx, outx)
addy <- c(y, outy, outy)
addz <- c(newz, circle.size.range)
# plot the circles
if(!add | is.null(add)) {
if (is.null(xlim)) xlim <- extendrange(x, f=0.1)
if (is.null(ylim)) ylim <- extendrange(y, f=0.1)
symbols(addx, addy, xlim=xlim, ylim=ylim, circles=addz, inches=circle.size.range[2], ...)
} else {
symbols(addx, addy, circles=addz, inches=circle.size.range[2], add=TRUE, ...)
}
mycircles <- function(x, y, z, data.range=range(z, na.rm=TRUE), circle.size.range=c(0.1, 1), outx=NA, outy=NA, ...) {
# control the plotting of circles
# fix the data range to be plotted (data.range)
# and fix the corresponding range of circle sizes (circle.size.range)
# rescale data range so it matches circle size range
newz <- ((z - data.range[1])/diff(data.range)) * diff(circle.size.range) + circle.size.range[1]
# add two data points that plot the min and max circle sizes outside the plot area
if(is.na(outx)) outx <- max(x) + 10 * diff(range(x))
if(is.na(outy)) outy <- max(y) + 10 * diff(range(y))
addx <- c(x, outx, outx)
addy <- c(y, outy, outy)
addz <- c(newz, circle.size.range)
# plot the circles
if(!add | is.null(add)) {
if (is.null(xlim)) xlim <- extendrange(x, f=0.1)
if (is.null(ylim)) ylim <- extendrange(y, f=0.1)
symbols(addx, addy, xlim=xlim, ylim=ylim, circles=addz, inches=circle.size.range[2], ...)
} else {
symbols(addx, addy, circles=addz, inches=circle.size.range[2], add=TRUE, ...)
}
}
mycircles(trees$Height, trees$Girth, trees$Volume, data.range=sqrt(c(0, max(trees$Volume))), circle.size.range=c(0, 0.3), 
xlab="Height (ft)", ylab="Diameter (in)", main="Trees' Volume")
mycircles <- function(x, y, z, data.range=range(z, na.rm=TRUE), circle.size.range=c(0.1, 1), outx=NA, outy=NA, add=FALSE, ...) {
# control the plotting of circles
# fix the data range to be plotted (data.range)
# and fix the corresponding range of circle sizes (circle.size.range)
# rescale data range so it matches circle size range
newz <- ((z - data.range[1])/diff(data.range)) * diff(circle.size.range) + circle.size.range[1]
# add two data points that plot the min and max circle sizes outside the plot area
if(is.na(outx)) outx <- max(x) + 10 * diff(range(x))
if(is.na(outy)) outy <- max(y) + 10 * diff(range(y))
addx <- c(x, outx, outx)
addy <- c(y, outy, outy)
addz <- c(newz, circle.size.range)
# plot the circles
if(add) {
symbols(addx, addy, circles=addz, inches=circle.size.range[2], add=TRUE, ...)
} else {
if (is.null(xlim)) xlim <- extendrange(x, f=0.1)
if (is.null(ylim)) ylim <- extendrange(y, f=0.1)
symbols(addx, addy, xlim=xlim, ylim=ylim, circles=addz, inches=circle.size.range[2], add=FALSE, ...)
}
}
mycircles(trees$Height, trees$Girth, trees$Volume, data.range=sqrt(c(0, max(trees$Volume))), circle.size.range=c(0, 0.3), 
xlab="Height (ft)", ylab="Diameter (in)", main="Trees' Volume")
xlim
is.null(xlim)
?is.null
mycircles <- function(x, y, z, data.range=range(z, na.rm=TRUE), circle.size.range=c(0.1, 1), outx=NA, outy=NA, add=FALSE, xlim=NULL, ylim=NULL, ...) {
# control the plotting of circles
# fix the data range to be plotted (data.range)
# and fix the corresponding range of circle sizes (circle.size.range)
# rescale data range so it matches circle size range
newz <- ((z - data.range[1])/diff(data.range)) * diff(circle.size.range) + circle.size.range[1]
# add two data points that plot the min and max circle sizes outside the plot area
if(is.na(outx)) outx <- max(x) + 10 * diff(range(x))
if(is.na(outy)) outy <- max(y) + 10 * diff(range(y))
addx <- c(x, outx, outx)
addy <- c(y, outy, outy)
addz <- c(newz, circle.size.range)
# plot the circles
if(add) {
symbols(addx, addy, circles=addz, inches=circle.size.range[2], add=TRUE, ...)
} else {
if (is.null(xlim)) xlim <- extendrange(x, f=0.1)
if (is.null(ylim)) ylim <- extendrange(y, f=0.1)
symbols(addx, addy, xlim=xlim, ylim=ylim, circles=addz, inches=circle.size.range[2], add=FALSE, ...)
}
}
mycircles(trees$Height, trees$Girth, trees$Volume, data.range=sqrt(c(0, max(trees$Volume))), circle.size.range=c(0, 0.3), 
xlab="Height (ft)", ylab="Diameter (in)", main="Trees' Volume")
mycircles <- function(x, y, z, data.range=range(z, na.rm=TRUE), circle.size.range=c(0.1, 1), outx=NA, outy=NA, add=FALSE, xlim=NULL, ylim=NULL, ...) {
# control the plotting of circles
# fix the data range to be plotted (data.range)
# and fix the corresponding range of circle sizes (circle.size.range)
# rescale data range so it matches circle size range
newz <- ((z - data.range[1])/diff(data.range)) * diff(circle.size.range) + circle.size.range[1]
# add two data points that plot the min and max circle sizes outside the plot area
if(is.na(outx)) outx <- max(x) + 10 * diff(range(x))
if(is.na(outy)) outy <- max(y) + 10 * diff(range(y))
addx <- c(x, outx, outx)
addy <- c(y, outy, outy)
addz <- c(newz, circle.size.range)
# plot the circles
if(add) {
symbols(addx, addy, circles=addz, inches=circle.size.range[2], add=TRUE, ...)
} else {
if (is.null(xlim)) xlim <- extendrange(x, f=0.1)
if (is.null(ylim)) ylim <- extendrange(y, f=0.1)
symbols(addx, addy, xlim=xlim, ylim=ylim, circles=addz, inches=circle.size.range[2], add=FALSE, ...)
}
}
mycircles(trees$Height, trees$Girth, trees$Volume, data.range=sqrt(c(0, max(trees$Volume))), circle.size.range=c(0, 0.3), xlab="Height (ft)", ylab="Diameter (in)", main="Trees' Volume")
library(XLConnect)
wb <- loadWorkbook("C:/JVA/GLFC/People/Kaye/Stonecats/Stonecat Length and Weight.xlsx")
dat <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=6)
info <- data.frame(
visit = c(1, 2, 3, 4, 5),
month = c(5, 5, 5, 8, 7),
day = c(2, 14, 26, 14, 13),
year = 2012 + c(0, 0, 0, 0, 1),
minutes = c(555, 0, 530, 390, 360)
)
info$date <- with(info, as.Date(paste(year, month, day, sep="-")))
length <- with(dat, c(Length, Length.1, Length.3, Length.4))
weight <- with(dat, c(Weight, Weight.1, Weight.3, Weight.4))
visit <- rep(info$visit[-3], rep(dim(dat)[1], length(info$visit[-3])))
cats <- data.frame(length, weight, visit)
cats <- cats[!is.na(cats$length), ]
rm(length, weight, visit)
catch <- table(cats$visit)
catch <- c(catch[1:2], 0, catch[3:4]) 
info$nperhr <- 60*catch/info$minutes
# mark recapture estimates for visit 1 and visit 4 (based on recaps during visit 2 and visit 5)
adjPetersen <- function(M, C, R) {
# Adjusted Petersen estimate for single mark-recapture, Chapman (1951)
N <- (M+1)*(C+1) / (R+1)
# CI for R
RCI <- binomCI(R, C-R, prob=FALSE)
NCI <- as.vector((M+1)*(C+1) / (RCI[c("U", "L")]+1))
c(N=N, L=NCI[1], U=NCI[2])
}
mr1 <- adjPetersen(M=39, C=348, R=0)
mr4 <- adjPetersen(M=42, C=30, R=1)
attach(info)
windows()
par(mar=c(4, 3.5, 2, 3.5), cex=1.5, yaxs="i")
plot(date[-2], nperhr[-2], type="n", ylim=1.05*c(0, max(nperhr[-2])), axes=FALSE,
xlab="Survey date  (2012-2013)", ylab="", main="Stonecats", las=1)
points(date[-2], nperhr[-2], type="o", lwd=2, col="blue")
axis(1, at=as.Date(c(paste(2012, 1:12, 1, sep="-"), paste(2013, 1:12, 1, sep="-")))-0.5, labels=F)
axis(1, at=as.Date(c(paste(2012, c(5, 8), 15, sep="-"), paste(2013, 7, 15, sep="-")))-0.5, labels=c(month.abb[c(5, 8)], month.abb[7]), tick=F, las=3)
axis(2, las=1, col.axis="blue")
mtext("CPUE  (#/hr of electrofishing)", side=2, line=2, cex=1.5, col="blue")
par(new=TRUE)
plot(date[c(1, 3, 4)], c(mr1[1], mr4[1], NA)/1000, type="n", ylim=1.05*c(0, max(mr1, mr4)/1000), xlab="", ylab="", axes=FALSE)
points(date[c(1, 3, 4)], c(mr1[1], mr4[1], NA)/1000, type="o", pch=2, lwd=2, col="red")
arrows(date[c(1, 3)], c(mr1[2], mr4[2])/1000, date[c(1, 3)], c(mr1[3], mr4[3])/1000, length=0.1, angle=90, code=3, col="red")
axis(4, las=1, col.axis="red")
mtext("Mark-recapture estimate  (thousands)", side=4, line=2, cex=1.5, col="red")
detach(info)
attach(cats)
windows(h=9, w=6.5)
par(mfrow=c(4, 1), yaxs="i", mar=c(0, 2, 0, 2), oma=c(3, 1, 2, 0), cex=1.5)
for(i in c(1, 2, 4, 5)) {
sel <- visit==i
ymax <- max(table(cut(length[sel], breaks=seq(0, 300, 5))))
hist(length[sel], breaks=seq(0, 300, 5), xlim=range(length), ylim=1.05*c(0, ymax), axes=FALSE, col="gray", xlab="", ylab="", main="")
if(i==1 | i==4) axis(2, las=1) else axis(4, las=1)
abline(v=seq(0, 300, 50), lty=3)
box()
mtext(info$date[i], side=3, line=-1, adj=0.97)
}
axis(1)
mtext("Length  (mm)", side=1, outer=TRUE, line=2, cex=1.5)
mtext("Frequency", side=2, outer=TRUE, cex=1.5)
mtext("Stonecats", side=3, outer=TRUE, line=0.5, cex=1.5, font=2)
windows(h=9, w=6.5)
par(mfrow=c(4, 1), yaxs="i", mar=c(0, 2, 0, 2), oma=c(3, 1, 2, 0), cex=1.5)
for(i in c(1, 2, 4, 5)) {
sel <- visit==i
ymax <- max(table(cut(weight[sel], breaks=seq(0, 300, 5))))
hist(weight[sel], breaks=seq(0, 300, 5), xlim=range(weight), ylim=1.05*c(0, ymax), axes=FALSE, col="gray", xlab="", ylab="", main="")
if(i==1 | i==4) axis(2, las=1) else axis(4, las=1)
abline(v=seq(0, 300, 50), lty=3)
box()
mtext(info$date[i], side=3, line=-1, adj=0.97)
}
axis(1)
mtext("Weight  (g)", side=1, outer=TRUE, line=2, cex=1.5)
mtext("Frequency", side=2, outer=TRUE, cex=1.5)
mtext("Stonecats", side=3, outer=TRUE, line=0.5, cex=1.5, font=2)
detach(cats)
############ useless gaming #############
if(FALSE) {
obs <- c(m1=39, r12=0, u2=348, r14=0, u4=42, r15=0, r25=1, u5=29)
# input starting values for 8 unknowns
# set p1 = p4 = p5
if(FALSE) {
meds <- c(n1=8000, p1=0.1, p2=0.1, mt=0.5, m45=0.2, e45=1000)
medsall <- meds
}
startdf <- expand.grid(
n1=round(seq(meds["n1"]/2, meds["n1"]*1.5, length=5)),
p1=seq(meds["p1"]/2, max(min(meds["p1"]*1.5, 1), 0.001), length=5),
p2=seq(meds["p2"]/2, max(min(meds["p2"]*1.5, 1), 0.001), length=5),
mt=seq(meds["mt"]/2, max(min(meds["mt"]*1.5, 1), 0.001), length=5),
m45=seq(meds["m45"]/2, max(min(meds["m45"]*1.5, 1), 0.001), length=5),
e45=round(seq(meds["e45"]/2, max(meds["e45"]*1.5, 100), length=5)))
# calculate predicted observations, given starting values
estm <- with(startdf, cbind(
m1 =  n1 *  p1,
r12 =  n1 *  p1  *  mt  *  p2,
u2 =  n1 *(1-p1)*  mt  *  p2,
r14 =  n1 *  p1  *(1-mt)       *  p1,
u4 =  n1 *(1-p1)*(1-mt)       *  p1,
r15 =  n1 *  p1  *(1-mt)       *(1-p1)*(1-m45)        * p1,
r25=  n1 *(1-p1)*(1-mt)       *  p1  *(1-m45)        * p1,
u5= (n1 *(1-p1)*(1-mt)       *(1-p1)*(1-m45) + e45) * p1
))
namz <- dimnames(estm)[[2]]
#windows()
par(mfrow=c(3, 3), mar=c(3, 3, 2, 1), oma=c(2, 2, 0, 0))
for(i in 1:dim(estm)[2]) {
hist(estm[, i], main=paste0(namz[i], " = ", obs[i]), las=1, nclass=25)
abline(v=obs[i], lwd=2, col="red")
}
mtext("Estimates", side=1, outer=TRUE)
mtext("Frequency", side=2, outer=TRUE)
# calculate residual = predicted - observed
resid <- t(estm) - obs
minerr <- apply(abs(resid), 1, which.min)
minerr
startdf[minerr, ]
meds <- apply(startdf[minerr, ], 2, median)
meds
medsall <- rbind(medsall, meds)
}
attach(info)
windows()
par(mar=c(4, 3.5, 2, 3.5), cex=1.5, yaxs="i")
plot(date[-2], nperhr[-2], type="n", ylim=1.05*c(0, max(nperhr[-2])), axes=FALSE,
xlab="Survey date  (2012-2013)", ylab="", main="Stonecats", las=1)
points(date[-2], nperhr[-2], type="o", lwd=2, col="blue")
axis(1, at=as.Date(c(paste(2012, 1:12, 1, sep="-"), paste(2013, 1:12, 1, sep="-")))-0.5, labels=F)
axis(1, at=as.Date(c(paste(2012, c(5, 8), 15, sep="-"), paste(2013, 7, 15, sep="-")))-0.5, labels=c(month.abb[c(5, 8)], month.abb[7]), tick=F, las=3)
axis(2, las=1, col.axis="blue")
mtext("CPUE  (#/hr of electrofishing)", side=2, line=2, cex=1.5, col="blue")
par(mar=c(4, 3.5, 2, 3.5), cex=1.5, yaxs="i")
plot(date[-2], nperhr[-2], type="n", ylim=1.05*c(0, max(nperhr[-2])), axes=FALSE,
xlab="Survey date  (2012-2013)", ylab="", main="Stonecats", las=1)
points(date[-2], nperhr[-2], type="o", lwd=2)
axis(1, at=as.Date(c(paste(2012, 1:12, 1, sep="-"), paste(2013, 1:12, 1, sep="-")))-0.5, labels=F)
axis(1, at=as.Date(c(paste(2012, c(5, 8), 15, sep="-"), paste(2013, 7, 15, sep="-")))-0.5, labels=c(month.abb[c(5, 8)], month.abb[7]), tick=F, las=3)
axis(2, las=1)
box()
mtext("CPUE  (#/hr of electrofishing)", side=2, line=2, cex=1.5)
par(mar=c(4, 3.5, 2, 1), cex=1.5, yaxs="i")
plot(date[-2], nperhr[-2], type="n", ylim=1.05*c(0, max(nperhr[-2])), axes=FALSE,
xlab="Survey date  (2012-2013)", ylab="", main="Stonecats", las=1)
points(date[-2], nperhr[-2], type="o", lwd=2)
axis(1, at=as.Date(c(paste(2012, 1:12, 1, sep="-"), paste(2013, 1:12, 1, sep="-")))-0.5, labels=F)
axis(1, at=as.Date(c(paste(2012, c(5, 8), 15, sep="-"), paste(2013, 7, 15, sep="-")))-0.5, labels=c(month.abb[c(5, 8)], month.abb[7]), tick=F, las=3)
axis(2, las=1)
box()
mtext("CPUE  (#/hr of electrofishing)", side=2, line=2, cex=1.5)
cleanup()
q()
# After restarting R, attach/install packages
library(devtools)
library(roxygen2)
# install from local folder
setwd("C:/JVA/GitHub")
install("jvamisc")
setwd("C:/JVA/R/Working Directory")
library(jvamisc)
?circles
#########
# Make any changes you like
# update documentation, then quit and restart R
library(devtools)
setwd("C:/JVA/GitHub/jvamisc")
document()
quit("yes")
