par(mar=c(4, 4, 1, 5), cex=1.5)
sy <- ontlook$year > 2003.5
plot(1, 1, type="n", log="y", las=1, xlim=range(ontlook$year[sy]), ylim=range(ontlook$Emr[sy], ontlook$Pmr[sy], na.rm=TRUE)/1000, xlab="Year", ylab="Adults")
for(i in 1:3) {
mycol <- blindcolz[c(3, 6, 5, 4, 2)[i]]
sel <- sy & ontlook$lscode==sus[i]
points(ontlook$year[sel], ontlook$Emr[sel]/1000, col=mycol, lwd=3, pch=16, type="o")
sel3 <- sel & ontlook$year>2008.5
mtext(ontlook$strname[sel3][1], side=4, at=median(ontlook$Emr[sel3]/1000, na.rm=TRUE), col=mycol, las=1, cex=1.5, line=0.2)
}
box()
# just Sterling & Black
windows(w=10, h=6)
par(mar=c(4, 4, 1, 5), cex=1.5)
sy <- ontlook$year > 2003.5
plot(1, 1, type="n", log="y", las=1, xlim=range(ontlook$year[sy]), ylim=range(ontlook$Emr[sy], ontlook$Pmr[sy], na.rm=TRUE)/1000, xlab="Year", ylab="Adults")
for(i in 4:5) {
mycol <- blindcolz[c(3, 6, 5, 4, 2)[i]]
sel <- sy & ontlook$lscode==sus[i]
points(ontlook$year[sel], ontlook$Emr[sel]/1000, col=mycol, lwd=3, pch=16, type="o")
sel3 <- sel & ontlook$year>2008.5
mtext(ontlook$strname[sel3][1], side=4, at=median(ontlook$Emr[sel3]/1000, na.rm=TRUE), col=mycol, las=1, cex=1.5, line=0.2)
}
box()
# just Sterling & Black ESTIMATED
windows(w=10, h=6)
par(mar=c(4, 4, 1, 5), cex=1.5)
sy <- ontlook$year > 2003.5
plot(1, 1, type="n", log="y", las=1, xlim=range(ontlook$year[sy]), ylim=range(ontlook$Emr[sy], ontlook$Pmr[sy], na.rm=TRUE)/1000, xlab="Year", ylab="Adults")
for(i in 4:5) {
mycol <- blindcolz[c(3, 6, 5, 4, 2)[i]]
sel <- sy & ontlook$lscode==sus[i]
lines(ontlook$year[sel], ontlook$COMBmr[sel]/1000, col=mycol, lwd=3, lty=2, lend="square")
points(ontlook$year[sel & is.na(ontlook$Emr)], ontlook$Pmr[sel & is.na(ontlook$Emr)]/1000, col=mycol, pch=16, cex=1.5)
sel3 <- sel & ontlook$year>2008.5
mtext(ontlook$strname[sel3][1], side=4, at=median(ontlook$Emr[sel3]/1000, na.rm=TRUE), col=mycol, las=1, cex=1.5, line=0.2)
}
box()
### spawner model and adult index time series overlaid
windows(h=4.5, w=5)
par(mar=c(4, 4, 2, 3), cex=1.2, yaxs="i")
i <- 5
myindxdf <- indices[[i]]$indxdf# year lake indxraw n.mr indxkeep indxkeep.lo indxkeep.hi
convfac <- indices[[i]]$scaleup
x1 <- myindxdf$year
y1 <- myindxdf$indxkeep/1000
ylo <- myindxdf$indxkeep.lo/1000
yhi <- myindxdf$indxkeep.hi/1000
yr <- 1.05*range(0, y1, yhi[x1>=YEAR1], na.rm=TRUE)
plot(x1, y1, type="n", xlim=range(x1[!is.na(y1)]), ylim=1.05*range(0, yhi, na.rm=TRUE), xlab="Year", ylab="Adult abundance  (thousands)", main=Lakenames[i], axes=FALSE)
axis(1)
axis(2, col=blindcolz[7], col.axis=blindcolz[7], las=1)
arrows(x1, ylo, x1, yhi, length=0, angle=90, code=3, lwd=10, lend="square", col="#ffddc1")
abline(h=targets.ai.adj$target[i]/1000, col=blindcolz[7], lty=2)
lines(x1, y1, col=blindcolz[7], type="o", pch=17, lwd=2)
par(mgp=c(3, 2.2, 0))
axis(4, at=pretty(convfac*yr)/convfac, labels=pretty(convfac*yr), col=blindcolz[3], col.axis=blindcolz[3], las=1, hadj=1)
box()
rm(ontlook, sus, sy, ss, mycol, sel, sel3, i, myindxdf, convfac, x1, y1, ylo, yhi, yr)
}
# summary table for trapped streams in spawner model, based on last X years of data
X <- 20
selmr <- dat$year > (as.numeric(lastyear)-X+0.5) & dat$est.source=="m-r"
tssm <- sort(unique(dat$lscode[selmr]))
sel <- dat$year > (as.numeric(lastyear)-X+0.5) & dat$lscode %in% tssm
mPE <- tapply(dat$Emr[sel], dat$lscode[sel], median, na.rm=TRUE)
mtc <- tapply(dat$trapcatch[sel], dat$lscode[sel], median, na.rm=TRUE)
mef <- tapply((dat$trapcatch/dat$Emr)[sel], dat$lscode[sel], median, na.rm=TRUE)
nyr <- tapply(!is.na(dat$Emr)[sel], dat$lscode[sel], sum)
wpyr <- tapply((dat$year-(as.numeric(lastyear)-X))[sel & !is.na(dat$Emr)], dat$lscode[sel & !is.na(dat$Emr)], sum)/((X+1)*(X/2))
mdf <- data.frame(mPE, mtc, mef, nyr, wpyr)
mdf <- cbind(dat[match(rownames(mdf), dat$lscode), c("lake", "country", "lscode", "strname", "estr")], mdf)
mdf$type <- c("", "Index")[mdf$lscode %in% unlist(index.streams) + 1]
rankl <- rank(rank(-mdf$wpyr) + rank(-mdf$mPE))
mdf$rank <- unlist(tapply(rankl, mdf$lake, rank))
ord <- order(mdf$lake, -(rank(mdf$mPE) + rank(mdf$nyr)))
ord <- order(mdf$lake, -mdf$mPE, -mdf$wpyr)
ord <- order(mdf$lake, mdf$rank)
mdf[ord, c("lake", "country", "lscode", "strname", "type", "rank", "nyr", "wpyr", "mPE", "mtc", "mef")]
rm(selmr, sel, mPE, mtc, mef, nyr, wpyr, rankl, ord)
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/1984-2014 US MarkRecap Summary.xlsx")
usmr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=2)
names(usmr) <- casefold(names(usmr))
names(usmr)[match(c("lk", "strm", "trib.name", "x.marked", "x.recap"), names(usmr))] <- c("lake", "estr", "trib", "marks", "recaps")
usmr$country <- "US"
usmr2 <- usmr[usmr$year > (as.numeric(lastyear)-X+0.5), c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
# assume missing values are zeroes
#############################################################################################
# Okay.  So if the catch is NA, I'll assume it wasn't trapped.  
# But if the catch is some number (even if it's 0) and the marks and the recaps are NA, 
# I'll assume that there were 0 marks and or 0 recaps.
#############################################################################################
head(usmr2)
table(is.na(usmr2$catch), is.na(usmr2$marks), is.na(usmr2$recaps))
summary(usmr2[is.na(usmr2$catch), ])
with(usmr2, table(is.na(catch), is.na(marks) | marks<1, is.na(recaps) | recaps < 1)
)
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/1984-2014 US MarkRecap Summary.xlsx")
usmr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=2)
names(usmr) <- casefold(names(usmr))
names(usmr)[match(c("lk", "strm", "trib.name", "x.marked", "x.recap"), names(usmr))] <- c("lake", "estr", "trib", "marks", "recaps")
usmr$country <- "US"
usmr2 <- usmr[usmr$year > (as.numeric(lastyear)-X+0.5), c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
# if the catch is NA, I assume it wasn't trapped
usmr2 <- usmr2[!is.na(usmr2$catch), ]
# if marks or recaps are NA, I assume they were zero
usmr2$marks[is.na(usmr2$marks)] <- 0
usmr2$recaps[is.na(usmr2$recaps)] <- 0
summary(usmr2)
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/marked and recaptured DFO.xlsx")
camr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1)
names(camr) <- casefold(names(camr))
names(camr)[match(c("stream_code", "stream_name", "marked", "recaptured"), names(camr))] <- c("estr", "trib", "marks", "recaps")
camr$country <- "Canada"
camr$lake <- match(camr$lake_code, Lakeabbs)
camr$catch <- NA
camr2 <- camr[camr$year > (as.numeric(lastyear)-X+0.5), c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
summary(camr2)
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/marked and recaptured DFO.xlsx")
camr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1)
names(camr) <- casefold(names(camr))
names(camr)[match(c("stream_code", "stream_name", "marked", "recaptured"), names(camr))] <- c("estr", "trib", "marks", "recaps")
camr$country <- "Canada"
camr$lake <- match(camr$lake_code, Lakeabbs)
camr$catch <- NA
camr2 <- camr[camr$year > (as.numeric(lastyear)-X+0.5), c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
summary(camr2)
camr2[is.na(camr2$recaps), ]
head(camr)
head(camr)
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/1984-2014 US MarkRecap Summary.xlsx")
usmr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=2)
names(usmr) <- casefold(names(usmr))
names(usmr)[match(c("lk", "strm", "trib.name", "x.marked", "x.recap"), names(usmr))] <- c("lake", "estr", "trib", "marks", "recaps")
usmr$country <- "US"
usmr2 <- usmr[usmr$year > (as.numeric(lastyear)-X+0.5), c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
usmr2$branch <- ""
# if the catch is NA, I assume it wasn't trapped
usmr2 <- usmr2[!is.na(usmr2$catch), ]
# if marks or recaps are NA, I assume they were zero
usmr2$marks[is.na(usmr2$marks)] <- 0
usmr2$recaps[is.na(usmr2$recaps)] <- 0
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/marked and recaptured DFO.xlsx")
camr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1)
names(camr) <- casefold(names(camr))
names(camr)[match(c("stream_code", "stream_name", "marked", "recaptured". "branch_lentic_name"), names(camr))] <- c("estr", "trib", "marks", "recaps", "branch")
camr$country <- "Canada"
camr$lake <- match(camr$lake_code, Lakeabbs)
camr$catch <- NA
camr2 <- camr[camr$year > (as.numeric(lastyear)-X+0.5), c("lake", "country", "estr", "trib", "branch", "year", "catch", "marks", "recaps")]
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/1984-2014 US MarkRecap Summary.xlsx")
usmr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=2)
names(usmr) <- casefold(names(usmr))
names(usmr)[match(c("lk", "strm", "trib.name", "x.marked", "x.recap"), names(usmr))] <- c("lake", "estr", "trib", "marks", "recaps")
usmr$country <- "US"
usmr2 <- usmr[usmr$year > (as.numeric(lastyear)-X+0.5), c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
usmr2$branch <- ""
# if the catch is NA, I assume it wasn't trapped
usmr2 <- usmr2[!is.na(usmr2$catch), ]
# if marks or recaps are NA, I assume they were zero
usmr2$marks[is.na(usmr2$marks)] <- 0
usmr2$recaps[is.na(usmr2$recaps)] <- 0
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/marked and recaptured DFO.xlsx")
camr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1)
names(camr) <- casefold(names(camr))
names(camr)[match(c("stream_code", "stream_name", "marked", "recaptured", "branch_lentic_name"), names(camr))] <- c("estr", "trib", "marks", "recaps", "branch")
camr$country <- "Canada"
camr$lake <- match(camr$lake_code, Lakeabbs)
camr$catch <- NA
camr2 <- camr[camr$year > (as.numeric(lastyear)-X+0.5), c("lake", "country", "estr", "trib", "branch", "year", "catch", "marks", "recaps")]
head(camr2)
summary(camr2)
camr2[is.na(camr2$recaps), ]
camr2[is.na(camr2$recaps), -7]
camr2[camr2$estr==571, ]
camr2[camr2$estr==571, -7]
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/1984-2014 US MarkRecap Summary.xlsx")
usmr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=2)
names(usmr) <- casefold(names(usmr))
names(usmr)[match(c("lk", "strm", "trib.name", "x.marked", "x.recap"), names(usmr))] <- c("lake", "estr", "trib", "marks", "recaps")
usmr$country <- "US"
usmr2 <- usmr[usmr$year > (as.numeric(lastyear)-X+0.5), c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
usmr2$branch <- ""
# if the catch is NA, I assume it wasn't trapped
usmr2 <- usmr2[!is.na(usmr2$catch), ]
# if marks or recaps are NA, I assume they were zero
usmr2$marks[is.na(usmr2$marks)] <- 0
usmr2$recaps[is.na(usmr2$recaps)] <- 0
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/marked and recaptured DFO.xlsx")
camr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1)
names(camr) <- casefold(names(camr))
names(camr)[match(c("stream_code", "stream_name", "marked", "recaptured", "branch_lentic_name"), names(camr))] <- c("estr", "trib", "marks", "recaps", "branch")
camr$country <- "Canada"
camr$lake <- match(camr$lake_code, Lakeabbs)
camr$catch <- NA
camr2 <- camr[camr$year > (as.numeric(lastyear)-X+0.5), c("lake", "country", "estr", "trib", "branch", "year", "catch", "marks", "recaps")]
both <- rbind(usmr2, camr2)
# create list of streams for matching with spawner model data
both$catlast <- ifelse(both$year==lastyear, both$catch, 0)
look <- aggregate(both[, c("catlast", "marks", "recaps")], both[, c("trib", "country", "estr", "lake")], median, na.rm=TRUE)
look <- look[, c("lake", "country", "estr", "trib", "catlast", "marks", "recaps")]
write.csv(look, "C:/JVA/Lamprey/Adults/AdultIndex/2014/mr-streams.csv", row.names=FALSE)
selmr <- dat$year > (as.numeric(lastyear)-X+0.5) & !is.na(dat$trapcatch)
tssm2 <- sort(unique(dat$lscode[selmr]))
look2 <- dat[dat$year==lastyear & dat$lscode %in% tssm2, c("lake", "country", "estr", "strname", "trapcatch", "lscode", "strcode", "reach")]
write.csv(look2[order(look2$lake, look2$estr, look2$country, look2$strname), ], "C:/JVA/Lamprey/Adults/AdultIndex/2014/sm-streams.csv", row.names=FALSE)
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/1984-2014 US MarkRecap Summary.xlsx")
usmr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=2)
names(usmr) <- casefold(names(usmr))
names(usmr)[match(c("lk", "strm", "trib.name", "x.marked", "x.recap"), names(usmr))] <- c("lake", "estr", "trib", "marks", "recaps")
usmr$country <- "US"
usmr2 <- usmr[usmr$year > (as.numeric(lastyear)-X+0.5), c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
usmr2$branch <- ""
# if the catch is NA, I assume it wasn't trapped
usmr2 <- usmr2[!is.na(usmr2$catch), ]
# if marks or recaps are NA, I assume they were zero
usmr2$marks[is.na(usmr2$marks)] <- 0
usmr2$recaps[is.na(usmr2$recaps)] <- 0
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/marked and recaptured DFO.xlsx")
camr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1)
names(camr) <- casefold(names(camr))
names(camr)[match(c("stream_code", "stream_name", "marked", "recaptured", "branch_lentic_name"), names(camr))] <- c("estr", "trib", "marks", "recaps", "branch")
camr$country <- "Canada"
camr$lake <- match(camr$lake_code, Lakeabbs)
camr$catch <- NA
camr2 <- camr[camr$year > (as.numeric(lastyear)-X+0.5), c("lake", "country", "estr", "trib", "branch", "year", "catch", "marks", "recaps")]
both <- rbind(usmr2, camr2)
# create list of streams for matching with spawner model data
both$catlast <- ifelse(both$year==lastyear, both$catch, 0)
look <- aggregate(both[, c("catlast", "marks", "recaps")], both[, c("branch", "trib", "country", "estr", "lake")], median, na.rm=TRUE)
look <- look[, c("lake", "country", "estr", "trib", "branch", "catlast", "marks", "recaps")]
write.csv(look, "C:/JVA/Lamprey/Adults/AdultIndex/2014/mr-streams.csv", row.names=FALSE)
selmr <- dat$year > (as.numeric(lastyear)-X+0.5) & !is.na(dat$trapcatch)
tssm2 <- sort(unique(dat$lscode[selmr]))
look2 <- dat[dat$year==lastyear & dat$lscode %in% tssm2, c("lake", "country", "estr", "strname", "trapcatch", "lscode", "strcode", "reach")]
write.csv(look2[order(look2$lake, look2$estr, look2$country, look2$strname), ], "C:/JVA/Lamprey/Adults/AdultIndex/2014/sm-streams.csv", row.names=FALSE)
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/1984-2014 US MarkRecap Summary.xlsx")
usmr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=2)
names(usmr) <- casefold(names(usmr))
names(usmr)[match(c("lk", "strm", "trib.name", "x.marked", "x.recap"), names(usmr))] <- c("lake", "estr", "trib", "marks", "recaps")
usmr$country <- "US"
usmr2 <- usmr[usmr$year > (as.numeric(lastyear)-X+0.5), c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
# if the catch is NA, I assume it wasn't trapped
usmr2 <- usmr2[!is.na(usmr2$catch), ]
# if marks or recaps are NA, I assume they were zero
usmr2$marks[is.na(usmr2$marks)] <- 0
usmr2$recaps[is.na(usmr2$recaps)] <- 0
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/marked and recaptured DFO.xlsx")
camr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1)
names(camr) <- casefold(names(camr))
names(camr)[match(c("stream_code", "stream_name", "marked", "recaptured", "branch_lentic_name"), names(camr))] <- c("estr", "trib", "marks", "recaps", "branch")
camr$country <- "Canada"
camr$lake <- match(camr$lake_code, Lakeabbs)
camr$catch <- NA
camr2 <- camr[camr$year > (as.numeric(lastyear)-X+0.5), c("lake", "country", "estr", "trib", "branch", "year", "catch", "marks", "recaps")]
camr2$trib <- paste(camr2$trib, camr2$branch, sep=" - ")
both <- rbind(usmr2, camr2)
# create list of streams for matching with spawner model data
both$catlast <- ifelse(both$year==lastyear, both$catch, 0)
look <- aggregate(both[, c("catlast", "marks", "recaps")], both[, c("trib", "country", "estr", "lake")], median, na.rm=TRUE)
look <- look[, c("lake", "country", "estr", "trib", "catlast", "marks", "recaps")]
write.csv(look, "C:/JVA/Lamprey/Adults/AdultIndex/2014/mr-streams.csv", row.names=FALSE)
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/1984-2014 US MarkRecap Summary.xlsx")
usmr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=2)
names(usmr) <- casefold(names(usmr))
names(usmr)[match(c("lk", "strm", "trib.name", "x.marked", "x.recap"), names(usmr))] <- c("lake", "estr", "trib", "marks", "recaps")
usmr$country <- "US"
usmr2 <- usmr[usmr$year > (as.numeric(lastyear)-X+0.5), c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
# if the catch is NA, I assume it wasn't trapped
usmr2 <- usmr2[!is.na(usmr2$catch), ]
# if marks or recaps are NA, I assume they were zero
usmr2$marks[is.na(usmr2$marks)] <- 0
usmr2$recaps[is.na(usmr2$recaps)] <- 0
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/marked and recaptured DFO.xlsx")
camr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1)
names(camr) <- casefold(names(camr))
names(camr)[match(c("stream_code", "stream_name", "marked", "recaptured", "branch_lentic_name"), names(camr))] <- c("estr", "trib", "marks", "recaps", "branch")
camr$country <- "Canada"
camr$lake <- match(camr$lake_code, Lakeabbs)
camr$catch <- NA
camr2 <- camr[camr$year > (as.numeric(lastyear)-X+0.5), ]
camr2$trib <- paste(camr2$trib, camr2$branch, sep=" - ")
camr2 <- camr2[, c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
both <- rbind(usmr2, camr2)
# create list of streams for matching with spawner model data
both$catlast <- ifelse(both$year==lastyear, both$catch, 0)
look <- aggregate(both[, c("catlast", "marks", "recaps")], both[, c("trib", "country", "estr", "lake")], median, na.rm=TRUE)
look <- look[, c("lake", "country", "estr", "trib", "catlast", "marks", "recaps")]
write.csv(look, "C:/JVA/Lamprey/Adults/AdultIndex/2014/mr-streams.csv", row.names=FALSE)
# bring in STREAM KEY to connect mark/recap data to spawner model data
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/MatchStreams.xlsx")
key <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1, startCol=12)
head(key)
# bring in STREAM KEY to connect mark/recap data to spawner model data
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/MatchStreams.xlsx")
key <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1, startCol=12, endCol=16)
head(key)
# use this key to assign lscode (lake stream code) numbers to mark/recap data
markrecap <- merge(both, key, by="lscode", all=x)
head(both)
head(
# use this key to assign lscode (lake stream code) numbers to mark/recap data
markrecap <- merge(both, key, all=x)
# use this key to assign lscode (lake stream code) numbers to mark/recap data
markrecap <- merge(both, key, all=x)
# use this key to assign lscode (lake stream code) numbers to mark/recap data
markrecap <- merge(both, key, all=x)
# use this key to assign lscode (lake stream code) numbers to mark/recap data
markrecap <- merge(both, key, all.x=TRUE)
dim(both)
dim(markrecap)
head(markrecap)
dput(names(markrecap))
# use this key to assign lscode (lake stream code) numbers to mark/recap data
markrecap <- merge(both[, c("lake", "country", "estr", "trib", "year", "marks", "recaps")], key, all.x=TRUE)
head(markrecap)
# use this key to assign lscode (lake stream code) numbers to mark/recap data
both2 <- merge(both, key, all.x=TRUE)
# sum up the marks and recaps by lscode
both3 <- aggregate(both2[, c("marks", "recaps")], both2[, "lscode"], sum)
# sum up the marks and recaps by lscode
both3 <- aggregate(both2[, c("marks", "recaps")], list(both2$lscode), sum)
head(both3)
both3 <- aggregate(both2[, c("marks", "recaps")], list(lscode=both2$lscode), sum)
head(both3)
# sum up the marks and recaps by lscode
both3 <- aggregate(both2[, c("marks", "recaps")], both2[, c("year", "lscode")], sum)
head(both3)
mrkrec <- rbind(usmr2, camr2)
# create list of streams for matching with spawner model data
mrkrec$catlast <- ifelse(mrkrec$year==lastyear, mrkrec$catch, 0)
look <- aggregate(mrkrec[, c("catlast", "marks", "recaps")], mrkrec[, c("trib", "country", "estr", "lake")], median, na.rm=TRUE)
look <- look[, c("lake", "country", "estr", "trib", "catlast", "marks", "recaps")]
write.csv(look, "C:/JVA/Lamprey/Adults/AdultIndex/2014/mr-streams.csv", row.names=FALSE)
selmr <- dat$year > (as.numeric(lastyear)-X+0.5) & !is.na(dat$trapcatch)
tssm2 <- sort(unique(dat$lscode[selmr]))
look2 <- dat[dat$year==lastyear & dat$lscode %in% tssm2, c("lake", "country", "estr", "strname", "trapcatch", "lscode", "strcode", "reach")]
write.csv(look2[order(look2$lake, look2$estr, look2$country, look2$strname), ], "C:/JVA/Lamprey/Adults/AdultIndex/2014/sm-streams.csv", row.names=FALSE)
# bring in STREAM KEY to connect mark/recap data to spawner model data
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/MatchStreams.xlsx")
key <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1, startCol=12, endCol=16)
# use this key to assign lscode (lake stream code) numbers to mark/recap data
mrkrec2 <- merge(mrkrec, key, all.x=TRUE)
# sum up the marks and recaps by lscode
mrkrec3 <- aggregate(mrkrec2[, c("marks", "recaps")], mrkrec2[, c("year", "lscode")], sum)
head(mrkrec3)
dim(mrkrec2)
dim(mrkrec3)
summary(mrkrec3)
# bring in mark/recap data from FWS and DFO
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/1984-2014 US MarkRecap Summary.xlsx")
usmr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=2)
names(usmr) <- casefold(names(usmr))
names(usmr)[match(c("lk", "strm", "trib.name", "x.marked", "x.recap"), names(usmr))] <- c("lake", "estr", "trib", "marks", "recaps")
usmr$country <- "US"
usmr2 <- usmr[usmr$year > (as.numeric(lastyear)-X+0.5), c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
# if the catch is NA, I assume it wasn't trapped
usmr2 <- usmr2[!is.na(usmr2$catch), ]
# if marks or recaps are NA, I assume they were zero
usmr2$marks[is.na(usmr2$marks)] <- 0
usmr2$recaps[is.na(usmr2$recaps)] <- 0
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/marked and recaptured DFO.xlsx")
camr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1)
names(camr) <- casefold(names(camr))
names(camr)[match(c("stream_code", "stream_name", "marked", "recaptured", "branch_lentic_name"), names(camr))] <- c("estr", "trib", "marks", "recaps", "branch")
camr$country <- "Canada"
camr$lake <- match(camr$lake_code, Lakeabbs)
camr$catch <- NA
camr2 <- camr[camr$year > (as.numeric(lastyear)-X+0.5), ]
camr2$trib <- paste(camr2$trib, camr2$branch, sep=" - ")
camr2 <- camr2[, c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
# if marks is NA, I assume it wasn't trapped
camr2 <- camr2[!is.na(camr2$marks), ]
# if recaps is NA, I assume it was zero
camr2$recaps[is.na(camr2$recaps)] <- 0
mrkrec <- rbind(usmr2, camr2)
# create list of streams for matching with spawner model data
mrkrec$catlast <- ifelse(mrkrec$year==lastyear, mrkrec$catch, 0)
look <- aggregate(mrkrec[, c("catlast", "marks", "recaps")], mrkrec[, c("trib", "country", "estr", "lake")], median, na.rm=TRUE)
look <- look[, c("lake", "country", "estr", "trib", "catlast", "marks", "recaps")]
write.csv(look, "C:/JVA/Lamprey/Adults/AdultIndex/2014/mr-streams.csv", row.names=FALSE)
selmr <- dat$year > (as.numeric(lastyear)-X+0.5) & !is.na(dat$trapcatch)
tssm2 <- sort(unique(dat$lscode[selmr]))
look2 <- dat[dat$year==lastyear & dat$lscode %in% tssm2, c("lake", "country", "estr", "strname", "trapcatch", "lscode", "strcode", "reach")]
write.csv(look2[order(look2$lake, look2$estr, look2$country, look2$strname), ], "C:/JVA/Lamprey/Adults/AdultIndex/2014/sm-streams.csv", row.names=FALSE)
# bring in STREAM KEY to connect mark/recap data to spawner model data
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/MatchStreams.xlsx")
key <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1, startCol=12, endCol=16)
# use this key to assign lscode (lake stream code) numbers to mark/recap data
mrkrec2 <- merge(mrkrec, key, all.x=TRUE)
# sum up the marks and recaps by lscode
mrkrec3 <- aggregate(mrkrec2[, c("marks", "recaps")], mrkrec2[, c("year", "lscode")], sum)
# then merge the mark/recap data with the spawner model data, by lscode
summary(mrkrec3)
cleanup()
search()
### summary table for trapped streams in spawner model, based on last X years of data ###
X <- 20
# bring in FWS mark/recap data
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/1984-2014 US MarkRecap Summary.xlsx")
usmr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=2)
names(usmr) <- casefold(names(usmr))
names(usmr)[match(c("lk", "strm", "trib.name", "x.marked", "x.recap"), names(usmr))] <- c("lake", "estr", "trib", "marks", "recaps")
usmr$country <- "US"
usmr2 <- usmr[usmr$year > (as.numeric(lastyear)-X+0.5), c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
# these assumptions were okayed by Jess Barber 24 Sep 2014
# if the catch is NA, I assume it wasn't trapped
usmr2 <- usmr2[!is.na(usmr2$catch), ]
# if marks or recaps are NA, I assume they were zero
usmr2$marks[is.na(usmr2$marks)] <- 0
usmr2$recaps[is.na(usmr2$recaps)] <- 0
# bring in DFO mark/recap data
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/marked and recaptured DFO.xlsx")
camr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1)
names(camr) <- casefold(names(camr))
names(camr)[match(c("stream_code", "stream_name", "marked", "recaptured", "branch_lentic_name"), names(camr))] <- c("estr", "trib", "marks", "recaps", "branch")
camr$country <- "Canada"
camr$lake <- match(camr$lake_code, Lakeabbs)
camr$catch <- NA
camr2 <- camr[camr$year > (as.numeric(lastyear)-X+0.5), ]
camr2$trib <- paste(camr2$trib, camr2$branch, sep=" - ")
camr2 <- camr2[, c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
# these assumptions were okayed by Gale Bravener 25 Sep 2014
# if marks or recaps are NA, I assume they were zero
camr2$marks[is.na(camr2$marks)] <- 0
camr2$recaps[is.na(camr2$recaps)] <- 0
# bring in stream-specific data
dat <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/StreamPEdynamicALLCOLS.csv", as.is=T)
dat$ls <- dat$lscode
lastyear <- max(dat$year)
### summary table for trapped streams in spawner model, based on last X years of data ###
X <- 20
# bring in FWS mark/recap data
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/1984-2014 US MarkRecap Summary.xlsx")
usmr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=2)
names(usmr) <- casefold(names(usmr))
names(usmr)[match(c("lk", "strm", "trib.name", "x.marked", "x.recap"), names(usmr))] <- c("lake", "estr", "trib", "marks", "recaps")
usmr$country <- "US"
usmr2 <- usmr[usmr$year > (as.numeric(lastyear)-X+0.5), c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
# these assumptions were okayed by Jess Barber 24 Sep 2014
# if the catch is NA, I assume it wasn't trapped
usmr2 <- usmr2[!is.na(usmr2$catch), ]
# if marks or recaps are NA, I assume they were zero
usmr2$marks[is.na(usmr2$marks)] <- 0
usmr2$recaps[is.na(usmr2$recaps)] <- 0
# bring in DFO mark/recap data
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/marked and recaptured DFO.xlsx")
camr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1)
names(camr) <- casefold(names(camr))
names(camr)[match(c("stream_code", "stream_name", "marked", "recaptured", "branch_lentic_name"), names(camr))] <- c("estr", "trib", "marks", "recaps", "branch")
camr$country <- "Canada"
camr$lake <- match(camr$lake_code, Lakeabbs)
camr$catch <- NA
camr2 <- camr[camr$year > (as.numeric(lastyear)-X+0.5), ]
camr2$trib <- paste(camr2$trib, camr2$branch, sep=" - ")
camr2 <- camr2[, c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
# these assumptions were okayed by Gale Bravener 25 Sep 2014
# if marks or recaps are NA, I assume they were zero
camr2$marks[is.na(camr2$marks)] <- 0
camr2$recaps[is.na(camr2$recaps)] <- 0
# create two lists of streams for matching with spawner model data
mrkrec$catlast <- ifelse(mrkrec$year==lastyear, mrkrec$catch, 0)
look <- aggregate(mrkrec[, c("catlast", "marks", "recaps")], mrkrec[, c("trib", "country", "estr", "lake")], median, na.rm=TRUE)
look <- look[, c("lake", "country", "estr", "trib", "catlast", "marks", "recaps")]
write.csv(look, "C:/JVA/Lamprey/Adults/AdultIndex/2014/mr-streams.csv", row.names=FALSE)
selmr <- dat$year > (as.numeric(lastyear)-X+0.5) & !is.na(dat$trapcatch)
tssm2 <- sort(unique(dat$lscode[selmr]))
look2 <- dat[dat$year==lastyear & dat$lscode %in% tssm2, c("lake", "country", "estr", "strname", "trapcatch", "lscode", "strcode", "reach")]
write.csv(look2[order(look2$lake, look2$estr, look2$country, look2$strname), ], "C:/JVA/Lamprey/Adults/AdultIndex/2014/sm-streams.csv", row.names=FALSE)
# then the file MatchStreams.xlsx is manually edited to match up the streams
# bring in STREAM KEY to connect mark/recap data to spawner model data
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/MatchStreams.xlsx")
key <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1, startCol=12, endCol=16)
# use this key to assign lscode (lake stream code) numbers to mark/recap data
mrkrec2 <- merge(mrkrec, key, all.x=TRUE)
# sum up the marks and recaps by lscode
mrkrec3 <- aggregate(mrkrec2[, c("marks", "recaps")], mrkrec2[, c("year", "lscode")], sum)
# then merge the mark/recap data with the spawner model data, by lscode
.Last
history
history(max.show=Inf)
# combine FWS and DFO mark/recap data
mrkrec <- rbind(usmr2, camr2)
# create two lists of streams for matching with spawner model data
mrkrec$catlast <- ifelse(mrkrec$year==lastyear, mrkrec$catch, 0)
look <- aggregate(mrkrec[, c("catlast", "marks", "recaps")], mrkrec[, c("trib", "country", "estr", "lake")], median, na.rm=TRUE)
look <- look[, c("lake", "country", "estr", "trib", "catlast", "marks", "recaps")]
write.csv(look, "C:/JVA/Lamprey/Adults/AdultIndex/2014/mr-streams.csv", row.names=FALSE)
selmr <- dat$year > (as.numeric(lastyear)-X+0.5) & !is.na(dat$trapcatch)
tssm2 <- sort(unique(dat$lscode[selmr]))
look2 <- dat[dat$year==lastyear & dat$lscode %in% tssm2, c("lake", "country", "estr", "strname", "trapcatch", "lscode", "strcode", "reach")]
write.csv(look2[order(look2$lake, look2$estr, look2$country, look2$strname), ], "C:/JVA/Lamprey/Adults/AdultIndex/2014/sm-streams.csv", row.names=FALSE)
# then the file MatchStreams.xlsx is manually edited to match up the streams
# bring in STREAM KEY to connect mark/recap data to spawner model data
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/MatchStreams.xlsx")
key <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1, startCol=12, endCol=16)
# use this key to assign lscode (lake stream code) numbers to mark/recap data
mrkrec2 <- merge(mrkrec, key, all.x=TRUE)
# sum up the marks and recaps by lscode
mrkrec3 <- aggregate(mrkrec2[, c("marks", "recaps")], mrkrec2[, c("year", "lscode")], sum)
# then merge the mark/recap data with the spawner model data, by lscode
.Last <- function()
    if(interactive()) try(savehistory("~/.Rhistory"))
cleanup()
q()
.Last <- function()
    if(interactive()) try(savehistory())
q()
x <- 1
y <- 2
cleanup()
q()
loadhistory()
par(mar=c(4, 4, 1, 5), cex=1.5)
sy <- ontlook$year > 2003.5
plot(1, 1, type="n", log="y", las=1, xlim=range(ontlook$year[sy]), ylim=range(ontlook$Emr[sy], ontlook$Pmr[sy], na.rm=TRUE)/1000, xlab="Year", ylab="Adults")
for(i in 1:3) {
mycol <- blindcolz[c(3, 6, 5, 4, 2)[i]]
sel <- sy & ontlook$lscode==sus[i]
points(ontlook$year[sel], ontlook$Emr[sel]/1000, col=mycol, lwd=3, pch=16, type="o")
sel3 <- sel & ontlook$year>2008.5
mtext(ontlook$strname[sel3][1], side=4, at=median(ontlook$Emr[sel3]/1000, na.rm=TRUE), col=mycol, las=1, cex=1.5, line=0.2)
}
box()
# just Sterling & Black
windows(w=10, h=6)
par(mar=c(4, 4, 1, 5), cex=1.5)
sy <- ontlook$year > 2003.5
plot(1, 1, type="n", log="y", las=1, xlim=range(ontlook$year[sy]), ylim=range(ontlook$Emr[sy], ontlook$Pmr[sy], na.rm=TRUE)/1000, xlab="Year", ylab="Adults")
for(i in 4:5) {
mycol <- blindcolz[c(3, 6, 5, 4, 2)[i]]
sel <- sy & ontlook$lscode==sus[i]
points(ontlook$year[sel], ontlook$Emr[sel]/1000, col=mycol, lwd=3, pch=16, type="o")
sel3 <- sel & ontlook$year>2008.5
mtext(ontlook$strname[sel3][1], side=4, at=median(ontlook$Emr[sel3]/1000, na.rm=TRUE), col=mycol, las=1, cex=1.5, line=0.2)
}
box()
# just Sterling & Black ESTIMATED
windows(w=10, h=6)
par(mar=c(4, 4, 1, 5), cex=1.5)
sy <- ontlook$year > 2003.5
plot(1, 1, type="n", log="y", las=1, xlim=range(ontlook$year[sy]), ylim=range(ontlook$Emr[sy], ontlook$Pmr[sy], na.rm=TRUE)/1000, xlab="Year", ylab="Adults")
for(i in 4:5) {
mycol <- blindcolz[c(3, 6, 5, 4, 2)[i]]
sel <- sy & ontlook$lscode==sus[i]
lines(ontlook$year[sel], ontlook$COMBmr[sel]/1000, col=mycol, lwd=3, lty=2, lend="square")
points(ontlook$year[sel & is.na(ontlook$Emr)], ontlook$Pmr[sel & is.na(ontlook$Emr)]/1000, col=mycol, pch=16, cex=1.5)
sel3 <- sel & ontlook$year>2008.5
mtext(ontlook$strname[sel3][1], side=4, at=median(ontlook$Emr[sel3]/1000, na.rm=TRUE), col=mycol, las=1, cex=1.5, line=0.2)
}
box()
### spawner model and adult index time series overlaid
windows(h=4.5, w=5)
par(mar=c(4, 4, 2, 3), cex=1.2, yaxs="i")
i <- 5
myindxdf <- indices[[i]]$indxdf# year lake indxraw n.mr indxkeep indxkeep.lo indxkeep.hi
convfac <- indices[[i]]$scaleup
x1 <- myindxdf$year
y1 <- myindxdf$indxkeep/1000
ylo <- myindxdf$indxkeep.lo/1000
yhi <- myindxdf$indxkeep.hi/1000
yr <- 1.05*range(0, y1, yhi[x1>=YEAR1], na.rm=TRUE)
plot(x1, y1, type="n", xlim=range(x1[!is.na(y1)]), ylim=1.05*range(0, yhi, na.rm=TRUE), xlab="Year", ylab="Adult abundance  (thousands)", main=Lakenames[i], axes=FALSE)
axis(1)
axis(2, col=blindcolz[7], col.axis=blindcolz[7], las=1)
arrows(x1, ylo, x1, yhi, length=0, angle=90, code=3, lwd=10, lend="square", col="#ffddc1")
abline(h=targets.ai.adj$target[i]/1000, col=blindcolz[7], lty=2)
lines(x1, y1, col=blindcolz[7], type="o", pch=17, lwd=2)
par(mgp=c(3, 2.2, 0))
axis(4, at=pretty(convfac*yr)/convfac, labels=pretty(convfac*yr), col=blindcolz[3], col.axis=blindcolz[3], las=1, hadj=1)
box()
rm(ontlook, sus, sy, ss, mycol, sel, sel3, i, myindxdf, convfac, x1, y1, ylo, yhi, yr)
}
# summary table for trapped streams in spawner model, based on last X years of data
X <- 20
selmr <- dat$year > (as.numeric(lastyear)-X+0.5) & dat$est.source=="m-r"
tssm <- sort(unique(dat$lscode[selmr]))
sel <- dat$year > (as.numeric(lastyear)-X+0.5) & dat$lscode %in% tssm
mPE <- tapply(dat$Emr[sel], dat$lscode[sel], median, na.rm=TRUE)
mtc <- tapply(dat$trapcatch[sel], dat$lscode[sel], median, na.rm=TRUE)
mef <- tapply((dat$trapcatch/dat$Emr)[sel], dat$lscode[sel], median, na.rm=TRUE)
nyr <- tapply(!is.na(dat$Emr)[sel], dat$lscode[sel], sum)
wpyr <- tapply((dat$year-(as.numeric(lastyear)-X))[sel & !is.na(dat$Emr)], dat$lscode[sel & !is.na(dat$Emr)], sum)/((X+1)*(X/2))
mdf <- data.frame(mPE, mtc, mef, nyr, wpyr)
mdf <- cbind(dat[match(rownames(mdf), dat$lscode), c("lake", "country", "lscode", "strname", "estr")], mdf)
mdf$type <- c("", "Index")[mdf$lscode %in% unlist(index.streams) + 1]
rankl <- rank(rank(-mdf$wpyr) + rank(-mdf$mPE))
mdf$rank <- unlist(tapply(rankl, mdf$lake, rank))
ord <- order(mdf$lake, -(rank(mdf$mPE) + rank(mdf$nyr)))
ord <- order(mdf$lake, -mdf$mPE, -mdf$wpyr)
ord <- order(mdf$lake, mdf$rank)
mdf[ord, c("lake", "country", "lscode", "strname", "type", "rank", "nyr", "wpyr", "mPE", "mtc", "mef")]
rm(selmr, sel, mPE, mtc, mef, nyr, wpyr, rankl, ord)
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/1984-2014 US MarkRecap Summary.xlsx")
usmr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=2)
names(usmr) <- casefold(names(usmr))
names(usmr)[match(c("lk", "strm", "trib.name", "x.marked", "x.recap"), names(usmr))] <- c("lake", "estr", "trib", "marks", "recaps")
usmr$country <- "US"
usmr2 <- usmr[usmr$year > (as.numeric(lastyear)-X+0.5), c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
# assume missing values are zeroes
#############################################################################################
# Okay.  So if the catch is NA, I'll assume it wasn't trapped.  
# But if the catch is some number (even if it's 0) and the marks and the recaps are NA, 
# I'll assume that there were 0 marks and or 0 recaps.
#############################################################################################
head(usmr2)
table(is.na(usmr2$catch), is.na(usmr2$marks), is.na(usmr2$recaps))
summary(usmr2[is.na(usmr2$catch), ])
with(usmr2, table(is.na(catch), is.na(marks) | marks<1, is.na(recaps) | recaps < 1)
)
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/1984-2014 US MarkRecap Summary.xlsx")
usmr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=2)
names(usmr) <- casefold(names(usmr))
names(usmr)[match(c("lk", "strm", "trib.name", "x.marked", "x.recap"), names(usmr))] <- c("lake", "estr", "trib", "marks", "recaps")
usmr$country <- "US"
usmr2 <- usmr[usmr$year > (as.numeric(lastyear)-X+0.5), c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
# if the catch is NA, I assume it wasn't trapped
usmr2 <- usmr2[!is.na(usmr2$catch), ]
# if marks or recaps are NA, I assume they were zero
usmr2$marks[is.na(usmr2$marks)] <- 0
usmr2$recaps[is.na(usmr2$recaps)] <- 0
summary(usmr2)
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/marked and recaptured DFO.xlsx")
camr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1)
names(camr) <- casefold(names(camr))
names(camr)[match(c("stream_code", "stream_name", "marked", "recaptured"), names(camr))] <- c("estr", "trib", "marks", "recaps")
camr$country <- "Canada"
camr$lake <- match(camr$lake_code, Lakeabbs)
camr$catch <- NA
camr2 <- camr[camr$year > (as.numeric(lastyear)-X+0.5), c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
summary(camr2)
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/marked and recaptured DFO.xlsx")
camr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1)
names(camr) <- casefold(names(camr))
names(camr)[match(c("stream_code", "stream_name", "marked", "recaptured"), names(camr))] <- c("estr", "trib", "marks", "recaps")
camr$country <- "Canada"
camr$lake <- match(camr$lake_code, Lakeabbs)
camr$catch <- NA
camr2 <- camr[camr$year > (as.numeric(lastyear)-X+0.5), c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
summary(camr2)
camr2[is.na(camr2$recaps), ]
head(camr)
head(camr)
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/1984-2014 US MarkRecap Summary.xlsx")
usmr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=2)
names(usmr) <- casefold(names(usmr))
names(usmr)[match(c("lk", "strm", "trib.name", "x.marked", "x.recap"), names(usmr))] <- c("lake", "estr", "trib", "marks", "recaps")
usmr$country <- "US"
usmr2 <- usmr[usmr$year > (as.numeric(lastyear)-X+0.5), c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
usmr2$branch <- ""
# if the catch is NA, I assume it wasn't trapped
usmr2 <- usmr2[!is.na(usmr2$catch), ]
# if marks or recaps are NA, I assume they were zero
usmr2$marks[is.na(usmr2$marks)] <- 0
usmr2$recaps[is.na(usmr2$recaps)] <- 0
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/marked and recaptured DFO.xlsx")
camr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1)
names(camr) <- casefold(names(camr))
names(camr)[match(c("stream_code", "stream_name", "marked", "recaptured". "branch_lentic_name"), names(camr))] <- c("estr", "trib", "marks", "recaps", "branch")
camr$country <- "Canada"
camr$lake <- match(camr$lake_code, Lakeabbs)
camr$catch <- NA
camr2 <- camr[camr$year > (as.numeric(lastyear)-X+0.5), c("lake", "country", "estr", "trib", "branch", "year", "catch", "marks", "recaps")]
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/1984-2014 US MarkRecap Summary.xlsx")
usmr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=2)
names(usmr) <- casefold(names(usmr))
names(usmr)[match(c("lk", "strm", "trib.name", "x.marked", "x.recap"), names(usmr))] <- c("lake", "estr", "trib", "marks", "recaps")
usmr$country <- "US"
usmr2 <- usmr[usmr$year > (as.numeric(lastyear)-X+0.5), c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
usmr2$branch <- ""
# if the catch is NA, I assume it wasn't trapped
usmr2 <- usmr2[!is.na(usmr2$catch), ]
# if marks or recaps are NA, I assume they were zero
usmr2$marks[is.na(usmr2$marks)] <- 0
usmr2$recaps[is.na(usmr2$recaps)] <- 0
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/marked and recaptured DFO.xlsx")
camr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1)
names(camr) <- casefold(names(camr))
names(camr)[match(c("stream_code", "stream_name", "marked", "recaptured", "branch_lentic_name"), names(camr))] <- c("estr", "trib", "marks", "recaps", "branch")
camr$country <- "Canada"
camr$lake <- match(camr$lake_code, Lakeabbs)
camr$catch <- NA
camr2 <- camr[camr$year > (as.numeric(lastyear)-X+0.5), c("lake", "country", "estr", "trib", "branch", "year", "catch", "marks", "recaps")]
head(camr2)
summary(camr2)
camr2[is.na(camr2$recaps), ]
camr2[is.na(camr2$recaps), -7]
camr2[camr2$estr==571, ]
camr2[camr2$estr==571, -7]
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/1984-2014 US MarkRecap Summary.xlsx")
usmr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=2)
names(usmr) <- casefold(names(usmr))
names(usmr)[match(c("lk", "strm", "trib.name", "x.marked", "x.recap"), names(usmr))] <- c("lake", "estr", "trib", "marks", "recaps")
usmr$country <- "US"
usmr2 <- usmr[usmr$year > (as.numeric(lastyear)-X+0.5), c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
usmr2$branch <- ""
# if the catch is NA, I assume it wasn't trapped
usmr2 <- usmr2[!is.na(usmr2$catch), ]
# if marks or recaps are NA, I assume they were zero
usmr2$marks[is.na(usmr2$marks)] <- 0
usmr2$recaps[is.na(usmr2$recaps)] <- 0
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/marked and recaptured DFO.xlsx")
camr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1)
names(camr) <- casefold(names(camr))
names(camr)[match(c("stream_code", "stream_name", "marked", "recaptured", "branch_lentic_name"), names(camr))] <- c("estr", "trib", "marks", "recaps", "branch")
camr$country <- "Canada"
camr$lake <- match(camr$lake_code, Lakeabbs)
camr$catch <- NA
camr2 <- camr[camr$year > (as.numeric(lastyear)-X+0.5), c("lake", "country", "estr", "trib", "branch", "year", "catch", "marks", "recaps")]
both <- rbind(usmr2, camr2)
# create list of streams for matching with spawner model data
both$catlast <- ifelse(both$year==lastyear, both$catch, 0)
look <- aggregate(both[, c("catlast", "marks", "recaps")], both[, c("trib", "country", "estr", "lake")], median, na.rm=TRUE)
look <- look[, c("lake", "country", "estr", "trib", "catlast", "marks", "recaps")]
write.csv(look, "C:/JVA/Lamprey/Adults/AdultIndex/2014/mr-streams.csv", row.names=FALSE)
selmr <- dat$year > (as.numeric(lastyear)-X+0.5) & !is.na(dat$trapcatch)
tssm2 <- sort(unique(dat$lscode[selmr]))
look2 <- dat[dat$year==lastyear & dat$lscode %in% tssm2, c("lake", "country", "estr", "strname", "trapcatch", "lscode", "strcode", "reach")]
write.csv(look2[order(look2$lake, look2$estr, look2$country, look2$strname), ], "C:/JVA/Lamprey/Adults/AdultIndex/2014/sm-streams.csv", row.names=FALSE)
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/1984-2014 US MarkRecap Summary.xlsx")
usmr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=2)
names(usmr) <- casefold(names(usmr))
names(usmr)[match(c("lk", "strm", "trib.name", "x.marked", "x.recap"), names(usmr))] <- c("lake", "estr", "trib", "marks", "recaps")
usmr$country <- "US"
usmr2 <- usmr[usmr$year > (as.numeric(lastyear)-X+0.5), c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
usmr2$branch <- ""
# if the catch is NA, I assume it wasn't trapped
usmr2 <- usmr2[!is.na(usmr2$catch), ]
# if marks or recaps are NA, I assume they were zero
usmr2$marks[is.na(usmr2$marks)] <- 0
usmr2$recaps[is.na(usmr2$recaps)] <- 0
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/marked and recaptured DFO.xlsx")
camr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1)
names(camr) <- casefold(names(camr))
names(camr)[match(c("stream_code", "stream_name", "marked", "recaptured", "branch_lentic_name"), names(camr))] <- c("estr", "trib", "marks", "recaps", "branch")
camr$country <- "Canada"
camr$lake <- match(camr$lake_code, Lakeabbs)
camr$catch <- NA
camr2 <- camr[camr$year > (as.numeric(lastyear)-X+0.5), c("lake", "country", "estr", "trib", "branch", "year", "catch", "marks", "recaps")]
both <- rbind(usmr2, camr2)
# create list of streams for matching with spawner model data
both$catlast <- ifelse(both$year==lastyear, both$catch, 0)
look <- aggregate(both[, c("catlast", "marks", "recaps")], both[, c("branch", "trib", "country", "estr", "lake")], median, na.rm=TRUE)
look <- look[, c("lake", "country", "estr", "trib", "branch", "catlast", "marks", "recaps")]
write.csv(look, "C:/JVA/Lamprey/Adults/AdultIndex/2014/mr-streams.csv", row.names=FALSE)
selmr <- dat$year > (as.numeric(lastyear)-X+0.5) & !is.na(dat$trapcatch)
tssm2 <- sort(unique(dat$lscode[selmr]))
look2 <- dat[dat$year==lastyear & dat$lscode %in% tssm2, c("lake", "country", "estr", "strname", "trapcatch", "lscode", "strcode", "reach")]
write.csv(look2[order(look2$lake, look2$estr, look2$country, look2$strname), ], "C:/JVA/Lamprey/Adults/AdultIndex/2014/sm-streams.csv", row.names=FALSE)
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/1984-2014 US MarkRecap Summary.xlsx")
usmr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=2)
names(usmr) <- casefold(names(usmr))
names(usmr)[match(c("lk", "strm", "trib.name", "x.marked", "x.recap"), names(usmr))] <- c("lake", "estr", "trib", "marks", "recaps")
usmr$country <- "US"
usmr2 <- usmr[usmr$year > (as.numeric(lastyear)-X+0.5), c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
# if the catch is NA, I assume it wasn't trapped
usmr2 <- usmr2[!is.na(usmr2$catch), ]
# if marks or recaps are NA, I assume they were zero
usmr2$marks[is.na(usmr2$marks)] <- 0
usmr2$recaps[is.na(usmr2$recaps)] <- 0
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/marked and recaptured DFO.xlsx")
camr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1)
names(camr) <- casefold(names(camr))
names(camr)[match(c("stream_code", "stream_name", "marked", "recaptured", "branch_lentic_name"), names(camr))] <- c("estr", "trib", "marks", "recaps", "branch")
camr$country <- "Canada"
camr$lake <- match(camr$lake_code, Lakeabbs)
camr$catch <- NA
camr2 <- camr[camr$year > (as.numeric(lastyear)-X+0.5), c("lake", "country", "estr", "trib", "branch", "year", "catch", "marks", "recaps")]
camr2$trib <- paste(camr2$trib, camr2$branch, sep=" - ")
both <- rbind(usmr2, camr2)
# create list of streams for matching with spawner model data
both$catlast <- ifelse(both$year==lastyear, both$catch, 0)
look <- aggregate(both[, c("catlast", "marks", "recaps")], both[, c("trib", "country", "estr", "lake")], median, na.rm=TRUE)
look <- look[, c("lake", "country", "estr", "trib", "catlast", "marks", "recaps")]
write.csv(look, "C:/JVA/Lamprey/Adults/AdultIndex/2014/mr-streams.csv", row.names=FALSE)
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/1984-2014 US MarkRecap Summary.xlsx")
usmr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=2)
names(usmr) <- casefold(names(usmr))
names(usmr)[match(c("lk", "strm", "trib.name", "x.marked", "x.recap"), names(usmr))] <- c("lake", "estr", "trib", "marks", "recaps")
usmr$country <- "US"
usmr2 <- usmr[usmr$year > (as.numeric(lastyear)-X+0.5), c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
# if the catch is NA, I assume it wasn't trapped
usmr2 <- usmr2[!is.na(usmr2$catch), ]
# if marks or recaps are NA, I assume they were zero
usmr2$marks[is.na(usmr2$marks)] <- 0
usmr2$recaps[is.na(usmr2$recaps)] <- 0
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/marked and recaptured DFO.xlsx")
camr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1)
names(camr) <- casefold(names(camr))
names(camr)[match(c("stream_code", "stream_name", "marked", "recaptured", "branch_lentic_name"), names(camr))] <- c("estr", "trib", "marks", "recaps", "branch")
camr$country <- "Canada"
camr$lake <- match(camr$lake_code, Lakeabbs)
camr$catch <- NA
camr2 <- camr[camr$year > (as.numeric(lastyear)-X+0.5), ]
camr2$trib <- paste(camr2$trib, camr2$branch, sep=" - ")
camr2 <- camr2[, c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
both <- rbind(usmr2, camr2)
# create list of streams for matching with spawner model data
both$catlast <- ifelse(both$year==lastyear, both$catch, 0)
look <- aggregate(both[, c("catlast", "marks", "recaps")], both[, c("trib", "country", "estr", "lake")], median, na.rm=TRUE)
look <- look[, c("lake", "country", "estr", "trib", "catlast", "marks", "recaps")]
write.csv(look, "C:/JVA/Lamprey/Adults/AdultIndex/2014/mr-streams.csv", row.names=FALSE)
# bring in STREAM KEY to connect mark/recap data to spawner model data
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/MatchStreams.xlsx")
key <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1, startCol=12)
head(key)
# bring in STREAM KEY to connect mark/recap data to spawner model data
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/MatchStreams.xlsx")
key <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1, startCol=12, endCol=16)
head(key)
# use this key to assign lscode (lake stream code) numbers to mark/recap data
markrecap <- merge(both, key, by="lscode", all=x)
head(both)
head(
# use this key to assign lscode (lake stream code) numbers to mark/recap data
markrecap <- merge(both, key, all=x)
# use this key to assign lscode (lake stream code) numbers to mark/recap data
markrecap <- merge(both, key, all=x)
# use this key to assign lscode (lake stream code) numbers to mark/recap data
markrecap <- merge(both, key, all=x)
# use this key to assign lscode (lake stream code) numbers to mark/recap data
markrecap <- merge(both, key, all.x=TRUE)
dim(both)
dim(markrecap)
head(markrecap)
dput(names(markrecap))
# use this key to assign lscode (lake stream code) numbers to mark/recap data
markrecap <- merge(both[, c("lake", "country", "estr", "trib", "year", "marks", "recaps")], key, all.x=TRUE)
head(markrecap)
# use this key to assign lscode (lake stream code) numbers to mark/recap data
both2 <- merge(both, key, all.x=TRUE)
# sum up the marks and recaps by lscode
both3 <- aggregate(both2[, c("marks", "recaps")], both2[, "lscode"], sum)
# sum up the marks and recaps by lscode
both3 <- aggregate(both2[, c("marks", "recaps")], list(both2$lscode), sum)
head(both3)
both3 <- aggregate(both2[, c("marks", "recaps")], list(lscode=both2$lscode), sum)
head(both3)
# sum up the marks and recaps by lscode
both3 <- aggregate(both2[, c("marks", "recaps")], both2[, c("year", "lscode")], sum)
head(both3)
mrkrec <- rbind(usmr2, camr2)
# create list of streams for matching with spawner model data
mrkrec$catlast <- ifelse(mrkrec$year==lastyear, mrkrec$catch, 0)
look <- aggregate(mrkrec[, c("catlast", "marks", "recaps")], mrkrec[, c("trib", "country", "estr", "lake")], median, na.rm=TRUE)
look <- look[, c("lake", "country", "estr", "trib", "catlast", "marks", "recaps")]
write.csv(look, "C:/JVA/Lamprey/Adults/AdultIndex/2014/mr-streams.csv", row.names=FALSE)
selmr <- dat$year > (as.numeric(lastyear)-X+0.5) & !is.na(dat$trapcatch)
tssm2 <- sort(unique(dat$lscode[selmr]))
look2 <- dat[dat$year==lastyear & dat$lscode %in% tssm2, c("lake", "country", "estr", "strname", "trapcatch", "lscode", "strcode", "reach")]
write.csv(look2[order(look2$lake, look2$estr, look2$country, look2$strname), ], "C:/JVA/Lamprey/Adults/AdultIndex/2014/sm-streams.csv", row.names=FALSE)
# bring in STREAM KEY to connect mark/recap data to spawner model data
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/MatchStreams.xlsx")
key <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1, startCol=12, endCol=16)
# use this key to assign lscode (lake stream code) numbers to mark/recap data
mrkrec2 <- merge(mrkrec, key, all.x=TRUE)
# sum up the marks and recaps by lscode
mrkrec3 <- aggregate(mrkrec2[, c("marks", "recaps")], mrkrec2[, c("year", "lscode")], sum)
head(mrkrec3)
dim(mrkrec2)
dim(mrkrec3)
summary(mrkrec3)
# bring in mark/recap data from FWS and DFO
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/1984-2014 US MarkRecap Summary.xlsx")
usmr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=2)
names(usmr) <- casefold(names(usmr))
names(usmr)[match(c("lk", "strm", "trib.name", "x.marked", "x.recap"), names(usmr))] <- c("lake", "estr", "trib", "marks", "recaps")
usmr$country <- "US"
usmr2 <- usmr[usmr$year > (as.numeric(lastyear)-X+0.5), c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
# if the catch is NA, I assume it wasn't trapped
usmr2 <- usmr2[!is.na(usmr2$catch), ]
# if marks or recaps are NA, I assume they were zero
usmr2$marks[is.na(usmr2$marks)] <- 0
usmr2$recaps[is.na(usmr2$recaps)] <- 0
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/marked and recaptured DFO.xlsx")
camr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1)
names(camr) <- casefold(names(camr))
names(camr)[match(c("stream_code", "stream_name", "marked", "recaptured", "branch_lentic_name"), names(camr))] <- c("estr", "trib", "marks", "recaps", "branch")
camr$country <- "Canada"
camr$lake <- match(camr$lake_code, Lakeabbs)
camr$catch <- NA
camr2 <- camr[camr$year > (as.numeric(lastyear)-X+0.5), ]
camr2$trib <- paste(camr2$trib, camr2$branch, sep=" - ")
camr2 <- camr2[, c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
# if marks is NA, I assume it wasn't trapped
camr2 <- camr2[!is.na(camr2$marks), ]
# if recaps is NA, I assume it was zero
camr2$recaps[is.na(camr2$recaps)] <- 0
mrkrec <- rbind(usmr2, camr2)
# create list of streams for matching with spawner model data
mrkrec$catlast <- ifelse(mrkrec$year==lastyear, mrkrec$catch, 0)
look <- aggregate(mrkrec[, c("catlast", "marks", "recaps")], mrkrec[, c("trib", "country", "estr", "lake")], median, na.rm=TRUE)
look <- look[, c("lake", "country", "estr", "trib", "catlast", "marks", "recaps")]
write.csv(look, "C:/JVA/Lamprey/Adults/AdultIndex/2014/mr-streams.csv", row.names=FALSE)
selmr <- dat$year > (as.numeric(lastyear)-X+0.5) & !is.na(dat$trapcatch)
tssm2 <- sort(unique(dat$lscode[selmr]))
look2 <- dat[dat$year==lastyear & dat$lscode %in% tssm2, c("lake", "country", "estr", "strname", "trapcatch", "lscode", "strcode", "reach")]
write.csv(look2[order(look2$lake, look2$estr, look2$country, look2$strname), ], "C:/JVA/Lamprey/Adults/AdultIndex/2014/sm-streams.csv", row.names=FALSE)
# bring in STREAM KEY to connect mark/recap data to spawner model data
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/MatchStreams.xlsx")
key <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1, startCol=12, endCol=16)
# use this key to assign lscode (lake stream code) numbers to mark/recap data
mrkrec2 <- merge(mrkrec, key, all.x=TRUE)
# sum up the marks and recaps by lscode
mrkrec3 <- aggregate(mrkrec2[, c("marks", "recaps")], mrkrec2[, c("year", "lscode")], sum)
# then merge the mark/recap data with the spawner model data, by lscode
summary(mrkrec3)
cleanup()
search()
### summary table for trapped streams in spawner model, based on last X years of data ###
X <- 20
# bring in FWS mark/recap data
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/1984-2014 US MarkRecap Summary.xlsx")
usmr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=2)
names(usmr) <- casefold(names(usmr))
names(usmr)[match(c("lk", "strm", "trib.name", "x.marked", "x.recap"), names(usmr))] <- c("lake", "estr", "trib", "marks", "recaps")
usmr$country <- "US"
usmr2 <- usmr[usmr$year > (as.numeric(lastyear)-X+0.5), c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
# these assumptions were okayed by Jess Barber 24 Sep 2014
# if the catch is NA, I assume it wasn't trapped
usmr2 <- usmr2[!is.na(usmr2$catch), ]
# if marks or recaps are NA, I assume they were zero
usmr2$marks[is.na(usmr2$marks)] <- 0
usmr2$recaps[is.na(usmr2$recaps)] <- 0
# bring in DFO mark/recap data
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/marked and recaptured DFO.xlsx")
camr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1)
names(camr) <- casefold(names(camr))
names(camr)[match(c("stream_code", "stream_name", "marked", "recaptured", "branch_lentic_name"), names(camr))] <- c("estr", "trib", "marks", "recaps", "branch")
camr$country <- "Canada"
camr$lake <- match(camr$lake_code, Lakeabbs)
camr$catch <- NA
camr2 <- camr[camr$year > (as.numeric(lastyear)-X+0.5), ]
camr2$trib <- paste(camr2$trib, camr2$branch, sep=" - ")
camr2 <- camr2[, c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
# these assumptions were okayed by Gale Bravener 25 Sep 2014
# if marks or recaps are NA, I assume they were zero
camr2$marks[is.na(camr2$marks)] <- 0
camr2$recaps[is.na(camr2$recaps)] <- 0
# bring in stream-specific data
dat <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/StreamPEdynamicALLCOLS.csv", as.is=T)
dat$ls <- dat$lscode
lastyear <- max(dat$year)
### summary table for trapped streams in spawner model, based on last X years of data ###
X <- 20
# bring in FWS mark/recap data
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/1984-2014 US MarkRecap Summary.xlsx")
usmr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=2)
names(usmr) <- casefold(names(usmr))
names(usmr)[match(c("lk", "strm", "trib.name", "x.marked", "x.recap"), names(usmr))] <- c("lake", "estr", "trib", "marks", "recaps")
usmr$country <- "US"
usmr2 <- usmr[usmr$year > (as.numeric(lastyear)-X+0.5), c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
# these assumptions were okayed by Jess Barber 24 Sep 2014
# if the catch is NA, I assume it wasn't trapped
usmr2 <- usmr2[!is.na(usmr2$catch), ]
# if marks or recaps are NA, I assume they were zero
usmr2$marks[is.na(usmr2$marks)] <- 0
usmr2$recaps[is.na(usmr2$recaps)] <- 0
# bring in DFO mark/recap data
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/marked and recaptured DFO.xlsx")
camr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1)
names(camr) <- casefold(names(camr))
names(camr)[match(c("stream_code", "stream_name", "marked", "recaptured", "branch_lentic_name"), names(camr))] <- c("estr", "trib", "marks", "recaps", "branch")
camr$country <- "Canada"
camr$lake <- match(camr$lake_code, Lakeabbs)
camr$catch <- NA
camr2 <- camr[camr$year > (as.numeric(lastyear)-X+0.5), ]
camr2$trib <- paste(camr2$trib, camr2$branch, sep=" - ")
camr2 <- camr2[, c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
# these assumptions were okayed by Gale Bravener 25 Sep 2014
# if marks or recaps are NA, I assume they were zero
camr2$marks[is.na(camr2$marks)] <- 0
camr2$recaps[is.na(camr2$recaps)] <- 0
# create two lists of streams for matching with spawner model data
mrkrec$catlast <- ifelse(mrkrec$year==lastyear, mrkrec$catch, 0)
look <- aggregate(mrkrec[, c("catlast", "marks", "recaps")], mrkrec[, c("trib", "country", "estr", "lake")], median, na.rm=TRUE)
look <- look[, c("lake", "country", "estr", "trib", "catlast", "marks", "recaps")]
write.csv(look, "C:/JVA/Lamprey/Adults/AdultIndex/2014/mr-streams.csv", row.names=FALSE)
selmr <- dat$year > (as.numeric(lastyear)-X+0.5) & !is.na(dat$trapcatch)
tssm2 <- sort(unique(dat$lscode[selmr]))
look2 <- dat[dat$year==lastyear & dat$lscode %in% tssm2, c("lake", "country", "estr", "strname", "trapcatch", "lscode", "strcode", "reach")]
write.csv(look2[order(look2$lake, look2$estr, look2$country, look2$strname), ], "C:/JVA/Lamprey/Adults/AdultIndex/2014/sm-streams.csv", row.names=FALSE)
# then the file MatchStreams.xlsx is manually edited to match up the streams
# bring in STREAM KEY to connect mark/recap data to spawner model data
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/MatchStreams.xlsx")
key <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1, startCol=12, endCol=16)
# use this key to assign lscode (lake stream code) numbers to mark/recap data
mrkrec2 <- merge(mrkrec, key, all.x=TRUE)
# sum up the marks and recaps by lscode
mrkrec3 <- aggregate(mrkrec2[, c("marks", "recaps")], mrkrec2[, c("year", "lscode")], sum)
# then merge the mark/recap data with the spawner model data, by lscode
.Last
history
history(max.show=Inf)
# combine FWS and DFO mark/recap data
mrkrec <- rbind(usmr2, camr2)
# create two lists of streams for matching with spawner model data
mrkrec$catlast <- ifelse(mrkrec$year==lastyear, mrkrec$catch, 0)
look <- aggregate(mrkrec[, c("catlast", "marks", "recaps")], mrkrec[, c("trib", "country", "estr", "lake")], median, na.rm=TRUE)
look <- look[, c("lake", "country", "estr", "trib", "catlast", "marks", "recaps")]
write.csv(look, "C:/JVA/Lamprey/Adults/AdultIndex/2014/mr-streams.csv", row.names=FALSE)
selmr <- dat$year > (as.numeric(lastyear)-X+0.5) & !is.na(dat$trapcatch)
tssm2 <- sort(unique(dat$lscode[selmr]))
look2 <- dat[dat$year==lastyear & dat$lscode %in% tssm2, c("lake", "country", "estr", "strname", "trapcatch", "lscode", "strcode", "reach")]
write.csv(look2[order(look2$lake, look2$estr, look2$country, look2$strname), ], "C:/JVA/Lamprey/Adults/AdultIndex/2014/sm-streams.csv", row.names=FALSE)
# then the file MatchStreams.xlsx is manually edited to match up the streams
# bring in STREAM KEY to connect mark/recap data to spawner model data
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/MatchStreams.xlsx")
key <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1, startCol=12, endCol=16)
# use this key to assign lscode (lake stream code) numbers to mark/recap data
mrkrec2 <- merge(mrkrec, key, all.x=TRUE)
# sum up the marks and recaps by lscode
mrkrec3 <- aggregate(mrkrec2[, c("marks", "recaps")], mrkrec2[, c("year", "lscode")], sum)
# then merge the mark/recap data with the spawner model data, by lscode
.Last <- function()
    if(interactive()) try(savehistory("~/.Rhistory"))
cleanup()
q()
.Last <- function()
    if(interactive()) try(savehistory())
q()
x <- 1
y <- 2
cleanup()
q()
?.Last
?history
date
date()
cat("\nSession ended at .................... ", date(), "\n")
cat("\nSession ended at ....................", date(), "\n")
options("R_HISTSIZE")
Sys.getenv("R_TEST")
Sys.getenv("R_HISTSIZE")
Sys.setenv(R_HISTSIZE = 999)
Sys.getenv("R_HISTSIZE")
jvaLast <- function(file=".Rhistory", nlines=10000) {
Sys.setenv(R_HISTSIZE = nlines)
cat("\nSession ended at ...............................", date(), "\n")
if(interactive()) try(savehistory(file))
}
jvaLast()
Sys.getenv("R_HISTSIZE")
.Last <- jvaLast
x <- 33333
cleanup()
q()
library(devtools)
library(roxygen2)
setwd("C:/JVA/GitHub")
install("jvamisc")
setwd("C:/JVA/R/Working Directory")
library(jvamisc)
?jvaLast
#' Shutdown
#'
#' One function with all the commands I typically want run at the end of an R session.
#' @param file Character scalar, file in which to save the commands history relative to current working directory, default ".Rhistory".
#' @param nlines Integer scalar, number of lines that saved to commands history, default 10,000.
#' @export
#' @seealso\code{\link{savehistory}}, \code{\link{Sys.setenv}}.
jvaLast <- function(file=".Rhistory", nlines=10000) {
if(interactive()) {
Sys.setenv(R_HISTSIZE = nlines)
cat("\nSession ended at ...............................", date(), "\n")
try(savehistory(file))
}
}
jvaLast()
library(devtools)
library(roxygen2)
setwd("C:/JVA/GitHub")
install("jvamisc")
setwd("C:/JVA/R/Working Directory")
library(jvamisc)
?jvaLast
q()
cleanup()
.First
.Last
.Last <- jvaLast
.Last
cleanup()
.Last
# C:\JVA\Lamprey\Adults\AdultIndex\2014\2014StreamSummaryTable.r
# summary table for trapped streams in spawner model, based on last YRZ years of data
# current year
YEAR <- 2014
# number of years over which to summarize data
YRZ <- 20
cutyear <- YEAR - YRZ + 0.5
# bring in FWS mark/recap data
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/1984-2014 US MarkRecap Summary.xlsx")
usmr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=2)
names(usmr) <- casefold(names(usmr))
names(usmr)[match(c("lk", "strm", "trib.name", "x.marked", "x.recap"), names(usmr))] <- c("lake", "estr", "trib", "marks", "recaps")
usmr$country <- "US"
usmr2 <- usmr[usmr$year > cutyear, c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
# these assumptions were okayed by Jess Barber 24 Sep 2014
# if the catch is NA, I assume it wasn't trapped
usmr2 <- usmr2[!is.na(usmr2$catch), ]
# if marks or recaps are NA, I assume they were zero
usmr2$marks[is.na(usmr2$marks)] <- 0
usmr2$recaps[is.na(usmr2$recaps)] <- 0
# bring in DFO mark/recap data
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/marked and recaptured DFO.xlsx")
camr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1)
names(camr) <- casefold(names(camr))
names(camr)[match(c("stream_code", "stream_name", "marked", "recaptured", "branch_lentic_name"), names(camr))] <- c("estr", "trib", "marks", "recaps", "branch")
camr$country <- "Canada"
camr$lake <- match(camr$lake_code, Lakeabbs)
camr$catch <- NA
camr2 <- camr[camr$year > cutyear, ]
camr2$trib <- paste(camr2$trib, camr2$branch, sep=" - ")
camr2 <- camr2[, c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
# these assumptions were okayed by Gale Bravener 25 Sep 2014
# if marks or recaps are NA, I assume they were zero
camr2$marks[is.na(camr2$marks)] <- 0
camr2$recaps[is.na(camr2$recaps)] <- 0
# combine FWS and DFO mark/recap data
mrkrec <- rbind(usmr2, camr2)
# create two lists of streams for matching with spawner model data
mrkrec$catlast <- ifelse(mrkrec$year==YEAR, mrkrec$catch, 0)
look <- aggregate(mrkrec[, c("catlast", "marks", "recaps")], mrkrec[, c("trib", "country", "estr", "lake")], median, na.rm=TRUE)
look <- look[, c("lake", "country", "estr", "trib", "catlast", "marks", "recaps")]
write.csv(look, "C:/JVA/Lamprey/Adults/AdultIndex/2014/mr-streams.csv", row.names=FALSE)
# bring in stream-specific data
spawn <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/StreamPEdynamicALLCOLS.csv", as.is=T)
seltr <- spawn$year > cutyear & !is.na(spawn$trapcatch)
trpd <- sort(unique(spawn$lscode[seltr]))
look2 <- spawn[spawn$year==YEAR & spawn$lscode %in% trpd, c("lake", "country", "estr", "strname", "trapcatch", "lscode", "strcode", "reach")]
write.csv(look2[order(look2$lake, look2$estr, look2$country, look2$strname), ], "C:/JVA/Lamprey/Adults/AdultIndex/2014/sm-streams.csv", row.names=FALSE)
# then the file MatchStreams.xlsx is manually edited to match up the streams
# bring in STREAM KEY to connect mark/recap data to spawner model data
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/MatchStreams.xlsx")
key <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1, startCol=12, endCol=16)
# use this key to assign lscode (lake stream code) numbers to mark/recap data
mrkrec2 <- merge(mrkrec, key, all.x=TRUE)
# sum up the marks and recaps by lscode
mrkrec3 <- aggregate(mrkrec2[, c("marks", "recaps")], mrkrec2[, c("year", "lscode")], sum)
# then merge the mark/recap data with the spawner model data, by lscode
# then merge the mark/recap data with the spawner model data, by lscode
selmr <- spawn$year > cutyear & spawn$est.source=="m-r"
mrkd <- sort(unique(spawn$lscode[selmr]))
spawn2 <- spawn[spawn$year > cutyear & spawn$lscode %in% mrkd, ]
dim(spawn)
dim(spawn2)
cutyear
dim(spawn2[spawn2$year==2014, ])
head(spawn)
dput(names(spawn))
head(spawn)
names(mrkrcp3)
head(mrkrec3)
# then merge the mark/recap data with the spawner model data, by lscode
selmr <- spawn$year > cutyear & spawn$est.source=="m-r"
mrkd <- sort(unique(spawn$lscode[selmr]))
spawn2 <- spawn[spawn$year > cutyear & spawn$lscode %in% mrkd, 
c("year", "lscode", "lake", "country", "strcode", "estr", "reach", "strname", "lat", "long", "trapcatch", "Emr", "CVmr", "est.source", 
"PE", "CV", "invcv2", "modest", "combPE", "lo", "hi")]
spawn3 <- merge(spawn2, mrkrec3, all.x=TRUE)
dim(spawn)
dim(spawn2)
dim(spawn3)
head(spawn3)
summary(spawn3[!is.na(spawn3$trapcatch), ])
summary(spawn3[!is.na(spawn3$trapcatch) & spawn3$trapcatch>0, ])
spawn3[!is.na(spawn3$trapcatch) & spawn3$trapcatch>0 & is.na(spawn3$marks), ]
spawn3[!is.na(spawn3$Emr) & is.na(spawn3$marks), ]
look <- spawn3[!is.na(spawn3$Emr) & is.na(spawn3$marks), ]
with(look, table(year, lscode))
dim(with(look, table(year, lscode)))
look <- spawn3[!is.na(spawn3$Emr) & is.na(spawn3$marks), ]
with(look, table(lscode, year))
with(look, table(lscode))
sort(with(look, table(lscode)))
sort(with(look, table(lscode, country)))
with(look, table(lscode, country))
head(camr2)
head(mrkrec2)
with(look, table(lscode, country))
with(mrkrec2, table(lscode, year, country)
)
look <- spawn3[!is.na(spawn3$Emr) & is.na(spawn3$marks), ]
with(look, table(lscode, year))
with(look, table(lscode, country))
with(mrkrec2, table(lscode, year, country)[, , 1]
with(look, table(lscode, country))
with(mrkrec2, table(lscode, year, country))[, , 1]
with(mrkrec2[mrkrec2$lscode %in% unique(look$lscode), ], table(lscode, year, country))[, , 1]
with(look, table(lscode, country))
mrkrec2[mrkrec2$lscode==5.022, ]
key
summary(key)
dim(key)
dim(mrkrec2)
# bring in STREAM KEY to connect mark/recap data to spawner model data
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/MatchStreams.xlsx")
key <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1, startCol=12, endCol=16)
key <- key[!is.na(key$lscode), ]
# use this key to assign lscode (lake stream code) numbers to mark/recap data
mrkrec2 <- merge(mrkrec, key, all.x=TRUE)
dim(mrkrec2)
spawn[spawn$lscode==5.022, ]
spawn2[spawn2$lscode==5.022, ]
names(camr)
camr[substring(camr$trib, 1, 6)=="Humber", ]
head(camr)
table(camr$trib)
camr
# bring in DFO mark/recap data
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/marked and recaptured DFO.xlsx")
camr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1)
camr
dim(camr)
cleanup()
search()
# C:\JVA\Lamprey\Adults\AdultIndex\2014\2014StreamSummaryTable.r
# summary table for trapped streams in spawner model, based on last YRZ years of data
# current year
YEAR <- 2014
# number of years over which to summarize data
YRZ <- 20
cutyear <- YEAR - YRZ + 0.5
# bring in FWS mark/recap data
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/1984-2014 US MarkRecap Summary.xlsx")
usmr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=2)
names(usmr) <- casefold(names(usmr))
names(usmr)[match(c("lk", "strm", "trib.name", "x.marked", "x.recap"), names(usmr))] <- c("lake", "estr", "trib", "marks", "recaps")
usmr$country <- "US"
usmr2 <- usmr[usmr$year > cutyear, c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
# these assumptions were okayed by Jess Barber 24 Sep 2014
# if the catch is NA, I assume it wasn't trapped
usmr2 <- usmr2[!is.na(usmr2$catch), ]
# if marks or recaps are NA, I assume they were zero
usmr2$marks[is.na(usmr2$marks)] <- 0
usmr2$recaps[is.na(usmr2$recaps)] <- 0
# bring in DFO mark/recap data
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/marked and recaptured DFO.xlsx")
camr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1)
names(camr) <- casefold(names(camr))
names(camr)[match(c("stream_code", "stream_name", "marked", "recaptured", "branch_lentic_name"), names(camr))] <- c("estr", "trib", "marks", "recaps", "branch")
camr$country <- "Canada"
camr$lake <- match(camr$lake_code, Lakeabbs)
camr$catch <- NA
camr2 <- camr[camr$year > cutyear, ]
camr2$trib <- paste(camr2$trib, camr2$branch, sep=" - ")
camr2 <- camr2[, c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
# these assumptions were okayed by Gale Bravener 25 Sep 2014
# if marks or recaps are NA, I assume they were zero
camr2$marks[is.na(camr2$marks)] <- 0
camr2$recaps[is.na(camr2$recaps)] <- 0
# combine FWS and DFO mark/recap data
mrkrec <- rbind(usmr2, camr2)
# create two lists of streams for matching with spawner model data
mrkrec$catlast <- ifelse(mrkrec$year==YEAR, mrkrec$catch, 0)
look <- aggregate(mrkrec[, c("catlast", "marks", "recaps")], mrkrec[, c("trib", "country", "estr", "lake")], median, na.rm=TRUE)
look <- look[, c("lake", "country", "estr", "trib", "catlast", "marks", "recaps")]
write.csv(look, "C:/JVA/Lamprey/Adults/AdultIndex/2014/mr-streams.csv", row.names=FALSE)
# bring in stream-specific data
spawn <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/StreamPEdynamicALLCOLS.csv", as.is=T)
seltr <- spawn$year > cutyear & !is.na(spawn$trapcatch)
trpd <- sort(unique(spawn$lscode[seltr]))
look2 <- spawn[spawn$year==YEAR & spawn$lscode %in% trpd, c("lake", "country", "estr", "strname", "trapcatch", "lscode", "strcode", "reach")]
write.csv(look2[order(look2$lake, look2$estr, look2$country, look2$strname), ], "C:/JVA/Lamprey/Adults/AdultIndex/2014/sm-streams.csv", row.names=FALSE)
# then the file MatchStreams.xlsx is manually edited to match up the streams
# bring in STREAM KEY to connect mark/recap data to spawner model data
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/MatchStreams.xlsx")
key <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1, startCol=12, endCol=16)
key <- key[!is.na(key$lscode), ]
# use this key to assign lscode (lake stream code) numbers to mark/recap data
mrkrec2 <- merge(mrkrec, key, all.x=TRUE)
# sum up the marks and recaps by lscode
mrkrec3 <- aggregate(mrkrec2[, c("marks", "recaps")], mrkrec2[, c("year", "lscode")], sum)
# then merge the mark/recap data with the spawner model data, by lscode
selmr <- spawn$year > cutyear & spawn$est.source=="m-r"
mrkd <- sort(unique(spawn$lscode[selmr]))
spawn2 <- spawn[spawn$year > cutyear & spawn$lscode %in% mrkd, 
c("year", "lscode", "lake", "country", "strcode", "estr", "reach", "strname", "lat", "long", "trapcatch", "Emr", "CVmr", "est.source", 
"PE", "CV", "invcv2", "modest", "combPE", "lo", "hi")]
spawn3 <- merge(spawn2, mrkrec3, all.x=TRUE)
# C:\JVA\Lamprey\Adults\AdultIndex\2014\2014StreamSummaryTable.r
# summary table for trapped streams in spawner model, based on last YRZ years of data
# current year
YEAR <- 2014
# number of years over which to summarize data
YRZ <- 20
cutyear <- YEAR - YRZ + 0.5
# bring in FWS mark/recap data
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/1984-2014 US MarkRecap Summary.xlsx")
usmr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=2)
names(usmr) <- casefold(names(usmr))
names(usmr)[match(c("lk", "strm", "trib.name", "x.marked", "x.recap"), names(usmr))] <- c("lake", "estr", "trib", "marks", "recaps")
usmr$country <- "US"
usmr2 <- usmr[usmr$year > cutyear, c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
# these assumptions were okayed by Jess Barber 24 Sep 2014
# if the catch is NA, I assume it wasn't trapped
usmr2 <- usmr2[!is.na(usmr2$catch), ]
# if marks or recaps are NA, I assume they were zero
usmr2$marks[is.na(usmr2$marks)] <- 0
usmr2$recaps[is.na(usmr2$recaps)] <- 0
# bring in DFO mark/recap data
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/marked and recaptured DFO.xlsx")
camr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1)
head(camr)
# bring in DFO mark/recap data
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/marked and recaptured DFO.xlsx")
camr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1)
head(camr)
names(camr) <- casefold(names(camr))
names(camr)[match(c("stream_code", "stream_name", "marked", "recaptured", "branch_lentic_name"), names(camr))] <- c("estr", "trib", "marks", "recaps", "branch")
camr$country <- "Canada"
camr$lake <- match(camr$lake_code, Lakeabbs)
camr$catch <- NA
camr2 <- camr[camr$year > cutyear, ]
camr2$trib <- paste(camr2$trib, camr2$branch, sep=" - ")
camr2 <- camr2[, c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
# these assumptions were okayed by Gale Bravener 25 Sep 2014
# if marks or recaps are NA, I assume they were zero
camr2$marks[is.na(camr2$marks)] <- 0
camr2$recaps[is.na(camr2$recaps)] <- 0
# combine FWS and DFO mark/recap data
mrkrec <- rbind(usmr2, camr2)
# create two lists of streams for matching with spawner model data
mrkrec$catlast <- ifelse(mrkrec$year==YEAR, mrkrec$catch, 0)
look <- aggregate(mrkrec[, c("catlast", "marks", "recaps")], mrkrec[, c("trib", "country", "estr", "lake")], median, na.rm=TRUE)
look <- look[, c("lake", "country", "estr", "trib", "catlast", "marks", "recaps")]
write.csv(look, "C:/JVA/Lamprey/Adults/AdultIndex/2014/mr-streams.csv", row.names=FALSE)
# bring in stream-specific data
spawn <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/StreamPEdynamicALLCOLS.csv", as.is=T)
seltr <- spawn$year > cutyear & !is.na(spawn$trapcatch)
trpd <- sort(unique(spawn$lscode[seltr]))
look2 <- spawn[spawn$year==YEAR & spawn$lscode %in% trpd, c("lake", "country", "estr", "strname", "trapcatch", "lscode", "strcode", "reach")]
write.csv(look2[order(look2$lake, look2$estr, look2$country, look2$strname), ], "C:/JVA/Lamprey/Adults/AdultIndex/2014/sm-streams.csv", row.names=FALSE)
# then the file MatchStreams.xlsx is manually edited to match up the streams
# bring in STREAM KEY to connect mark/recap data to spawner model data
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/MatchStreams.xlsx")
key <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1, startCol=12, endCol=16)
key <- key[!is.na(key$lscode), ]
# use this key to assign lscode (lake stream code) numbers to mark/recap data
mrkrec2 <- merge(mrkrec, key, all.x=TRUE)
# sum up the marks and recaps by lscode
mrkrec3 <- aggregate(mrkrec2[, c("marks", "recaps")], mrkrec2[, c("year", "lscode")], sum)
# then merge the mark/recap data with the spawner model data, by lscode
selmr <- spawn$year > cutyear & spawn$est.source=="m-r"
mrkd <- sort(unique(spawn$lscode[selmr]))
spawn2 <- spawn[spawn$year > cutyear & spawn$lscode %in% mrkd, 
c("year", "lscode", "lake", "country", "strcode", "estr", "reach", "strname", "lat", "long", "trapcatch", "Emr", "CVmr", "est.source", 
"PE", "CV", "invcv2", "modest", "combPE", "lo", "hi")]
spawn3 <- merge(spawn2, mrkrec3, all.x=TRUE)
look <- spawn3[!is.na(spawn3$Emr) & is.na(spawn3$marks), ]
dim(look)
look
with(look, table(lscode, year))
with(look, table(lscode, country))
camr
dim(camr)
dim(usmr)
dim(mrkrec)
dim(mrkrec2)
dim(mrkrec3)
camr[substring(camr, 1, 6)=="Humber", ]
camr$
camr[substring(camr$trib, 1, 6)=="Humber", ]
camr[substring(camr$trib, 1, 6)=="Humber", ]
camr2[substring(camr2$trib, 1, 6)=="Humber", ]
mrkrec[substring(mrkrec$trib, 1, 6)=="Humber", ]
camr[substring(camr$trib, 1, 6)=="Humber", ]
camr2[substring(camr2$trib, 1, 6)=="Humber", ]
mrkrec[substring(mrkrec$trib, 1, 6)=="Humber", ]
mrkrec2[substring(mrkrec2$trib, 1, 6)=="Humber", ]
mrkrec3[substring(mrkrec3$trib, 1, 6)=="Humber", ]
head(mrkrec3)
unique(camr$trib)
unique(camr$branch)
is.na(unique(camr$branch))
# C:\JVA\Lamprey\Adults\AdultIndex\2014\2014StreamSummaryTable.r
# summary table for trapped streams in spawner model, based on last YRZ years of data
# current year
YEAR <- 2014
# number of years over which to summarize data
YRZ <- 20
cutyear <- YEAR - YRZ + 0.5
# bring in FWS mark/recap data
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/1984-2014 US MarkRecap Summary.xlsx")
usmr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=2)
names(usmr) <- casefold(names(usmr))
names(usmr)[match(c("lk", "strm", "trib.name", "x.marked", "x.recap"), names(usmr))] <- c("lake", "estr", "trib", "marks", "recaps")
usmr$country <- "US"
usmr2 <- usmr[usmr$year > cutyear, c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
# these assumptions were okayed by Jess Barber 24 Sep 2014
# if the catch is NA, I assume it wasn't trapped
usmr2 <- usmr2[!is.na(usmr2$catch), ]
# if marks or recaps are NA, I assume they were zero
usmr2$marks[is.na(usmr2$marks)] <- 0
usmr2$recaps[is.na(usmr2$recaps)] <- 0
# bring in DFO mark/recap data
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/marked and recaptured DFO.xlsx")
camr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1)
names(camr) <- casefold(names(camr))
names(camr)[match(c("stream_code", "stream_name", "marked", "recaptured", "branch_lentic_name"), names(camr))] <- c("estr", "trib", "marks", "recaps", "branch")
camr$country <- "Canada"
camr$lake <- match(camr$lake_code, Lakeabbs)
camr$catch <- NA
camr2 <- camr[camr$year > cutyear, ]
camr2$trib <- ifelse(is.na(camr2$branch, camr2$trib, paste(camr2$trib, camr2$branch, sep=" - ")
camr2 <- camr2[, c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
# these assumptions were okayed by Gale Bravener 25 Sep 2014
# if marks or recaps are NA, I assume they were zero
camr2$marks[is.na(camr2$marks)] <- 0
camr2$recaps[is.na(camr2$recaps)] <- 0
# combine FWS and DFO mark/recap data
mrkrec <- rbind(usmr2, camr2)
# create two lists of streams for matching with spawner model data
mrkrec$catlast <- ifelse(mrkrec$year==YEAR, mrkrec$catch, 0)
look <- aggregate(mrkrec[, c("catlast", "marks", "recaps")], mrkrec[, c("trib", "country", "estr", "lake")], median, na.rm=TRUE)
look <- look[, c("lake", "country", "estr", "trib", "catlast", "marks", "recaps")]
write.csv(look, "C:/JVA/Lamprey/Adults/AdultIndex/2014/mr-streams.csv", row.names=FALSE)
# bring in stream-specific data
spawn <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/StreamPEdynamicALLCOLS.csv", as.is=T)
seltr <- spawn$year > cutyear & !is.na(spawn$trapcatch)
trpd <- sort(unique(spawn$lscode[seltr]))
look2 <- spawn[spawn$year==YEAR & spawn$lscode %in% trpd, c("lake", "country", "estr", "strname", "trapcatch", "lscode", "strcode", "reach")]
write.csv(look2[order(look2$lake, look2$estr, look2$country, look2$strname), ], "C:/JVA/Lamprey/Adults/AdultIndex/2014/sm-streams.csv", row.names=FALSE)
# then the file MatchStreams.xlsx is manually edited to match up the streams
# bring in STREAM KEY to connect mark/recap data to spawner model data
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/MatchStreams.xlsx")
key <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1, startCol=12, endCol=16)
key <- key[!is.na(key$lscode), ]
# use this key to assign lscode (lake stream code) numbers to mark/recap data
mrkrec2 <- merge(mrkrec, key, all.x=TRUE)
# sum up the marks and recaps by lscode
mrkrec3 <- aggregate(mrkrec2[, c("marks", "recaps")], mrkrec2[, c("year", "lscode")], sum)
# then merge the mark/recap data with the spawner model data, by lscode
selmr <- spawn$year > cutyear & spawn$est.source=="m-r"
mrkd <- sort(unique(spawn$lscode[selmr]))
spawn2 <- spawn[spawn$year > cutyear & spawn$lscode %in% mrkd, 
c("year", "lscode", "lake", "country", "strcode", "estr", "reach", "strname", "lat", "long", "trapcatch", "Emr", "CVmr", "est.source", 
"PE", "CV", "invcv2", "modest", "combPE", "lo", "hi")]
spawn3 <- merge(spawn2, mrkrec3, all.x=TRUE)
look <- spawn3[!is.na(spawn3$Emr) & is.na(spawn3$marks), ]
with(look, table(lscode, year))
with(look, table(lscode, country))
# C:\JVA\Lamprey\Adults\AdultIndex\2014\2014StreamSummaryTable.r
# summary table for trapped streams in spawner model, based on last YRZ years of data
# current year
YEAR <- 2014
# number of years over which to summarize data
YRZ <- 20
cutyear <- YEAR - YRZ + 0.5
# bring in FWS mark/recap data
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/1984-2014 US MarkRecap Summary.xlsx")
usmr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=2)
names(usmr) <- casefold(names(usmr))
names(usmr)[match(c("lk", "strm", "trib.name", "x.marked", "x.recap"), names(usmr))] <- c("lake", "estr", "trib", "marks", "recaps")
usmr$country <- "US"
usmr2 <- usmr[usmr$year > cutyear, c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
# these assumptions were okayed by Jess Barber 24 Sep 2014
# if the catch is NA, I assume it wasn't trapped
usmr2 <- usmr2[!is.na(usmr2$catch), ]
# if marks or recaps are NA, I assume they were zero
usmr2$marks[is.na(usmr2$marks)] <- 0
usmr2$recaps[is.na(usmr2$recaps)] <- 0
# bring in DFO mark/recap data
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/marked and recaptured DFO.xlsx")
camr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1)
names(camr) <- casefold(names(camr))
names(camr)[match(c("stream_code", "stream_name", "marked", "recaptured", "branch_lentic_name"), names(camr))] <- c("estr", "trib", "marks", "recaps", "branch")
camr$country <- "Canada"
camr$lake <- match(camr$lake_code, Lakeabbs)
camr$catch <- NA
camr2 <- camr[camr$year > cutyear, ]
camr2$trib <- ifelse(is.na(camr2$branch), camr2$trib, paste(camr2$trib, camr2$branch, sep=" - "))
camr2 <- camr2[, c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
# these assumptions were okayed by Gale Bravener 25 Sep 2014
# if marks or recaps are NA, I assume they were zero
camr2$marks[is.na(camr2$marks)] <- 0
camr2$recaps[is.na(camr2$recaps)] <- 0
# combine FWS and DFO mark/recap data
mrkrec <- rbind(usmr2, camr2)
# create two lists of streams for matching with spawner model data
mrkrec$catlast <- ifelse(mrkrec$year==YEAR, mrkrec$catch, 0)
look <- aggregate(mrkrec[, c("catlast", "marks", "recaps")], mrkrec[, c("trib", "country", "estr", "lake")], median, na.rm=TRUE)
look <- look[, c("lake", "country", "estr", "trib", "catlast", "marks", "recaps")]
write.csv(look, "C:/JVA/Lamprey/Adults/AdultIndex/2014/mr-streams.csv", row.names=FALSE)
# bring in stream-specific data
spawn <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/StreamPEdynamicALLCOLS.csv", as.is=T)
seltr <- spawn$year > cutyear & !is.na(spawn$trapcatch)
trpd <- sort(unique(spawn$lscode[seltr]))
look2 <- spawn[spawn$year==YEAR & spawn$lscode %in% trpd, c("lake", "country", "estr", "strname", "trapcatch", "lscode", "strcode", "reach")]
write.csv(look2[order(look2$lake, look2$estr, look2$country, look2$strname), ], "C:/JVA/Lamprey/Adults/AdultIndex/2014/sm-streams.csv", row.names=FALSE)
# then the file MatchStreams.xlsx is manually edited to match up the streams
# bring in STREAM KEY to connect mark/recap data to spawner model data
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/MatchStreams.xlsx")
key <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1, startCol=12, endCol=16)
key <- key[!is.na(key$lscode), ]
# use this key to assign lscode (lake stream code) numbers to mark/recap data
mrkrec2 <- merge(mrkrec, key, all.x=TRUE)
# sum up the marks and recaps by lscode
mrkrec3 <- aggregate(mrkrec2[, c("marks", "recaps")], mrkrec2[, c("year", "lscode")], sum)
# then merge the mark/recap data with the spawner model data, by lscode
selmr <- spawn$year > cutyear & spawn$est.source=="m-r"
mrkd <- sort(unique(spawn$lscode[selmr]))
spawn2 <- spawn[spawn$year > cutyear & spawn$lscode %in% mrkd, 
c("year", "lscode", "lake", "country", "strcode", "estr", "reach", "strname", "lat", "long", "trapcatch", "Emr", "CVmr", "est.source", 
"PE", "CV", "invcv2", "modest", "combPE", "lo", "hi")]
spawn3 <- merge(spawn2, mrkrec3, all.x=TRUE)
look <- spawn3[!is.na(spawn3$Emr) & is.na(spawn3$marks), ]
with(look, table(lscode, year))
with(look, table(lscode, country))
dim(look)
look
head(camr)
table(camr$year)
camr[camr$year==2014, ]
# summarize the data
spawn3$trapeff <- spawn3$trapcatch/spawn3$Emr
smry <- aggregate(spawn3[, c("Emr", "trapcatch", "trapeff", "marks", "recaps")], spawn3[, c("lscode", "lake", "country", "strcode", "estr", "strname")], median)
dim(smry)
smry
smry <- aggregate(spawn3[, c("Emr", "trapcatch", "trapeff", "marks", "recaps")], spawn3[, c("lscode", "lake", "country", "strcode", "estr", "strname")], 
median, na.rm=TRUE)
smry
smry <- aggregate(spawn3[, c("Emr", "trapcatch", "trapeff", "marks", "recaps")], spawn3[, c("lake", "country", "strcode", "estr", "strname", "lscode")], 
median, na.rm=TRUE)
smry$nyr <- tapply(!is.na(spawn3$Emr), spawn3$lscode, sum)
smry
smry <- aggregate(spawn3[, c("Emr", "trapcatch", "trapeff", "marks", "recaps")], spawn3[, c("lake", "country", "strcode", "estr", "strname", "lscode")], 
median, na.rm=TRUE)
smry$nyr <- tapply(!is.na(spawn3$Emr), spawn3$lscode, sum)
smry$wpyr <- tapply((spawn3$year-(YEAR-YRZ))[!is.na(spawn3$Emr)], spawn3$lscode[!is.na(spawn3$Emr)], sum)/((YRZ+1)*(YRZ/2))
smry
# identify the index streams
index.streams <- list(
Sup = c(1, 2, 9, 29, 31, 32, 62),
Mic = c(5, 6, 15, 24, 26, 35),
Hur = c(10, 16, 27, 32, 999, 38),
Eri = c(1, 2, 3, 7, 9),
Ont = c(5, 9, 22, 23, 36)
)
index.streams <- lapply(1:5, function(i) i + index.streams[[i]]/1000)
index.streams
smry$type <- c("", "Index")[smry$lscode %in% unlist(index.streams) + 1]
# summarize the data
spawn3$trapeff <- spawn3$trapcatch/spawn3$Emr
smry <- aggregate(spawn3[, c("Emr", "trapcatch", "trapeff", "marks", "recaps")], spawn3[, c("lake", "country", "strcode", "estr", "strname", "lscode")], 
median, na.rm=TRUE)
# number of years, and weighted proportion of years (giving more weight to recent years)
smry$nyr <- tapply(!is.na(spawn3$Emr), spawn3$lscode, sum)
smry$wpyr <- tapply((spawn3$year-(YEAR-YRZ))[!is.na(spawn3$Emr)], spawn3$lscode[!is.na(spawn3$Emr)], sum)/((YRZ+1)*(YRZ/2))
# identify the index streams
index.streams <- list(
Sup = c(1, 2, 9, 29, 31, 32, 62),
Mic = c(5, 6, 15, 24, 26, 35),
Hur = c(10, 16, 27, 32, 999, 38),
Eri = c(1, 2, 3, 7, 9),
Ont = c(5, 9, 22, 23, 36)
)
index.streams <- lapply(1:5, function(i) i + index.streams[[i]]/1000)
smry$type <- c("", "Index")[smry$lscode %in% unlist(index.streams) + 1]
rankl <- rank(rank(-smry$wpyr) + rank(-smry$mPE))
smry$rank <- unlist(tapply(rankl, smry$lake, rank))
ord <- order(smry$lake, -(rank(smry$mPE) + rank(smry$nyr)))
ord <- order(smry$lake, -smry$mPE, -smry$wpyr)
ord <- order(smry$lake, smry$rank)
smry[ord, c("lake", "country", "lscode", "strname", "type", "rank", "nyr", "wpyr", "mPE", "mtc", "mef")]
# summarize the data
spawn3$trapeff <- spawn3$trapcatch/spawn3$Emr
smry <- aggregate(spawn3[, c("Emr", "trapcatch", "trapeff", "marks", "recaps")], spawn3[, c("lake", "country", "strcode", "estr", "strname", "lscode")], 
median, na.rm=TRUE)
# number of years, and weighted proportion of years (giving more weight to recent years)
smry$nyr <- tapply(!is.na(spawn3$Emr), spawn3$lscode, sum)
smry$wpyr <- tapply((spawn3$year-(YEAR-YRZ))[!is.na(spawn3$Emr)], spawn3$lscode[!is.na(spawn3$Emr)], sum)/((YRZ+1)*(YRZ/2))
# identify the index streams
index.streams <- list(
Sup = c(1, 2, 9, 29, 31, 32, 62),
Mic = c(5, 6, 15, 24, 26, 35),
Hur = c(10, 16, 27, 32, 999, 38),
Eri = c(1, 2, 3, 7, 9),
Ont = c(5, 9, 22, 23, 36)
)
index.streams <- lapply(1:5, function(i) i + index.streams[[i]]/1000)
smry$type <- c("", "Index")[smry$lscode %in% unlist(index.streams) + 1]
rankl <- rank(rank(-smry$wpyr) + rank(-smry$Emr))
smry$rank <- unlist(tapply(rankl, smry$lake, rank))
ord <- order(smry$lake, -(rank(smry$Emr) + rank(smry$nyr)))
ord <- order(smry$lake, -smry$Emr, -smry$wpyr)
ord <- order(smry$lake, smry$rank)
smry[ord, c("lake", "country", "lscode", "strname", "type", "rank", "nyr", "wpyr", "Emr", "mtc", "mef")]
names(smry)
smry[ord, c("lake", "country", "lscode", "strname", "type", "rank", "nyr", "wpyr", "Emr", "trapcatch", "trapeff", "marks", "recaps")]
cleanup()
# C:\JVA\Lamprey\Adults\AdultIndex\2014\2014StreamSummaryTable.r
# summary table for trapped streams in spawner model, based on last YRZ years of data
# current year
YEAR <- 2014
# number of years over which to summarize data
YRZ <- 20
cutyear <- YEAR - YRZ + 0.5
# bring in FWS mark/recap data
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/1984-2014 US MarkRecap Summary.xlsx")
usmr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=2)
names(usmr) <- casefold(names(usmr))
names(usmr)[match(c("lk", "strm", "trib.name", "x.marked", "x.recap"), names(usmr))] <- c("lake", "estr", "trib", "marks", "recaps")
usmr$country <- "US"
usmr2 <- usmr[usmr$year > cutyear, c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
# these assumptions were okayed by Jess Barber 24 Sep 2014
# if the catch is NA, I assume it wasn't trapped
usmr2 <- usmr2[!is.na(usmr2$catch), ]
# if marks or recaps are NA, I assume they were zero
usmr2$marks[is.na(usmr2$marks)] <- 0
usmr2$recaps[is.na(usmr2$recaps)] <- 0
# bring in DFO mark/recap data
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/marked and recaptured DFO.xlsx")
camr <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1)
names(camr) <- casefold(names(camr))
names(camr)[match(c("stream_code", "stream_name", "marked", "recaptured", "branch_lentic_name"), names(camr))] <- c("estr", "trib", "marks", "recaps", "branch")
camr$country <- "Canada"
camr$lake <- match(camr$lake_code, Lakeabbs)
camr$catch <- NA
camr2 <- camr[camr$year > cutyear, ]
camr2$trib <- ifelse(is.na(camr2$branch), camr2$trib, paste(camr2$trib, camr2$branch, sep=" - "))
camr2 <- camr2[, c("lake", "country", "estr", "trib", "year", "catch", "marks", "recaps")]
# these assumptions were okayed by Gale Bravener 25 Sep 2014
# if marks or recaps are NA, I assume they were zero
camr2$marks[is.na(camr2$marks)] <- 0
camr2$recaps[is.na(camr2$recaps)] <- 0
# combine FWS and DFO mark/recap data
mrkrec <- rbind(usmr2, camr2)
# create two lists of streams for matching with spawner model data
mrkrec$catlast <- ifelse(mrkrec$year==YEAR, mrkrec$catch, 0)
look <- aggregate(mrkrec[, c("catlast", "marks", "recaps")], mrkrec[, c("trib", "country", "estr", "lake")], median, na.rm=TRUE)
look <- look[, c("lake", "country", "estr", "trib", "catlast", "marks", "recaps")]
write.csv(look, "C:/JVA/Lamprey/Adults/AdultIndex/2014/mr-streams.csv", row.names=FALSE)
# bring in stream-specific data
spawn <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/StreamPEdynamicALLCOLS.csv", as.is=T)
seltr <- spawn$year > cutyear & !is.na(spawn$trapcatch)
trpd <- sort(unique(spawn$lscode[seltr]))
look2 <- spawn[spawn$year==YEAR & spawn$lscode %in% trpd, c("lake", "country", "estr", "strname", "trapcatch", "lscode", "strcode", "reach")]
write.csv(look2[order(look2$lake, look2$estr, look2$country, look2$strname), ], "C:/JVA/Lamprey/Adults/AdultIndex/2014/sm-streams.csv", row.names=FALSE)
# then the file MatchStreams.xlsx is manually edited to match up the streams
# bring in STREAM KEY to connect mark/recap data to spawner model data
wb <- loadWorkbook("C:/JVA/Lamprey/Adults/AdultIndex/2014/MatchStreams.xlsx")
key <- readWorksheet(wb, sheet=getSheets(wb)[1], startRow=1, startCol=12, endCol=16)
key <- key[!is.na(key$lscode), ]
# use this key to assign lscode (lake stream code) numbers to mark/recap data
mrkrec2 <- merge(mrkrec, key, all.x=TRUE)
# sum up the marks and recaps by lscode
mrkrec3 <- aggregate(mrkrec2[, c("marks", "recaps")], mrkrec2[, c("year", "lscode")], sum)
# then merge the mark/recap data with the spawner model data, by lscode
selmr <- spawn$year > cutyear & spawn$est.source=="m-r"
mrkd <- sort(unique(spawn$lscode[selmr]))
spawn2 <- spawn[spawn$year > cutyear & spawn$lscode %in% mrkd, 
c("year", "lscode", "lake", "country", "strcode", "estr", "reach", "strname", "lat", "long", "trapcatch", "Emr", "CVmr", "est.source", 
"PE", "CV", "invcv2", "modest", "combPE", "lo", "hi")]
spawn3 <- merge(spawn2, mrkrec3, all.x=TRUE)
# streams with mark-recap estimates but no mark/recap data available
look <- spawn3[!is.na(spawn3$Emr) & is.na(spawn3$marks), ]
# summarize the data
spawn3$trapeff <- spawn3$trapcatch/spawn3$Emr
smry <- aggregate(spawn3[, c("Emr", "trapcatch", "trapeff", "marks", "recaps")], spawn3[, c("lake", "country", "strcode", "estr", "strname", "lscode")], 
median, na.rm=TRUE)
# number of years, and weighted proportion of years (giving more weight to recent years)
smry$nyr <- tapply(!is.na(spawn3$Emr), spawn3$lscode, sum)
smry$wpyr <- tapply((spawn3$year-(YEAR-YRZ))[!is.na(spawn3$Emr)], spawn3$lscode[!is.na(spawn3$Emr)], sum)/((YRZ+1)*(YRZ/2))
# identify the index streams
index.streams <- list(
Sup = c(1, 2, 9, 29, 31, 32, 62),
Mic = c(5, 6, 15, 24, 26, 35),
Hur = c(10, 16, 27, 32, 999, 38),
Eri = c(1, 2, 3, 7, 9),
Ont = c(5, 9, 22, 23, 36)
)
index.streams <- lapply(1:5, function(i) i + index.streams[[i]]/1000)
smry$type <- c("", "Index")[smry$lscode %in% unlist(index.streams) + 1]
rankl <- rank(rank(-smry$wpyr) + rank(-smry$Emr))
smry$rank <- unlist(tapply(rankl, smry$lake, rank))
ord <- order(smry$lake, -(rank(smry$Emr) + rank(smry$nyr)))
ord <- order(smry$lake, -smry$Emr, -smry$wpyr)
ord <- order(smry$lake, smry$rank)
smry[ord, c("lake", "country", "lscode", "strname", "type", "rank", "nyr", "wpyr", "Emr", "trapcatch", "trapeff", "marks", "recaps")]
lls()
ord <- order(smry$lake, -(rank(smry$Emr) + rank(smry$nyr)))
ord <- order(smry$lake, -smry$Emr, -smry$wpyr)
ord <- order(smry$lake, smry$rank)
smry2 <- smry[ord, c("lake", "country", "lscode", "strname", "type", "rank", "nyr", "wpyr", "Emr", "trapcatch", "trapeff", "marks", "recaps")]
write(smry2, "C:/JVA/Lamprey/Adults/AdultIndex/2014/StreamSummaryTable.xlsx", row.names=FALSE)
write.csv(smry2, "C:/JVA/Lamprey/Adults/AdultIndex/2014/StreamSummaryTable.csv", row.names=FALSE)
attach(smry2)
# removal of adults currently
tc <- tapply(trapcatch, list(lake, type), sum)
m <- tapply(marks, list(lake, type), sum)
r <- tapply(recaps, list(lake, type), sum)
tc
m
r
tc[
# all totals
tca <- tapply(trapcatch, lake, sum)
ma <- tapply(marks, lake, sum)
ra <- tapply(recaps, lake, sum)
# index totals
tci <- tapply(trapcatch, list(lake, type), sum)[, 2]
mi <- tapply(marks, list(lake, type), sum)[, 2]
ri <- tapply(recaps, list(lake, type), sum)[, 2]
# removal of adults 
# currently
tca - ma + r
# index and continue trapping others
tca - mi + ri
# index only
tci - mi + ri
# all totals
tca <- tapply(trapcatch, lake, sum)
ma <- tapply(marks, lake, sum)
ra <- tapply(recaps, lake, sum)
# index totals
tci <- tapply(trapcatch, list(lake, type), sum)[, 2]
mi <- tapply(marks, list(lake, type), sum)[, 2]
ri <- tapply(recaps, list(lake, type), sum)[, 2]
# removal of adults 
# currently
tca - ma + r
# index and continue trapping others
tca - mi + ri
# index only
tci - mi + ri
tca
ma
r
# all totals
tca <- tapply(trapcatch, lake, sum)
ma <- tapply(marks, lake, sum)
ra <- tapply(recaps, lake, sum)
# index totals
tci <- tapply(trapcatch, list(lake, type), sum)[, 2]
mi <- tapply(marks, list(lake, type), sum)[, 2]
ri <- tapply(recaps, list(lake, type), sum)[, 2]
# removal of adults 
# currently
tca - ma + ra
# index and continue trapping others
tca - mi + ri
# index only
tci - mi + ri
cbind(cur, indp, indp.=(indp - cur)/cur, ind, ind.=(ind - cur)/cur)
# removal of adults 
# currently
cur <- tca - ma + ra
# index and continue trapping others
indp <- tca - mi + ri
# index only
ind <- tci - mi + ri
cbind(cur, indp, indp.=(indp - cur)/cur, ind, ind.=(ind - cur)/cur)
cutyear
cleanup()
q()
# C:\JVA\Lamprey\Adults\AdultIndex\2014\AdultIndex v2.r
{ # functions
# the following seven plot.table related function are from the Systmatic Investor Toolbox
# load Systematic Investor Toolbox
# require(RCurl)
# sit = getURLContent("https://github.com/systematicinvestor/SIT/raw/master/sit.gz", binary=TRUE, followlocation=TRUE, ssl.verifypeer=FALSE)
# con = gzcon(rawConnection(sit, "rb"))
# source(con)
# close(con)
draw.cell <- function(title, r, c, text.cex = 1, bg.col = 'white', frame.cell = T) {
if(!frame.cell) bcol = bg.col else bcol = 'black'
rect((2*(c - 1) + .5), -(r - .5), (2*c + .5), -(r + .5), col = bg.col, border = bcol)
if( c == 1) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else if( r == 1 ) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else {
text((2*c + .5), -r, title, adj = 1, cex = text.cex)
}
}
plot.table.helper.auto.adjust.cex <- function(temp.table, keep.all.same.cex = FALSE) {
nr = nrow(temp.table)
nc = ncol(temp.table)
all.xrange = diff(par()$usr[1:2]) / nc
xrange = matrix( strwidth(paste('  ', temp.table), units = 'user', cex = 1), nc = nc)
all.yrange = diff(par()$usr[3:4]) / nr
yrange = matrix( 5/3 * strheight(temp.table, units = 'user', cex = 1), nc = nc)
plot.matrix.cex = pmin( round(all.yrange / yrange, 2) , round(all.xrange / xrange, 2) )
header.col.cex = min(plot.matrix.cex[1,-1])
header.row.cex = min(plot.matrix.cex[-1,1])
title.cex = plot.matrix.cex[1, 1]
data.cex = min(plot.matrix.cex[-1, -1])
if ( keep.all.same.cex ) {
plot.matrix.cex[] = min(plot.matrix.cex)
} else {
plot.matrix.cex[1,-1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,-1]= min(c(header.col.cex, header.row.cex, data.cex))
plot.matrix.cex[1,1]= min(c(header.col.cex, header.row.cex, data.cex, title.cex))
plot.matrix.cex[1,-1] = min(c(header.col.cex))
plot.matrix.cex[-1,1] = min(c(header.row.cex))
plot.matrix.cex[-1,-1]= min(c(data.cex))
plot.matrix.cex[1,1]= min(c(title.cex))
}
return(plot.matrix.cex)
}
make.table <- function(nr, nc) {
savepar = par(mar = rep(1, 4))
plot(c(0.5, nc*2 + 0.5), c(-0.5, -(nr + 0.5)), xaxs = 'i', yaxs = 'i',
type = 'n', xlab = '', ylab = '', axes = FALSE)
savepar
}
trim <- function(s) {
s = sub(pattern = '^ +', replacement = '', x = s)
s = sub(pattern = ' +$', replacement = '', x = s)
return(s)
}
plot.table.param <- function(plot.matrix, smain = '', plot.matrix.cex, plot.matrix_bg.col, frame.cell = T, keep.all.same.cex = FALSE) {
n = nrow(plot.matrix)
pages = unique(c(seq(0, n, by = 120), n))
for(p in 1:(length(pages)-1)) {
rindex = (pages[p]+1) : pages[p+1]
temp.table = matrix('', nr = length(rindex)+1, nc = ncol(plot.matrix)+1)
temp.table[-1, -1] = plot.matrix[rindex,]
temp.table[1, -1] = colnames(plot.matrix)
temp.table[-1, 1] = rownames(plot.matrix)[rindex]
temp.table[1, 1] = smain
nr = nrow(temp.table)
nc = ncol(temp.table)
par(mar = c(0, 0, 0, 0), cex = 0.5)
oldpar = make.table(nr, nc)
text.cex = plot.matrix.cex[c(1, 1 + rindex), ]
text.cex = plot.table.helper.auto.adjust.cex(temp.table, keep.all.same.cex)
bg.col = plot.matrix_bg.col[c(1, 1 + rindex), ]
for(r in 1:nr) {
for(c in 1:nc) {
draw.cell( paste('', temp.table[r,c], '', sep=' '), r, c,
text.cex = text.cex[r,c], bg.col = bg.col[r,c], frame.cell = frame.cell)
}}
}
}
plot.table <- function(plot.matrix, smain="", text.cex=1, frame.cell=TRUE, highlight=FALSE, colorbar=FALSE, keep_all.same.cex=FALSE) {
if( is.null(rownames(plot.matrix)) & is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
if( ncol(temp.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[-1, -1, drop = FALSE]
colnames(plot.matrix) = temp.matrix[1, -1]
rownames(plot.matrix) = temp.matrix[-1, 1]
smain = temp.matrix[1, 1]
} else if( is.null(rownames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( ncol(plot.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[, -1, drop = FALSE]
colnames(plot.matrix) = colnames(temp.matrix)[-1]
rownames(plot.matrix) = temp.matrix[,1]
smain = colnames(temp.matrix)[1]
} else if( is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
plot.matrix = temp.matrix[-1, , drop = FALSE]
rownames(plot.matrix) = rownames(temp.matrix)[-1]
colnames(plot.matrix) = temp.matrix[1, ]
smain = rownames(temp.matrix)[1]
}
plot.matrix[which(trim(plot.matrix) == "NA")] = ""
plot.matrix[which(trim(plot.matrix) == "NA%")] = ""
plot.matrix[which(is.na(plot.matrix))] = ""
nr = nrow(plot.matrix) + 1
nc = ncol(plot.matrix) + 1
is_highlight = TRUE
if(is.logical(highlight)) {
is_highlight = highlight
if(highlight) highlight = plot.table.helper.color(plot.matrix)
}
if(!is_highlight) {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[seq(1, nr, 2), ] = "yellow"
plot.matrix_bg.col[1,] = "gray";
plot.table.param( plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
} else {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[1,] = "gray"
plot.matrix_bg.col[2:nr,2:nc] = highlight
plot.table.param(plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
}
}
plot.table.helper.color <- function (temp) {
temp = matrix(as.double(gsub("[%,$]", "", temp)), nrow(temp), ncol(temp))
highlight = as.vector(temp)
cols = rep(NA, length(highlight))
ncols = length(highlight[!is.na(highlight)])
cols[1:ncols] = rev(rainbow(ncols, start=0.5/6, end=3.5/6))
o = sort.list(highlight, na.last = TRUE, decreasing = FALSE)
o1 = sort.list(o, na.last = TRUE, decreasing = FALSE)
highlight = matrix(cols[o1], nrow = nrow(temp))
highlight[is.na(temp)] = NA
return(highlight)
}
ModelEst <- function(fit, df) {
# derive regression estimates from log(y) fit
mse <- rev(as.matrix(summary(fit)[[1]])[, "Mean Sq"])[1]
plpe <- predict(fit, newdata=df, se.fit=T)
m <- plpe$fit
v <- plpe$se.fit^2 + mse
exp(m + v/2)
}
myrange <- function(x) {
if(all(is.na(x))) r <- c(NA, NA) else r <- range(x, na.rm=TRUE)
return(r)
}
jackindex <- function(m) {
# m is a matrix of numbers (stream PEs) with observations (years) as rows and individuals (streams) as columns
if(any(is.na(m))) stop("The input matrix may not have any missing values.")
# calculate the index as the sum of the columns for each row
rowsum <- apply(m, 1, sum)
# calculate the mean of the index
avgind <- mean(rowsum)
# recalculate the index, leaving out one individual at a time
loo <- apply(m, 2, function(column) (rowsum - column))
# rescale the loo index, relative to mean
looscaled <- apply(loo, 2, function(x) x/mean(x))
# convert to original scale
looscaled2 <- looscaled * avgind
# calculate range
ranges <- t(apply(looscaled2, 1, range))
cbind(index=rowsum, lo=ranges[, 1], hi=ranges[, 2])
}
# selstreams <- index.streams[[1]] 
# allstreamdf <- dat
# alllakedf <- lk 
# min.nmr=2 
# show=FALSE
index.est <- function(selstreams, allstreamdf, alllakedf, min.nmr=2, show=FALSE) {
# INDEX OF ADULT SEA LAMPREY ABUNDANCE
### INPUTS
# selstreams = vector of stream ids, e.g., 1.064 (lake + strcode/1000)
# allstreamdf = data frame of mark-recap estimates for all streams, with vars:  year lake ls Emr CVmr
# alllakedf = data frame of lake-wide PEs from Mullett et al. (2003) spawner model with vars:  lake year PE
# min.nmr = minimum number of mark-recapture estimates needed in a year to generate an index, default 2
# show = print out a brief summary of the results, default FALSE
### OUTPUTS
# indfit = simple model used to predict missing mark-recap estimates
# streamdf = original allstreamdf, subsetted by selstreams, with estimates for missing mark-recaps
# indxdf = original alllakedf, subsetted by lake, with annual index, including raw (indxraw), kept based on min.nmr (indxkeep, indxkeep.lo, indxkeep.hi)
# scaleup = conversion factor used to scale up annual index to spawner model PE
streamdf <- allstreamdf[allstreamdf$ls %in% selstreams, ]
# error checks
check1 <- var(streamdf$lake)
if(is.na(check1) | is.null(check1)) stop("Either no streams selected or critical data missing.") else if(check1 > 0) stop("Selected streams should be only from ONE lake.")
if(any(is.na(match(c("year", "lake", "ls", "Emr", "CVmr"), names(allstreamdf))))) stop("allstreamdf must include these variables: year lake ls Emr CVmr.")
if(any(is.na(match(c("year", "lake", "PE"), names(alllakedf))))) stop("alllakedf must include these variables: lake year PE.")
# fill in missing mark-recap data
indfit <- aov(log(Emr) ~ as.factor(ls) + as.factor(year), data=streamdf, weights=1/CVmr^2)
# figure out estimable years (those with at least 1 m-r estimate)
n.mr <- tapply(!is.na(streamdf$Emr), streamdf$year, sum)
eyrs <- as.numeric(names(n.mr)[n.mr > 0.5])
estimable <- streamdf$year %in% eyrs
streamdf$Pmr <- NA
streamdf$Pmr[estimable] <- ModelEst(fit=indfit, df=streamdf[estimable, ])
streamdf$COMBmr <- ifelse(is.na(streamdf$Emr), streamdf$Pmr, streamdf$Emr)
# annual index (sum across streams)
indxdf <- aggregate(COMBmr ~ year + lake, streamdf, sum, na.rm=TRUE, na.action=na.pass)
names(indxdf)[names(indxdf)=="COMBmr"] <- "indxraw"
indxdf$indxraw[indxdf$indxraw==0] <- NA
# only keep lake-wide index for years with at least min.nmr mark-recap estimates
indxdf$n.mr <- n.mr
indxdf$indxkeep <- ifelse(indxdf$n.mr > (min.nmr - 0.5), indxdf$indxraw, NA)
indxdf$indxkeep.lo <- NA
indxdf$indxkeep.hi <- NA
# matrix of stream estimates (rows = years, columns = index streams)
streamests <- with(streamdf, tapply(COMBmr, list(year, ls), mean))
# selection of only those streams with a keepable index
selkeep <- !is.na(indxdf$indxkeep)
jack <- jackindex(streamests[selkeep, ])
indxdf$indxkeep.lo[selkeep] <- jack[, "lo"]
indxdf$indxkeep.hi[selkeep] <- jack[, "hi"]
# scale up the index to the spawner model PE
lk1 <- lk[lk$lake == streamdf$lake[1], ]
indxdf2 <- merge(lk1, indxdf, all=TRUE)
scaleup <- median(indxdf2$PE / indxdf2$indxkeep, na.rm=TRUE)
if(show) {
cat("\nindfit\n")
print(summary(indfit))
cat("\nstreamdf\n")
print(tail(streamdf[, c("lake", "year", "ls", "Emr", "CVmr", "Pmr", "COMBmr")]))
cat("\nscaleup\n")
print(scaleup)
cat("\nindxdf\n")
print(tail(indxdf[, c("lake", "year", "n.mr", "indxraw", "indxkeep", "indxkeep.lo", "indxkeep.hi")]))
}
list(indfit=indfit, streamdf=streamdf, scaleup=scaleup, indxdf=indxdf)
}
calctarg <- function(lakenum, adults, year, targyears, adjust=c(1, 1, 0.25, 1, 1)) {
# lakenum = vector of lake numbers (1-5)
# adults = vector of lakewide adult sea lamprey estimates
# year = vector of years
# targyears = list (length 5) of selected years from which to calculate targets
# lake huron target is 25% of
targets <- data.frame(lake=1:5, target=rep(NA, 5), lo=rep(NA, 5), hi=rep(NA, 5))
for(i in 1:5) {
pick5 <- adults[lakenum==i & is.element(year, targyears[[i]]) & !is.na(adults)]
if(length(pick5) > 0) {
targets$target[i] <- mean(pick5)
n <- length(pick5)
ci <- qnorm(1 - 0.05/2) * sqrt(var(pick5)) / sqrt(n)
targets[i, c("lo", "hi")] <- mean(pick5) + c(-1, 1)*ci# using z dist (known variance)
targets[i, c("target", "lo", "hi")] <- adjust[i]*targets[i, c("target", "lo", "hi")]
} else {
targets[i, c("target", "lo", "hi")] <- c(NA, NA, NA)
}
}
targets
}
}
# bring in lake-wide spawner data
lk <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/LakePEdynamic.csv", as.is=T)
# bring in stream-specific data
dat <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/StreamPEdynamicALLCOLS.csv", as.is=T)
dat$ls <- dat$lscode
# 2014-04-09 Jess and Gale agreed that the East Au Gres (38) should be replaced with the Au Sable (36) in Lake Huron
# 2014-04-10 Jess thinks that we should just stick with the East Au Gres (38)
index.streams <- list(
Sup = c(1, 2, 9, 29, 31, 32, 62),
Mic = c(5, 6, 15, 24, 26, 35),
Hur = c(10, 16, 27, 32, 999, 38),
Eri = c(1, 2, 3, 7, 9),
Ont = c(5, 9, 22, 23, 36)
)
index.streams <- lapply(1:5, function(i) i + index.streams[[i]]/1000)
# estimate adult index of abundance for each lake using index streams
indices <- lapply(index.streams, index.est, dat, lk)
# combine index data for all lakes in one dataframe
indxall <- do.call(rbind, lapply(indices, "[[", "indxdf"))
# calculate targets 
sptargyrz <- list(1994:1998, 1988:1992, 1989:1993, 1991:1995, 1999:2003)
targyrz <- apply(sapply(sptargyrz, range), 2, paste, collapse="-")
# spawner model
targets.sm <- calctarg(lakenum=lk$lake, adults=lk$PE, year=lk$year, targyears=sptargyrz)
# adult index
targets.ai <- calctarg(lakenum=indxall$lake, adults=indxall$indxkeep, year=indxall$year, targyears=sptargyrz)
# spawner model targets scaled down to adult index
targets.sm.su <- cbind(lake=targets.sm[, 1], (1/sapply(indices, "[[", "scaleup")) * targets.sm[, -1])
# adult index adjusted
targets.ai.adj <- targets.ai
targets.ai.adj[is.na(targets.ai$target), ] <- targets.sm.su[is.na(targets.ai$target), ]
YEAR1 <- 1984
# create a Word document with results
doc <- startrtf(file="2014-10 SLCB Index", dir="C:/JVA/Lamprey/Adults/AdultIndex/2014", omi=c(1, 1.25, 1, 1.25))
heading("Index of Adult Sea Lamprey Abundance in each Great Lake")
heading(paste("Adams, Barber, Bravener, Steeves -", as.character(Sys.Date())), htype=2)
### Spawner model time series
heading("Purpose of the index", htype=3)
heading("Selection of index streams", htype=3)
heading("Calculation of index", htype=3)
heading("Assumptions", htype=3)
heading("Fate of current spawner model", htype=3)
para("Conversion factors: ", paste(Lakenames, round(sapply(indices, "[[", "scaleup"), 2), collapse=", "), ".")
# position of text for selected streams in each lake (for map drawing)
posp <- list(c(3, 1, 3, 1, 1, 3, 1),
c(2, 2, 2, 2, 2, 2),
c(4, 4, 4, 4, 4, 4),
c(2, 2, 2, 2, 2),
c(2, 2, 2, 2, 2, 2))
i <- 1
mymap <- mapL[[i]]
mystreamdf <- indices[[i]]$streamdf
myindxdf <- indices[[i]]$indxdf
mystreamdf <- mystreamdf[mystreamdf$year >= YEAR1, ]
myindxdf <- myindxdf[myindxdf$year >= YEAR1, ]
### colored table of mark-recap estimates of selected streams
m <- with(mystreamdf, tapply(Emr, list(year, substring(strname, 1, 10)), mean))
m <- m[, rev(order(apply(m, 2, median, na.rm=TRUE)))]
cols.in.table <- sapply(index.streams, length) + 1
table.width <- 6*cols.in.table/max(cols.in.table)
# add in a blurb on the model predicted values in the most recent year.
lastyear <- rev(dimnames(m)[[1]])[1]
lastrow <- m[lastyear, ]
missings <- names(lastrow[is.na(lastrow)])
misstext <- ""
m
dim(m)
windows()
barplot(m)
myindxdf
barplot(myindxdf)
class(myindxdf)
as.matrix(myindxdf)
barplot(myindxdf$indxkeep)
mystreamdf
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p
m
barplot(p)
?barplot
barplot(t(p))
### barplot all PEs of index streams
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
barplot(t(p))
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p <- p[, order(apply(p, 2, median, na.rm=TRUE))]
barplot(t(p))
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p <- p[, order(apply(p, 2, median, na.rm=TRUE))]
p <- p[, order(apply(p, 2, var, na.rm=TRUE))]
barplot(t(p))
### barplot all PEs of index streams
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p <- p[, order(apply(p, 2, median, na.rm=TRUE))]
p <- p[, order(apply(p, 2, var, na.rm=TRUE))]
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
barplot(t(p))
barplot(t(p), las=1)
barplot(t(p)/1000, las=1)
col7 <- c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69")
barplot(t(p)/1000, las=1, col=col7)
a <- barplot(t(p)/1000, las=1, col=col7)
a
p
dimnames(p)
dimnames(p)[[1]]
as.numeric(dimnames(p)[[1]])
yrz
yrz <- as.numeric(dimnames(p)[[1]])
pretty(yrz)
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
windows()
par(mar=c(4, 4, 1, 1), las=1)
a <- barplot(t(p)/1000, las=1, col=col7, axes=FALSE, xlab="Year", ylab="Adult abundance  (thousands)")
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2)
box()
?barplot
par(mar=c(4, 4, 1, 1), las=1)
a <- barplot(t(p)/1000, las=1, col=col7, axes=FALSE, names.arg="", xlab="Year", ylab="Adult abundance  (thousands)")
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2)
box()
p
apply(p, 1, sum, na.rm=TRUE)
max(apply(p, 1, sum, na.rm=TRUE))
par(mar=c(4, 4, 1, 1), las=1)
a <- barplot(t(p)/1000, las=1, col=col7, axes=FALSE, names.arg="", ylim=1.05*c(0, max(apply(p, 1, sum, na.rm=TRUE))), 
xlab="Year", ylab="Adult abundance  (thousands)")
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2)
box()
par(mar=c(4, 4, 1, 1), las=1)
a <- barplot(t(p)/1000, las=1, col=col7, axes=FALSE, names.arg=NA, ylim=1.05*c(0, max(apply(p, 1, sum, na.rm=TRUE))), 
xlab="Year", ylab="Adult abundance  (thousands)")
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2)
box()
par(mar=c(4, 4, 1, 1), las=1)
a <- barplot(t(p)/1000, las=1, col=col7, axes=FALSE, names.arg=NULL, ylim=1.05*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="Year", ylab="Adult abundance  (thousands)")
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2)
box()
par(mar=c(4, 4, 1, 1), las=1)
a <- barplot(t(p)/1000, las=1, col=col7, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.05*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="Year", ylab="Adult abundance  (thousands)")
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2)
box()
par(mar=c(4, 4, 1, 1), las=1)
a <- barplot(t(p)/1000, las=1, col=col7, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.01*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="Year", ylab="Adult abundance  (thousands)")
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2)
box()
par(mar=c(4, 4, 1, 1), las=1, yaxs="i")
a <- barplot(t(p)/1000, las=1, col=col7, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.01*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="Year", ylab="Adult abundance  (thousands)")
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2)
box()
p
colnames(p)
par(mar=c(4, 4, 1, 1), las=1, yaxs="i")
a <- barplot(t(p)/1000, las=1, col=col7, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.01*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="Year", ylab="Adult abundance  (thousands)")
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2)
box()
legend("topleft", colnames(p), col7)
legend("topleft", colnames(p), col=col7)
?legend
par(mar=c(4, 4, 1, 1), las=1, yaxs="i")
a <- barplot(t(p)/1000, las=1, col=col7, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.01*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="Year", ylab="Adult abundance  (thousands)")
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2)
box()
legend("topleft", colnames(p), fill=col7)
par(mar=c(4, 4, 1, 1), las=1, yaxs="i")
a <- barplot(t(p)/1000, las=1, col=col7, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.01*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="Year", ylab="Adult abundance  (thousands)")
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2)
box()
legend("topleft", rev(colnames(p)), fill=rev(col7))
### bar plot of individual stream PEs
fig <- function() {
par(mar=c(4, 4, 1, 1), las=1, yaxs="i", cex=1.5)
a <- barplot(t(p)/1000, las=1, col=col7, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.01*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="Year", ylab="Adult abundance  (thousands)")
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2)
box()
legend("topleft", rev(colnames(p)), fill=rev(col7))
}
windows()
fig()
# C:\JVA\Lamprey\Adults\AdultIndex\2014\AdultIndex v2.r
{ # functions
# the following seven plot.table related function are from the Systmatic Investor Toolbox
# load Systematic Investor Toolbox
# require(RCurl)
# sit = getURLContent("https://github.com/systematicinvestor/SIT/raw/master/sit.gz", binary=TRUE, followlocation=TRUE, ssl.verifypeer=FALSE)
# con = gzcon(rawConnection(sit, "rb"))
# source(con)
# close(con)
draw.cell <- function(title, r, c, text.cex = 1, bg.col = 'white', frame.cell = T) {
if(!frame.cell) bcol = bg.col else bcol = 'black'
rect((2*(c - 1) + .5), -(r - .5), (2*c + .5), -(r + .5), col = bg.col, border = bcol)
if( c == 1) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else if( r == 1 ) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else {
text((2*c + .5), -r, title, adj = 1, cex = text.cex)
}
}
plot.table.helper.auto.adjust.cex <- function(temp.table, keep.all.same.cex = FALSE) {
nr = nrow(temp.table)
nc = ncol(temp.table)
all.xrange = diff(par()$usr[1:2]) / nc
xrange = matrix( strwidth(paste('  ', temp.table), units = 'user', cex = 1), nc = nc)
all.yrange = diff(par()$usr[3:4]) / nr
yrange = matrix( 5/3 * strheight(temp.table, units = 'user', cex = 1), nc = nc)
plot.matrix.cex = pmin( round(all.yrange / yrange, 2) , round(all.xrange / xrange, 2) )
header.col.cex = min(plot.matrix.cex[1,-1])
header.row.cex = min(plot.matrix.cex[-1,1])
title.cex = plot.matrix.cex[1, 1]
data.cex = min(plot.matrix.cex[-1, -1])
if ( keep.all.same.cex ) {
plot.matrix.cex[] = min(plot.matrix.cex)
} else {
plot.matrix.cex[1,-1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,-1]= min(c(header.col.cex, header.row.cex, data.cex))
plot.matrix.cex[1,1]= min(c(header.col.cex, header.row.cex, data.cex, title.cex))
plot.matrix.cex[1,-1] = min(c(header.col.cex))
plot.matrix.cex[-1,1] = min(c(header.row.cex))
plot.matrix.cex[-1,-1]= min(c(data.cex))
plot.matrix.cex[1,1]= min(c(title.cex))
}
return(plot.matrix.cex)
}
make.table <- function(nr, nc) {
savepar = par(mar = rep(1, 4))
plot(c(0.5, nc*2 + 0.5), c(-0.5, -(nr + 0.5)), xaxs = 'i', yaxs = 'i',
type = 'n', xlab = '', ylab = '', axes = FALSE)
savepar
}
trim <- function(s) {
s = sub(pattern = '^ +', replacement = '', x = s)
s = sub(pattern = ' +$', replacement = '', x = s)
return(s)
}
plot.table.param <- function(plot.matrix, smain = '', plot.matrix.cex, plot.matrix_bg.col, frame.cell = T, keep.all.same.cex = FALSE) {
n = nrow(plot.matrix)
pages = unique(c(seq(0, n, by = 120), n))
for(p in 1:(length(pages)-1)) {
rindex = (pages[p]+1) : pages[p+1]
temp.table = matrix('', nr = length(rindex)+1, nc = ncol(plot.matrix)+1)
temp.table[-1, -1] = plot.matrix[rindex,]
temp.table[1, -1] = colnames(plot.matrix)
temp.table[-1, 1] = rownames(plot.matrix)[rindex]
temp.table[1, 1] = smain
nr = nrow(temp.table)
nc = ncol(temp.table)
par(mar = c(0, 0, 0, 0), cex = 0.5)
oldpar = make.table(nr, nc)
text.cex = plot.matrix.cex[c(1, 1 + rindex), ]
text.cex = plot.table.helper.auto.adjust.cex(temp.table, keep.all.same.cex)
bg.col = plot.matrix_bg.col[c(1, 1 + rindex), ]
for(r in 1:nr) {
for(c in 1:nc) {
draw.cell( paste('', temp.table[r,c], '', sep=' '), r, c,
text.cex = text.cex[r,c], bg.col = bg.col[r,c], frame.cell = frame.cell)
}}
}
}
plot.table <- function(plot.matrix, smain="", text.cex=1, frame.cell=TRUE, highlight=FALSE, colorbar=FALSE, keep_all.same.cex=FALSE) {
if( is.null(rownames(plot.matrix)) & is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
if( ncol(temp.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[-1, -1, drop = FALSE]
colnames(plot.matrix) = temp.matrix[1, -1]
rownames(plot.matrix) = temp.matrix[-1, 1]
smain = temp.matrix[1, 1]
} else if( is.null(rownames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( ncol(plot.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[, -1, drop = FALSE]
colnames(plot.matrix) = colnames(temp.matrix)[-1]
rownames(plot.matrix) = temp.matrix[,1]
smain = colnames(temp.matrix)[1]
} else if( is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
plot.matrix = temp.matrix[-1, , drop = FALSE]
rownames(plot.matrix) = rownames(temp.matrix)[-1]
colnames(plot.matrix) = temp.matrix[1, ]
smain = rownames(temp.matrix)[1]
}
plot.matrix[which(trim(plot.matrix) == "NA")] = ""
plot.matrix[which(trim(plot.matrix) == "NA%")] = ""
plot.matrix[which(is.na(plot.matrix))] = ""
nr = nrow(plot.matrix) + 1
nc = ncol(plot.matrix) + 1
is_highlight = TRUE
if(is.logical(highlight)) {
is_highlight = highlight
if(highlight) highlight = plot.table.helper.color(plot.matrix)
}
if(!is_highlight) {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[seq(1, nr, 2), ] = "yellow"
plot.matrix_bg.col[1,] = "gray";
plot.table.param( plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
} else {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[1,] = "gray"
plot.matrix_bg.col[2:nr,2:nc] = highlight
plot.table.param(plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
}
}
plot.table.helper.color <- function (temp) {
temp = matrix(as.double(gsub("[%,$]", "", temp)), nrow(temp), ncol(temp))
highlight = as.vector(temp)
cols = rep(NA, length(highlight))
ncols = length(highlight[!is.na(highlight)])
cols[1:ncols] = rev(rainbow(ncols, start=0.5/6, end=3.5/6))
o = sort.list(highlight, na.last = TRUE, decreasing = FALSE)
o1 = sort.list(o, na.last = TRUE, decreasing = FALSE)
highlight = matrix(cols[o1], nrow = nrow(temp))
highlight[is.na(temp)] = NA
return(highlight)
}
ModelEst <- function(fit, df) {
# derive regression estimates from log(y) fit
mse <- rev(as.matrix(summary(fit)[[1]])[, "Mean Sq"])[1]
plpe <- predict(fit, newdata=df, se.fit=T)
m <- plpe$fit
v <- plpe$se.fit^2 + mse
exp(m + v/2)
}
myrange <- function(x) {
if(all(is.na(x))) r <- c(NA, NA) else r <- range(x, na.rm=TRUE)
return(r)
}
jackindex <- function(m) {
# m is a matrix of numbers (stream PEs) with observations (years) as rows and individuals (streams) as columns
if(any(is.na(m))) stop("The input matrix may not have any missing values.")
# calculate the index as the sum of the columns for each row
rowsum <- apply(m, 1, sum)
# calculate the mean of the index
avgind <- mean(rowsum)
# recalculate the index, leaving out one individual at a time
loo <- apply(m, 2, function(column) (rowsum - column))
# rescale the loo index, relative to mean
looscaled <- apply(loo, 2, function(x) x/mean(x))
# convert to original scale
looscaled2 <- looscaled * avgind
# calculate range
ranges <- t(apply(looscaled2, 1, range))
cbind(index=rowsum, lo=ranges[, 1], hi=ranges[, 2])
}
# selstreams <- index.streams[[1]] 
# allstreamdf <- dat
# alllakedf <- lk 
# min.nmr=2 
# show=FALSE
index.est <- function(selstreams, allstreamdf, alllakedf, min.nmr=2, show=FALSE) {
# INDEX OF ADULT SEA LAMPREY ABUNDANCE
### INPUTS
# selstreams = vector of stream ids, e.g., 1.064 (lake + strcode/1000)
# allstreamdf = data frame of mark-recap estimates for all streams, with vars:  year lake ls Emr CVmr
# alllakedf = data frame of lake-wide PEs from Mullett et al. (2003) spawner model with vars:  lake year PE
# min.nmr = minimum number of mark-recapture estimates needed in a year to generate an index, default 2
# show = print out a brief summary of the results, default FALSE
### OUTPUTS
# indfit = simple model used to predict missing mark-recap estimates
# streamdf = original allstreamdf, subsetted by selstreams, with estimates for missing mark-recaps
# indxdf = original alllakedf, subsetted by lake, with annual index, including raw (indxraw), kept based on min.nmr (indxkeep, indxkeep.lo, indxkeep.hi)
# scaleup = conversion factor used to scale up annual index to spawner model PE
streamdf <- allstreamdf[allstreamdf$ls %in% selstreams, ]
# error checks
check1 <- var(streamdf$lake)
if(is.na(check1) | is.null(check1)) stop("Either no streams selected or critical data missing.") else if(check1 > 0) stop("Selected streams should be only from ONE lake.")
if(any(is.na(match(c("year", "lake", "ls", "Emr", "CVmr"), names(allstreamdf))))) stop("allstreamdf must include these variables: year lake ls Emr CVmr.")
if(any(is.na(match(c("year", "lake", "PE"), names(alllakedf))))) stop("alllakedf must include these variables: lake year PE.")
# fill in missing mark-recap data
indfit <- aov(log(Emr) ~ as.factor(ls) + as.factor(year), data=streamdf, weights=1/CVmr^2)
# figure out estimable years (those with at least 1 m-r estimate)
n.mr <- tapply(!is.na(streamdf$Emr), streamdf$year, sum)
eyrs <- as.numeric(names(n.mr)[n.mr > 0.5])
estimable <- streamdf$year %in% eyrs
streamdf$Pmr <- NA
streamdf$Pmr[estimable] <- ModelEst(fit=indfit, df=streamdf[estimable, ])
streamdf$COMBmr <- ifelse(is.na(streamdf$Emr), streamdf$Pmr, streamdf$Emr)
# annual index (sum across streams)
indxdf <- aggregate(COMBmr ~ year + lake, streamdf, sum, na.rm=TRUE, na.action=na.pass)
names(indxdf)[names(indxdf)=="COMBmr"] <- "indxraw"
indxdf$indxraw[indxdf$indxraw==0] <- NA
# only keep lake-wide index for years with at least min.nmr mark-recap estimates
indxdf$n.mr <- n.mr
indxdf$indxkeep <- ifelse(indxdf$n.mr > (min.nmr - 0.5), indxdf$indxraw, NA)
indxdf$indxkeep.lo <- NA
indxdf$indxkeep.hi <- NA
# matrix of stream estimates (rows = years, columns = index streams)
streamests <- with(streamdf, tapply(COMBmr, list(year, ls), mean))
# selection of only those streams with a keepable index
selkeep <- !is.na(indxdf$indxkeep)
jack <- jackindex(streamests[selkeep, ])
indxdf$indxkeep.lo[selkeep] <- jack[, "lo"]
indxdf$indxkeep.hi[selkeep] <- jack[, "hi"]
# scale up the index to the spawner model PE
lk1 <- lk[lk$lake == streamdf$lake[1], ]
indxdf2 <- merge(lk1, indxdf, all=TRUE)
scaleup <- median(indxdf2$PE / indxdf2$indxkeep, na.rm=TRUE)
if(show) {
cat("\nindfit\n")
print(summary(indfit))
cat("\nstreamdf\n")
print(tail(streamdf[, c("lake", "year", "ls", "Emr", "CVmr", "Pmr", "COMBmr")]))
cat("\nscaleup\n")
print(scaleup)
cat("\nindxdf\n")
print(tail(indxdf[, c("lake", "year", "n.mr", "indxraw", "indxkeep", "indxkeep.lo", "indxkeep.hi")]))
}
list(indfit=indfit, streamdf=streamdf, scaleup=scaleup, indxdf=indxdf)
}
calctarg <- function(lakenum, adults, year, targyears, adjust=c(1, 1, 0.25, 1, 1)) {
# lakenum = vector of lake numbers (1-5)
# adults = vector of lakewide adult sea lamprey estimates
# year = vector of years
# targyears = list (length 5) of selected years from which to calculate targets
# lake huron target is 25% of
targets <- data.frame(lake=1:5, target=rep(NA, 5), lo=rep(NA, 5), hi=rep(NA, 5))
for(i in 1:5) {
pick5 <- adults[lakenum==i & is.element(year, targyears[[i]]) & !is.na(adults)]
if(length(pick5) > 0) {
targets$target[i] <- mean(pick5)
n <- length(pick5)
ci <- qnorm(1 - 0.05/2) * sqrt(var(pick5)) / sqrt(n)
targets[i, c("lo", "hi")] <- mean(pick5) + c(-1, 1)*ci# using z dist (known variance)
targets[i, c("target", "lo", "hi")] <- adjust[i]*targets[i, c("target", "lo", "hi")]
} else {
targets[i, c("target", "lo", "hi")] <- c(NA, NA, NA)
}
}
targets
}
}
# bring in lake-wide spawner data
lk <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/LakePEdynamic.csv", as.is=T)
# bring in stream-specific data
dat <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/StreamPEdynamicALLCOLS.csv", as.is=T)
dat$ls <- dat$lscode
# 2014-04-09 Jess and Gale agreed that the East Au Gres (38) should be replaced with the Au Sable (36) in Lake Huron
# 2014-04-10 Jess thinks that we should just stick with the East Au Gres (38)
index.streams <- list(
Sup = c(1, 2, 9, 29, 31, 32, 62),
Mic = c(5, 6, 15, 24, 26, 35),
Hur = c(10, 16, 27, 32, 999, 38),
Eri = c(1, 2, 3, 7, 9),
Ont = c(5, 9, 22, 23, 36)
)
index.streams <- lapply(1:5, function(i) i + index.streams[[i]]/1000)
# estimate adult index of abundance for each lake using index streams
indices <- lapply(index.streams, index.est, dat, lk)
# combine index data for all lakes in one dataframe
indxall <- do.call(rbind, lapply(indices, "[[", "indxdf"))
# calculate targets 
sptargyrz <- list(1994:1998, 1988:1992, 1989:1993, 1991:1995, 1999:2003)
targyrz <- apply(sapply(sptargyrz, range), 2, paste, collapse="-")
# spawner model
targets.sm <- calctarg(lakenum=lk$lake, adults=lk$PE, year=lk$year, targyears=sptargyrz)
# adult index
targets.ai <- calctarg(lakenum=indxall$lake, adults=indxall$indxkeep, year=indxall$year, targyears=sptargyrz)
# spawner model targets scaled down to adult index
targets.sm.su <- cbind(lake=targets.sm[, 1], (1/sapply(indices, "[[", "scaleup")) * targets.sm[, -1])
# adult index adjusted
targets.ai.adj <- targets.ai
targets.ai.adj[is.na(targets.ai$target), ] <- targets.sm.su[is.na(targets.ai$target), ]
YEAR1 <- 1984
# create a Word document with results
doc <- startrtf(file="2014-10 SLCB Index", dir="C:/JVA/Lamprey/Adults/AdultIndex/2014", omi=c(1, 1.25, 1, 1.25))
heading("Index of Adult Sea Lamprey Abundance in each Great Lake")
heading(paste("Adams, Barber, Bravener, Steeves -", as.character(Sys.Date())), htype=2)
### Spawner model time series
heading("Purpose of the index", htype=3)
heading("Selection of index streams", htype=3)
heading("Calculation of index", htype=3)
heading("Assumptions", htype=3)
heading("Fate of current spawner model", htype=3)
para("Conversion factors: ", paste(Lakenames, round(sapply(indices, "[[", "scaleup"), 2), collapse=", "), ".")
# position of text for selected streams in each lake (for map drawing)
posp <- list(c(3, 1, 3, 1, 1, 3, 1),
c(2, 2, 2, 2, 2, 2),
c(4, 4, 4, 4, 4, 4),
c(2, 2, 2, 2, 2),
c(2, 2, 2, 2, 2, 2))
for(i in 1:5) {
mymap <- mapL[[i]]
mystreamdf <- indices[[i]]$streamdf
myindxdf <- indices[[i]]$indxdf
mystreamdf <- mystreamdf[mystreamdf$year >= YEAR1, ]
myindxdf <- myindxdf[myindxdf$year >= YEAR1, ]
### colored table of mark-recap estimates of selected streams
m <- with(mystreamdf, tapply(Emr, list(year, substring(strname, 1, 10)), mean))
m <- m[, rev(order(apply(m, 2, median, na.rm=TRUE)))]
cols.in.table <- sapply(index.streams, length) + 1
table.width <- 6*cols.in.table/max(cols.in.table)
# add in a blurb on the model predicted values in the most recent year.
lastyear <- rev(dimnames(m)[[1]])[1]
lastrow <- m[lastyear, ]
missings <- names(lastrow[is.na(lastrow)])
misstext <- ""
if(length(missings)>0) {
preds <- with(mystreamdf, COMBmr[year==lastyear & strname %in% missings])
insert <- paste(paste(format(round(preds), big.mark=","), "for the", missings), collapse=", ")
if(length(missings)>1) {
misstext <- paste0("  In ", lastyear, ", these estimates were: ", insert, ".")
} else {
misstext <- paste0("  In ", lastyear, ", this estimate was ", insert, ".")
}
}
### barplot all PEs of index streams
col7 <- c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69")
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
fig <- function() {
plot.table(format(round(m), big.mark=","), highlight=TRUE)
}
figu("Mark-recapture estimates from Lake ", Lakenames[i], " index streams.", 
"  Colors are used to highlight quantities from low (blue) to high (orange).", 
"  Streams are ordered according to their median estimates, highest (left) to lowest (right).", 
"  Abundances in streams without valid mark-recapture estimates (white rectangles) were estimated from the mean stream PE and the mean annual pattern,",
" weighting by the inverse CV2.", misstext, figid="Table ", fign=tabcount, newpage="port", capunder=FALSE, w=table.width[i], h=7)
tabcount <- tabcount + 1
figcount <- figcount - 1
### map of selected streams
fig <- function() {
map(xlim=range(mymap$x, na.rm=T), ylim=range(mymap$y, na.rm=T), col=NA, mar=rep(1, 4))
lines(mymap$x, mymap$y, col="darkgray", lwd=0.5)
with(mystreamdf[mystreamdf$year==2010, ], {
points(long, lat, cex=1.5, pch=16)
par(xpd=NA)
text(long, lat, strname, cex=1.2, pos=posp[[i]], font=2)
})
}
figu("Streams selected for inclusion in the Lake ", Lakenames[i], " index of adult sea lamprey abundance.", h=c(3, 6, 6, 3, 3)[i], w=6)
### bar plot of individual stream PEs
fig <- function() {
par(mar=c(4, 4, 1, 1), las=1, yaxs="i", cex=1.5)
a <- barplot(t(p)/1000, las=1, col=col7, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.01*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="Year", ylab="Adult abundance  (thousands)")
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2)
box()
legend("topleft", rev(colnames(p)), fill=rev(col7))
}
figu("Adult sea lamprey abundance estimates for index streams of Lake ", Lakenames[i], ".", h=3, w=6)
### time series of PEs
fig <- function() {
par(mar=c(4, 4, 1, 1), cex=1.5, yaxs="i")
with(myindxdf, {
just <- year >= min(year[!is.na(indxkeep)])
yr <- 1.05*range(0, indxkeep.hi[just], na.rm=TRUE)/1000
plot(1, 1, xlim=range(year), ylim=yr, type="n", xlab="Year", ylab="Adults (thousands)", las=1)
arrows(year, indxkeep.lo/1000, year, indxkeep.hi/1000, length=0, angle=90, code=3, lwd=10, lend="square", col="#ffddc1")
abline(h=targets.ai.adj$target[i]/1000)
abline(h=targets.ai.adj[i, c("lo", "hi")]/1000, lty=2)
lines(year, indxkeep/1000, lwd=2, col=blindcolz[7], type="o", pch=17)
})
}
figu("Patterns over time in Lake ", Lakenames[i], " adult sea lampreys using the newly derived index.", 
"  Jackknife-type error bars for the annual abundance of adults are indicated by shaded rectangles.",
"  The index target is indicated by the horizontal line (with 95% confidence intervals).", h=3, w=6)
}
rm(mymap, mystreamdf, myindxdf, m, cols.in.table, table.width, lastrow, missings, misstext, preds, insert,
col7, p, yrz, pyrz)
### spawner model and adult index time series overlaid
fig <- function() {
par(mfrow=c(3, 2), mar=c(3, 3, 2, 3), oma=c(2, 2, 0, 0), cex=1.4, yaxs="i")
for(i in 1:5) {
mylk <- lk[lk$lake==i, ]# lake year PE lo hi
myindxdf <- indices[[i]]$indxdf# year lake indxraw n.mr indxkeep indxkeep.lo indxkeep.hi
convfac <- indices[[i]]$scaleup
x1 <- myindxdf$year
y1 <- myindxdf$indxkeep/1000
x2 <- mylk$year
y2 <- mylk$PE/convfac/1000
yr <- 1.05*range(0, y1, y2[x2>=YEAR1], na.rm=TRUE)
plot(1, 1, type="n", xlim=range(lk$year), ylim=yr, xlab="", ylab="", main=Lakenames[i], axes=FALSE)
axis(1)
axis(2, col=blindcolz[7], col.axis=blindcolz[7], las=1)
par(mgp=c(3, 2.2, 0))
axis(4, at=pretty(convfac*yr)/convfac, labels=pretty(convfac*yr), col=blindcolz[3], col.axis=blindcolz[3], las=1, hadj=1)
par(mgp=c(3, 1, 0))
box()
abline(h=targets.sm$target[i]/convfac/1000, col=blindcolz[3], lty=2)
abline(h=targets.ai.adj$target[i]/1000, col=blindcolz[7], lty=2)
lines(x2, y2, col=blindcolz[3], type="o", pch=18, lwd=2)
lines(x1, y1, col=blindcolz[7], type="o", pch=17, lwd=2)
if(i==1) {
plot(1, 1, type="n", xlab="", ylab="", axes=FALSE)
legend("center", c("Adult index", "Spawner model"), col=blindcolz[c(7, 3)], lwd=2, pch=c(17, 18))
}
}
mtext("Year", outer=TRUE, side=1, cex=1.8)
mtext("Adult abundance  (thousands)", outer=TRUE, side=2, cex=1.8)
}
figu("Patterns over time in adult sea lamprey abundance, comparing the newly derived index with the spawner model.",
"  Targets are indicated by dashed horizontal lines.",
"  Targets are based on averages from five years with historically acceptable wounding rates: ", paste(paste(targyrz, "in", Lakenames), collapse=", "), ".", 
w=6, h=7.5)
endrtf()
rm(targyrz, i)
names(indices[[1]])
# "indfit"   "streamdf" "scaleup"  "indxdf"
# scale up
round(sapply(indices, "[[", 3), 2)
# 3.84 1.85 2.82 1.01 2.40
indxall[7:11, ]
   # year lake   indxraw n.mr  indxkeep indxkeep.lo indxkeep.hi
# 7  1986    1 24275.673    5 24275.673   18726.753   27579.203
# 8  1987    1 10994.483    5 10994.483   10269.609   11494.884
# 9  1988    1 13630.037    5 13630.037   11710.612   14680.398
# 10 1989    1 20227.926    6 20227.926   18704.166   21988.594
# 11 1990    1  9332.001    5  9332.001    8435.646   11991.514
cleanup()
search()
# C:\JVA\Lamprey\Adults\AdultIndex\2014\AdultIndex v2.r
{ # functions
# the following seven plot.table related function are from the Systmatic Investor Toolbox
# load Systematic Investor Toolbox
# require(RCurl)
# sit = getURLContent("https://github.com/systematicinvestor/SIT/raw/master/sit.gz", binary=TRUE, followlocation=TRUE, ssl.verifypeer=FALSE)
# con = gzcon(rawConnection(sit, "rb"))
# source(con)
# close(con)
draw.cell <- function(title, r, c, text.cex = 1, bg.col = 'white', frame.cell = T) {
if(!frame.cell) bcol = bg.col else bcol = 'black'
rect((2*(c - 1) + .5), -(r - .5), (2*c + .5), -(r + .5), col = bg.col, border = bcol)
if( c == 1) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else if( r == 1 ) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else {
text((2*c + .5), -r, title, adj = 1, cex = text.cex)
}
}
plot.table.helper.auto.adjust.cex <- function(temp.table, keep.all.same.cex = FALSE) {
nr = nrow(temp.table)
nc = ncol(temp.table)
all.xrange = diff(par()$usr[1:2]) / nc
xrange = matrix( strwidth(paste('  ', temp.table), units = 'user', cex = 1), nc = nc)
all.yrange = diff(par()$usr[3:4]) / nr
yrange = matrix( 5/3 * strheight(temp.table, units = 'user', cex = 1), nc = nc)
plot.matrix.cex = pmin( round(all.yrange / yrange, 2) , round(all.xrange / xrange, 2) )
header.col.cex = min(plot.matrix.cex[1,-1])
header.row.cex = min(plot.matrix.cex[-1,1])
title.cex = plot.matrix.cex[1, 1]
data.cex = min(plot.matrix.cex[-1, -1])
if ( keep.all.same.cex ) {
plot.matrix.cex[] = min(plot.matrix.cex)
} else {
plot.matrix.cex[1,-1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,-1]= min(c(header.col.cex, header.row.cex, data.cex))
plot.matrix.cex[1,1]= min(c(header.col.cex, header.row.cex, data.cex, title.cex))
plot.matrix.cex[1,-1] = min(c(header.col.cex))
plot.matrix.cex[-1,1] = min(c(header.row.cex))
plot.matrix.cex[-1,-1]= min(c(data.cex))
plot.matrix.cex[1,1]= min(c(title.cex))
}
return(plot.matrix.cex)
}
make.table <- function(nr, nc) {
savepar = par(mar = rep(1, 4))
plot(c(0.5, nc*2 + 0.5), c(-0.5, -(nr + 0.5)), xaxs = 'i', yaxs = 'i',
type = 'n', xlab = '', ylab = '', axes = FALSE)
savepar
}
trim <- function(s) {
s = sub(pattern = '^ +', replacement = '', x = s)
s = sub(pattern = ' +$', replacement = '', x = s)
return(s)
}
plot.table.param <- function(plot.matrix, smain = '', plot.matrix.cex, plot.matrix_bg.col, frame.cell = T, keep.all.same.cex = FALSE) {
n = nrow(plot.matrix)
pages = unique(c(seq(0, n, by = 120), n))
for(p in 1:(length(pages)-1)) {
rindex = (pages[p]+1) : pages[p+1]
temp.table = matrix('', nr = length(rindex)+1, nc = ncol(plot.matrix)+1)
temp.table[-1, -1] = plot.matrix[rindex,]
temp.table[1, -1] = colnames(plot.matrix)
temp.table[-1, 1] = rownames(plot.matrix)[rindex]
temp.table[1, 1] = smain
nr = nrow(temp.table)
nc = ncol(temp.table)
par(mar = c(0, 0, 0, 0), cex = 0.5)
oldpar = make.table(nr, nc)
text.cex = plot.matrix.cex[c(1, 1 + rindex), ]
text.cex = plot.table.helper.auto.adjust.cex(temp.table, keep.all.same.cex)
bg.col = plot.matrix_bg.col[c(1, 1 + rindex), ]
for(r in 1:nr) {
for(c in 1:nc) {
draw.cell( paste('', temp.table[r,c], '', sep=' '), r, c,
text.cex = text.cex[r,c], bg.col = bg.col[r,c], frame.cell = frame.cell)
}}
}
}
plot.table <- function(plot.matrix, smain="", text.cex=1, frame.cell=TRUE, highlight=FALSE, colorbar=FALSE, keep_all.same.cex=FALSE) {
if( is.null(rownames(plot.matrix)) & is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
if( ncol(temp.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[-1, -1, drop = FALSE]
colnames(plot.matrix) = temp.matrix[1, -1]
rownames(plot.matrix) = temp.matrix[-1, 1]
smain = temp.matrix[1, 1]
} else if( is.null(rownames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( ncol(plot.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[, -1, drop = FALSE]
colnames(plot.matrix) = colnames(temp.matrix)[-1]
rownames(plot.matrix) = temp.matrix[,1]
smain = colnames(temp.matrix)[1]
} else if( is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
plot.matrix = temp.matrix[-1, , drop = FALSE]
rownames(plot.matrix) = rownames(temp.matrix)[-1]
colnames(plot.matrix) = temp.matrix[1, ]
smain = rownames(temp.matrix)[1]
}
plot.matrix[which(trim(plot.matrix) == "NA")] = ""
plot.matrix[which(trim(plot.matrix) == "NA%")] = ""
plot.matrix[which(is.na(plot.matrix))] = ""
nr = nrow(plot.matrix) + 1
nc = ncol(plot.matrix) + 1
is_highlight = TRUE
if(is.logical(highlight)) {
is_highlight = highlight
if(highlight) highlight = plot.table.helper.color(plot.matrix)
}
if(!is_highlight) {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[seq(1, nr, 2), ] = "yellow"
plot.matrix_bg.col[1,] = "gray";
plot.table.param( plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
} else {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[1,] = "gray"
plot.matrix_bg.col[2:nr,2:nc] = highlight
plot.table.param(plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
}
}
plot.table.helper.color <- function (temp) {
temp = matrix(as.double(gsub("[%,$]", "", temp)), nrow(temp), ncol(temp))
highlight = as.vector(temp)
cols = rep(NA, length(highlight))
ncols = length(highlight[!is.na(highlight)])
cols[1:ncols] = rev(rainbow(ncols, start=0.5/6, end=3.5/6))
o = sort.list(highlight, na.last = TRUE, decreasing = FALSE)
o1 = sort.list(o, na.last = TRUE, decreasing = FALSE)
highlight = matrix(cols[o1], nrow = nrow(temp))
highlight[is.na(temp)] = NA
return(highlight)
}
ModelEst <- function(fit, df) {
# derive regression estimates from log(y) fit
mse <- rev(as.matrix(summary(fit)[[1]])[, "Mean Sq"])[1]
plpe <- predict(fit, newdata=df, se.fit=T)
m <- plpe$fit
v <- plpe$se.fit^2 + mse
exp(m + v/2)
}
myrange <- function(x) {
if(all(is.na(x))) r <- c(NA, NA) else r <- range(x, na.rm=TRUE)
return(r)
}
jackindex <- function(m) {
# m is a matrix of numbers (stream PEs) with observations (years) as rows and individuals (streams) as columns
if(any(is.na(m))) stop("The input matrix may not have any missing values.")
# calculate the index as the sum of the columns for each row
rowsum <- apply(m, 1, sum)
# calculate the mean of the index
avgind <- mean(rowsum)
# recalculate the index, leaving out one individual at a time
loo <- apply(m, 2, function(column) (rowsum - column))
# rescale the loo index, relative to mean
looscaled <- apply(loo, 2, function(x) x/mean(x))
# convert to original scale
looscaled2 <- looscaled * avgind
# calculate range
ranges <- t(apply(looscaled2, 1, range))
cbind(index=rowsum, lo=ranges[, 1], hi=ranges[, 2])
}
# selstreams <- index.streams[[1]] 
# allstreamdf <- dat
# alllakedf <- lk 
# min.nmr=2 
# show=FALSE
index.est <- function(selstreams, allstreamdf, alllakedf, min.nmr=2, show=FALSE) {
# INDEX OF ADULT SEA LAMPREY ABUNDANCE
### INPUTS
# selstreams = vector of stream ids, e.g., 1.064 (lake + strcode/1000)
# allstreamdf = data frame of mark-recap estimates for all streams, with vars:  year lake ls Emr CVmr
# alllakedf = data frame of lake-wide PEs from Mullett et al. (2003) spawner model with vars:  lake year PE
# min.nmr = minimum number of mark-recapture estimates needed in a year to generate an index, default 2
# show = print out a brief summary of the results, default FALSE
### OUTPUTS
# indfit = simple model used to predict missing mark-recap estimates
# streamdf = original allstreamdf, subsetted by selstreams, with estimates for missing mark-recaps
# indxdf = original alllakedf, subsetted by lake, with annual index, including raw (indxraw), kept based on min.nmr (indxkeep, indxkeep.lo, indxkeep.hi)
# scaleup = conversion factor used to scale up annual index to spawner model PE
streamdf <- allstreamdf[allstreamdf$ls %in% selstreams, ]
# error checks
check1 <- var(streamdf$lake)
if(is.na(check1) | is.null(check1)) stop("Either no streams selected or critical data missing.") else if(check1 > 0) stop("Selected streams should be only from ONE lake.")
if(any(is.na(match(c("year", "lake", "ls", "Emr", "CVmr"), names(allstreamdf))))) stop("allstreamdf must include these variables: year lake ls Emr CVmr.")
if(any(is.na(match(c("year", "lake", "PE"), names(alllakedf))))) stop("alllakedf must include these variables: lake year PE.")
# fill in missing mark-recap data
indfit <- aov(log(Emr) ~ as.factor(ls) + as.factor(year), data=streamdf, weights=1/CVmr^2)
# figure out estimable years (those with at least 1 m-r estimate)
n.mr <- tapply(!is.na(streamdf$Emr), streamdf$year, sum)
eyrs <- as.numeric(names(n.mr)[n.mr > 0.5])
estimable <- streamdf$year %in% eyrs
streamdf$Pmr <- NA
streamdf$Pmr[estimable] <- ModelEst(fit=indfit, df=streamdf[estimable, ])
streamdf$COMBmr <- ifelse(is.na(streamdf$Emr), streamdf$Pmr, streamdf$Emr)
# annual index (sum across streams)
indxdf <- aggregate(COMBmr ~ year + lake, streamdf, sum, na.rm=TRUE, na.action=na.pass)
names(indxdf)[names(indxdf)=="COMBmr"] <- "indxraw"
indxdf$indxraw[indxdf$indxraw==0] <- NA
# only keep lake-wide index for years with at least min.nmr mark-recap estimates
indxdf$n.mr <- n.mr
indxdf$indxkeep <- ifelse(indxdf$n.mr > (min.nmr - 0.5), indxdf$indxraw, NA)
indxdf$indxkeep.lo <- NA
indxdf$indxkeep.hi <- NA
# matrix of stream estimates (rows = years, columns = index streams)
streamests <- with(streamdf, tapply(COMBmr, list(year, ls), mean))
# selection of only those streams with a keepable index
selkeep <- !is.na(indxdf$indxkeep)
jack <- jackindex(streamests[selkeep, ])
indxdf$indxkeep.lo[selkeep] <- jack[, "lo"]
indxdf$indxkeep.hi[selkeep] <- jack[, "hi"]
# scale up the index to the spawner model PE
lk1 <- lk[lk$lake == streamdf$lake[1], ]
indxdf2 <- merge(lk1, indxdf, all=TRUE)
scaleup <- median(indxdf2$PE / indxdf2$indxkeep, na.rm=TRUE)
if(show) {
cat("\nindfit\n")
print(summary(indfit))
cat("\nstreamdf\n")
print(tail(streamdf[, c("lake", "year", "ls", "Emr", "CVmr", "Pmr", "COMBmr")]))
cat("\nscaleup\n")
print(scaleup)
cat("\nindxdf\n")
print(tail(indxdf[, c("lake", "year", "n.mr", "indxraw", "indxkeep", "indxkeep.lo", "indxkeep.hi")]))
}
list(indfit=indfit, streamdf=streamdf, scaleup=scaleup, indxdf=indxdf)
}
calctarg <- function(lakenum, adults, year, targyears, adjust=c(1, 1, 0.25, 1, 1)) {
# lakenum = vector of lake numbers (1-5)
# adults = vector of lakewide adult sea lamprey estimates
# year = vector of years
# targyears = list (length 5) of selected years from which to calculate targets
# lake huron target is 25% of
targets <- data.frame(lake=1:5, target=rep(NA, 5), lo=rep(NA, 5), hi=rep(NA, 5))
for(i in 1:5) {
pick5 <- adults[lakenum==i & is.element(year, targyears[[i]]) & !is.na(adults)]
if(length(pick5) > 0) {
targets$target[i] <- mean(pick5)
n <- length(pick5)
ci <- qnorm(1 - 0.05/2) * sqrt(var(pick5)) / sqrt(n)
targets[i, c("lo", "hi")] <- mean(pick5) + c(-1, 1)*ci# using z dist (known variance)
targets[i, c("target", "lo", "hi")] <- adjust[i]*targets[i, c("target", "lo", "hi")]
} else {
targets[i, c("target", "lo", "hi")] <- c(NA, NA, NA)
}
}
targets
}
}
# bring in lake-wide spawner data
lk <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/LakePEdynamic.csv", as.is=T)
# bring in stream-specific data
dat <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/StreamPEdynamicALLCOLS.csv", as.is=T)
dat$ls <- dat$lscode
# 2014-04-09 Jess and Gale agreed that the East Au Gres (38) should be replaced with the Au Sable (36) in Lake Huron
# 2014-04-10 Jess thinks that we should just stick with the East Au Gres (38)
index.streams <- list(
Sup = c(1, 2, 9, 29, 31, 32, 62),
Mic = c(5, 6, 15, 24, 26, 35),
Hur = c(10, 16, 27, 32, 999, 38),
Eri = c(1, 2, 3, 7, 9),
Ont = c(5, 9, 22, 23, 36)
)
index.streams <- lapply(1:5, function(i) i + index.streams[[i]]/1000)
# estimate adult index of abundance for each lake using index streams
indices <- lapply(index.streams, index.est, dat, lk)
# combine index data for all lakes in one dataframe
indxall <- do.call(rbind, lapply(indices, "[[", "indxdf"))
# calculate targets 
sptargyrz <- list(1994:1998, 1988:1992, 1989:1993, 1991:1995, 1999:2003)
targyrz <- apply(sapply(sptargyrz, range), 2, paste, collapse="-")
# spawner model
targets.sm <- calctarg(lakenum=lk$lake, adults=lk$PE, year=lk$year, targyears=sptargyrz)
# adult index
targets.ai <- calctarg(lakenum=indxall$lake, adults=indxall$indxkeep, year=indxall$year, targyears=sptargyrz)
# spawner model targets scaled down to adult index
targets.sm.su <- cbind(lake=targets.sm[, 1], (1/sapply(indices, "[[", "scaleup")) * targets.sm[, -1])
# adult index adjusted
targets.ai.adj <- targets.ai
targets.ai.adj[is.na(targets.ai$target), ] <- targets.sm.su[is.na(targets.ai$target), ]
YEAR1 <- 1984
# create a Word document with results
doc <- startrtf(file="2014-10 SLCB Index", dir="C:/JVA/Lamprey/Adults/AdultIndex/2014", omi=c(1, 1.25, 1, 1.25))
heading("Index of Adult Sea Lamprey Abundance in each Great Lake")
heading(paste("Adams, Barber, Bravener, Steeves -", as.character(Sys.Date())), htype=2)
### Spawner model time series
heading("Purpose of the index", htype=3)
heading("Selection of index streams", htype=3)
heading("Calculation of index", htype=3)
heading("Assumptions", htype=3)
heading("Fate of current spawner model", htype=3)
para("Conversion factors: ", paste(Lakenames, round(sapply(indices, "[[", "scaleup"), 2), collapse=", "), ".")
# position of text for selected streams in each lake (for map drawing)
posp <- list(c(3, 1, 3, 1, 1, 3, 1),
c(2, 2, 2, 2, 2, 2),
c(4, 4, 4, 4, 4, 4),
c(2, 2, 2, 2, 2),
c(2, 2, 2, 2, 2, 2))
for(i in 1:5) {
mymap <- mapL[[i]]
mystreamdf <- indices[[i]]$streamdf
myindxdf <- indices[[i]]$indxdf
mystreamdf <- mystreamdf[mystreamdf$year >= YEAR1, ]
myindxdf <- myindxdf[myindxdf$year >= YEAR1, ]
### colored table of mark-recap estimates of selected streams
m <- with(mystreamdf, tapply(Emr, list(year, substring(strname, 1, 10)), mean))
m <- m[, rev(order(apply(m, 2, median, na.rm=TRUE)))]
cols.in.table <- sapply(index.streams, length) + 1
table.width <- 6*cols.in.table/max(cols.in.table)
# add in a blurb on the model predicted values in the most recent year.
lastyear <- rev(dimnames(m)[[1]])[1]
lastrow <- m[lastyear, ]
missings <- names(lastrow[is.na(lastrow)])
misstext <- ""
if(length(missings)>0) {
preds <- with(mystreamdf, COMBmr[year==lastyear & strname %in% missings])
insert <- paste(paste(format(round(preds), big.mark=","), "for the", missings), collapse=", ")
if(length(missings)>1) {
misstext <- paste0("  In ", lastyear, ", these estimates were: ", insert, ".")
} else {
misstext <- paste0("  In ", lastyear, ", this estimate was ", insert, ".")
}
}
### barplot all PEs of index streams
col7 <- c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69")
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
fig <- function() {
plot.table(format(round(m), big.mark=","), highlight=TRUE)
}
figu("Mark-recapture estimates from Lake ", Lakenames[i], " index streams.", 
"  Colors are used to highlight quantities from low (blue) to high (orange).", 
"  Streams are ordered according to their median estimates, highest (left) to lowest (right).", 
"  Abundances in streams without valid mark-recapture estimates (white rectangles) were estimated from the mean stream PE and the mean annual pattern,",
" weighting by the inverse CV2.", misstext, figid="Table ", fign=tabcount, newpage="port", capunder=FALSE, w=table.width[i], h=7)
tabcount <- tabcount + 1
figcount <- figcount - 1
### map of selected streams
fig <- function() {
map(xlim=range(mymap$x, na.rm=T), ylim=range(mymap$y, na.rm=T), col=NA, mar=rep(1, 4))
lines(mymap$x, mymap$y, col="darkgray", lwd=0.5)
with(mystreamdf[mystreamdf$year==2010, ], {
points(long, lat, cex=1.5, pch=16)
par(xpd=NA)
text(long, lat, strname, cex=1.2, pos=posp[[i]], font=2)
})
}
figu("Streams selected for inclusion in the Lake ", Lakenames[i], " index of adult sea lamprey abundance.", h=c(3, 6, 6, 3, 3)[i], w=6)
### bar plot of individual stream PEs
fig <- function() {
par(mar=c(4, 4, 1, 1), las=1, yaxs="i", cex=1.5)
a <- barplot(t(p)/1000, las=1, col=col7, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.01*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="Year", ylab="Adult abundance  (thousands)")
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2)
box()
legend("topleft", rev(colnames(p)), fill=rev(col7))
}
figu("Adult sea lamprey abundance estimates for index streams of Lake ", Lakenames[i], ".", h=3, w=6)
### time series of PEs
fig <- function() {
par(mar=c(4, 4, 1, 1), cex=1.5, yaxs="i")
with(myindxdf, {
just <- year >= min(year[!is.na(indxkeep)])
yr <- 1.05*range(0, indxkeep.hi[just], na.rm=TRUE)/1000
plot(1, 1, xlim=range(year), ylim=yr, type="n", xlab="Year", ylab="Adults (thousands)", las=1)
arrows(year, indxkeep.lo/1000, year, indxkeep.hi/1000, length=0, angle=90, code=3, lwd=10, lend="square", col="#ffddc1")
abline(h=targets.ai.adj$target[i]/1000)
abline(h=targets.ai.adj[i, c("lo", "hi")]/1000, lty=2)
lines(year, indxkeep/1000, lwd=2, col=blindcolz[7], type="o", pch=17)
})
}
figu("Patterns over time in Lake ", Lakenames[i], " adult sea lampreys using the newly derived index.", 
"  Jackknife-type error bars for the annual abundance of adults are indicated by shaded rectangles.",
"  The index target is indicated by the horizontal line (with 95% confidence intervals).", h=3, w=6)
}
rm(mymap, mystreamdf, myindxdf, m, cols.in.table, table.width, lastrow, missings, misstext, preds, insert,
col7, p, yrz, pyrz)
### spawner model and adult index time series overlaid
fig <- function() {
par(mfrow=c(3, 2), mar=c(3, 3, 2, 3), oma=c(2, 2, 0, 0), cex=1.4, yaxs="i")
for(i in 1:5) {
mylk <- lk[lk$lake==i, ]# lake year PE lo hi
myindxdf <- indices[[i]]$indxdf# year lake indxraw n.mr indxkeep indxkeep.lo indxkeep.hi
convfac <- indices[[i]]$scaleup
x1 <- myindxdf$year
y1 <- myindxdf$indxkeep/1000
x2 <- mylk$year
y2 <- mylk$PE/convfac/1000
yr <- 1.05*range(0, y1, y2[x2>=YEAR1], na.rm=TRUE)
plot(1, 1, type="n", xlim=range(lk$year), ylim=yr, xlab="", ylab="", main=Lakenames[i], axes=FALSE)
axis(1)
axis(2, col=blindcolz[7], col.axis=blindcolz[7], las=1)
par(mgp=c(3, 2.2, 0))
axis(4, at=pretty(convfac*yr)/convfac, labels=pretty(convfac*yr), col=blindcolz[3], col.axis=blindcolz[3], las=1, hadj=1)
par(mgp=c(3, 1, 0))
box()
abline(h=targets.sm$target[i]/convfac/1000, col=blindcolz[3], lty=2)
abline(h=targets.ai.adj$target[i]/1000, col=blindcolz[7], lty=2)
lines(x2, y2, col=blindcolz[3], type="o", pch=18, lwd=2)
lines(x1, y1, col=blindcolz[7], type="o", pch=17, lwd=2)
if(i==1) {
plot(1, 1, type="n", xlab="", ylab="", axes=FALSE)
legend("center", c("Adult index", "Spawner model"), col=blindcolz[c(7, 3)], lwd=2, pch=c(17, 18))
}
}
mtext("Year", outer=TRUE, side=1, cex=1.8)
mtext("Adult abundance  (thousands)", outer=TRUE, side=2, cex=1.8)
}
figu("Patterns over time in adult sea lamprey abundance, comparing the newly derived index with the spawner model.",
"  Targets are indicated by dashed horizontal lines.",
"  Targets are based on averages from five years with historically acceptable wounding rates: ", paste(paste(targyrz, "in", Lakenames), collapse=", "), ".", 
w=6, h=7.5)
endrtf()
rm(targyrz, i)
names(indices[[1]])
# "indfit"   "streamdf" "scaleup"  "indxdf"
# scale up
round(sapply(indices, "[[", 3), 2)
# 3.84 1.85 2.82 1.01 2.40
indxall[7:11, ]
   # year lake   indxraw n.mr  indxkeep indxkeep.lo indxkeep.hi
# 7  1986    1 24275.673    5 24275.673   18726.753   27579.203
# 8  1987    1 10994.483    5 10994.483   10269.609   11494.884
# 9  1988    1 13630.037    5 13630.037   11710.612   14680.398
# 10 1989    1 20227.926    6 20227.926   18704.166   21988.594
# 11 1990    1  9332.001    5  9332.001    8435.646   11991.514
# C:\JVA\Lamprey\Adults\AdultIndex\2014\AdultIndex v2.r
{ # functions
# the following seven plot.table related function are from the Systmatic Investor Toolbox
# load Systematic Investor Toolbox
# require(RCurl)
# sit = getURLContent("https://github.com/systematicinvestor/SIT/raw/master/sit.gz", binary=TRUE, followlocation=TRUE, ssl.verifypeer=FALSE)
# con = gzcon(rawConnection(sit, "rb"))
# source(con)
# close(con)
draw.cell <- function(title, r, c, text.cex = 1, bg.col = 'white', frame.cell = T) {
if(!frame.cell) bcol = bg.col else bcol = 'black'
rect((2*(c - 1) + .5), -(r - .5), (2*c + .5), -(r + .5), col = bg.col, border = bcol)
if( c == 1) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else if( r == 1 ) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else {
text((2*c + .5), -r, title, adj = 1, cex = text.cex)
}
}
plot.table.helper.auto.adjust.cex <- function(temp.table, keep.all.same.cex = FALSE) {
nr = nrow(temp.table)
nc = ncol(temp.table)
all.xrange = diff(par()$usr[1:2]) / nc
xrange = matrix( strwidth(paste('  ', temp.table), units = 'user', cex = 1), nc = nc)
all.yrange = diff(par()$usr[3:4]) / nr
yrange = matrix( 5/3 * strheight(temp.table, units = 'user', cex = 1), nc = nc)
plot.matrix.cex = pmin( round(all.yrange / yrange, 2) , round(all.xrange / xrange, 2) )
header.col.cex = min(plot.matrix.cex[1,-1])
header.row.cex = min(plot.matrix.cex[-1,1])
title.cex = plot.matrix.cex[1, 1]
data.cex = min(plot.matrix.cex[-1, -1])
if ( keep.all.same.cex ) {
plot.matrix.cex[] = min(plot.matrix.cex)
} else {
plot.matrix.cex[1,-1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,-1]= min(c(header.col.cex, header.row.cex, data.cex))
plot.matrix.cex[1,1]= min(c(header.col.cex, header.row.cex, data.cex, title.cex))
plot.matrix.cex[1,-1] = min(c(header.col.cex))
plot.matrix.cex[-1,1] = min(c(header.row.cex))
plot.matrix.cex[-1,-1]= min(c(data.cex))
plot.matrix.cex[1,1]= min(c(title.cex))
}
return(plot.matrix.cex)
}
make.table <- function(nr, nc) {
savepar = par(mar = rep(1, 4))
plot(c(0.5, nc*2 + 0.5), c(-0.5, -(nr + 0.5)), xaxs = 'i', yaxs = 'i',
type = 'n', xlab = '', ylab = '', axes = FALSE)
savepar
}
trim <- function(s) {
s = sub(pattern = '^ +', replacement = '', x = s)
s = sub(pattern = ' +$', replacement = '', x = s)
return(s)
}
plot.table.param <- function(plot.matrix, smain = '', plot.matrix.cex, plot.matrix_bg.col, frame.cell = T, keep.all.same.cex = FALSE) {
n = nrow(plot.matrix)
pages = unique(c(seq(0, n, by = 120), n))
for(p in 1:(length(pages)-1)) {
rindex = (pages[p]+1) : pages[p+1]
temp.table = matrix('', nr = length(rindex)+1, nc = ncol(plot.matrix)+1)
temp.table[-1, -1] = plot.matrix[rindex,]
temp.table[1, -1] = colnames(plot.matrix)
temp.table[-1, 1] = rownames(plot.matrix)[rindex]
temp.table[1, 1] = smain
nr = nrow(temp.table)
nc = ncol(temp.table)
par(mar = c(0, 0, 0, 0), cex = 0.5)
oldpar = make.table(nr, nc)
text.cex = plot.matrix.cex[c(1, 1 + rindex), ]
text.cex = plot.table.helper.auto.adjust.cex(temp.table, keep.all.same.cex)
bg.col = plot.matrix_bg.col[c(1, 1 + rindex), ]
for(r in 1:nr) {
for(c in 1:nc) {
draw.cell( paste('', temp.table[r,c], '', sep=' '), r, c,
text.cex = text.cex[r,c], bg.col = bg.col[r,c], frame.cell = frame.cell)
}}
}
}
plot.table <- function(plot.matrix, smain="", text.cex=1, frame.cell=TRUE, highlight=FALSE, colorbar=FALSE, keep_all.same.cex=FALSE) {
if( is.null(rownames(plot.matrix)) & is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
if( ncol(temp.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[-1, -1, drop = FALSE]
colnames(plot.matrix) = temp.matrix[1, -1]
rownames(plot.matrix) = temp.matrix[-1, 1]
smain = temp.matrix[1, 1]
} else if( is.null(rownames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( ncol(plot.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[, -1, drop = FALSE]
colnames(plot.matrix) = colnames(temp.matrix)[-1]
rownames(plot.matrix) = temp.matrix[,1]
smain = colnames(temp.matrix)[1]
} else if( is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
plot.matrix = temp.matrix[-1, , drop = FALSE]
rownames(plot.matrix) = rownames(temp.matrix)[-1]
colnames(plot.matrix) = temp.matrix[1, ]
smain = rownames(temp.matrix)[1]
}
plot.matrix[which(trim(plot.matrix) == "NA")] = ""
plot.matrix[which(trim(plot.matrix) == "NA%")] = ""
plot.matrix[which(is.na(plot.matrix))] = ""
nr = nrow(plot.matrix) + 1
nc = ncol(plot.matrix) + 1
is_highlight = TRUE
if(is.logical(highlight)) {
is_highlight = highlight
if(highlight) highlight = plot.table.helper.color(plot.matrix)
}
if(!is_highlight) {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[seq(1, nr, 2), ] = "yellow"
plot.matrix_bg.col[1,] = "gray";
plot.table.param( plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
} else {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[1,] = "gray"
plot.matrix_bg.col[2:nr,2:nc] = highlight
plot.table.param(plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
}
}
plot.table.helper.color <- function (temp) {
temp = matrix(as.double(gsub("[%,$]", "", temp)), nrow(temp), ncol(temp))
highlight = as.vector(temp)
cols = rep(NA, length(highlight))
ncols = length(highlight[!is.na(highlight)])
cols[1:ncols] = rev(rainbow(ncols, start=0.5/6, end=3.5/6))
o = sort.list(highlight, na.last = TRUE, decreasing = FALSE)
o1 = sort.list(o, na.last = TRUE, decreasing = FALSE)
highlight = matrix(cols[o1], nrow = nrow(temp))
highlight[is.na(temp)] = NA
return(highlight)
}
ModelEst <- function(fit, df) {
# derive regression estimates from log(y) fit
mse <- rev(as.matrix(summary(fit)[[1]])[, "Mean Sq"])[1]
plpe <- predict(fit, newdata=df, se.fit=T)
m <- plpe$fit
v <- plpe$se.fit^2 + mse
exp(m + v/2)
}
myrange <- function(x) {
if(all(is.na(x))) r <- c(NA, NA) else r <- range(x, na.rm=TRUE)
return(r)
}
jackindex <- function(m) {
# m is a matrix of numbers (stream PEs) with observations (years) as rows and individuals (streams) as columns
if(any(is.na(m))) stop("The input matrix may not have any missing values.")
# calculate the index as the sum of the columns for each row
rowsum <- apply(m, 1, sum)
# calculate the mean of the index
avgind <- mean(rowsum)
# recalculate the index, leaving out one individual at a time
loo <- apply(m, 2, function(column) (rowsum - column))
# rescale the loo index, relative to mean
looscaled <- apply(loo, 2, function(x) x/mean(x))
# convert to original scale
looscaled2 <- looscaled * avgind
# calculate range
ranges <- t(apply(looscaled2, 1, range))
cbind(index=rowsum, lo=ranges[, 1], hi=ranges[, 2])
}
# selstreams <- index.streams[[1]] 
# allstreamdf <- dat
# alllakedf <- lk 
# min.nmr=2 
# show=FALSE
index.est <- function(selstreams, allstreamdf, alllakedf, min.nmr=2, show=FALSE) {
# INDEX OF ADULT SEA LAMPREY ABUNDANCE
### INPUTS
# selstreams = vector of stream ids, e.g., 1.064 (lake + strcode/1000)
# allstreamdf = data frame of mark-recap estimates for all streams, with vars:  year lake ls Emr CVmr
# alllakedf = data frame of lake-wide PEs from Mullett et al. (2003) spawner model with vars:  lake year PE
# min.nmr = minimum number of mark-recapture estimates needed in a year to generate an index, default 2
# show = print out a brief summary of the results, default FALSE
### OUTPUTS
# indfit = simple model used to predict missing mark-recap estimates
# streamdf = original allstreamdf, subsetted by selstreams, with estimates for missing mark-recaps
# indxdf = original alllakedf, subsetted by lake, with annual index, including raw (indxraw), kept based on min.nmr (indxkeep, indxkeep.lo, indxkeep.hi)
# scaleup = conversion factor used to scale up annual index to spawner model PE
streamdf <- allstreamdf[allstreamdf$ls %in% selstreams, ]
# error checks
check1 <- var(streamdf$lake)
if(is.na(check1) | is.null(check1)) stop("Either no streams selected or critical data missing.") else if(check1 > 0) stop("Selected streams should be only from ONE lake.")
if(any(is.na(match(c("year", "lake", "ls", "Emr", "CVmr"), names(allstreamdf))))) stop("allstreamdf must include these variables: year lake ls Emr CVmr.")
if(any(is.na(match(c("year", "lake", "PE"), names(alllakedf))))) stop("alllakedf must include these variables: lake year PE.")
# fill in missing mark-recap data
indfit <- aov(log(Emr) ~ as.factor(ls) + as.factor(year), data=streamdf, weights=1/CVmr^2)
# figure out estimable years (those with at least 1 m-r estimate)
n.mr <- tapply(!is.na(streamdf$Emr), streamdf$year, sum)
eyrs <- as.numeric(names(n.mr)[n.mr > 0.5])
estimable <- streamdf$year %in% eyrs
streamdf$Pmr <- NA
streamdf$Pmr[estimable] <- ModelEst(fit=indfit, df=streamdf[estimable, ])
streamdf$COMBmr <- ifelse(is.na(streamdf$Emr), streamdf$Pmr, streamdf$Emr)
# annual index (sum across streams)
indxdf <- aggregate(COMBmr ~ year + lake, streamdf, sum, na.rm=TRUE, na.action=na.pass)
names(indxdf)[names(indxdf)=="COMBmr"] <- "indxraw"
indxdf$indxraw[indxdf$indxraw==0] <- NA
# only keep lake-wide index for years with at least min.nmr mark-recap estimates
indxdf$n.mr <- n.mr
indxdf$indxkeep <- ifelse(indxdf$n.mr > (min.nmr - 0.5), indxdf$indxraw, NA)
indxdf$indxkeep.lo <- NA
indxdf$indxkeep.hi <- NA
# matrix of stream estimates (rows = years, columns = index streams)
streamests <- with(streamdf, tapply(COMBmr, list(year, ls), mean))
# selection of only those streams with a keepable index
selkeep <- !is.na(indxdf$indxkeep)
jack <- jackindex(streamests[selkeep, ])
indxdf$indxkeep.lo[selkeep] <- jack[, "lo"]
indxdf$indxkeep.hi[selkeep] <- jack[, "hi"]
# scale up the index to the spawner model PE
lk1 <- lk[lk$lake == streamdf$lake[1], ]
indxdf2 <- merge(lk1, indxdf, all=TRUE)
scaleup <- median(indxdf2$PE / indxdf2$indxkeep, na.rm=TRUE)
if(show) {
cat("\nindfit\n")
print(summary(indfit))
cat("\nstreamdf\n")
print(tail(streamdf[, c("lake", "year", "ls", "Emr", "CVmr", "Pmr", "COMBmr")]))
cat("\nscaleup\n")
print(scaleup)
cat("\nindxdf\n")
print(tail(indxdf[, c("lake", "year", "n.mr", "indxraw", "indxkeep", "indxkeep.lo", "indxkeep.hi")]))
}
list(indfit=indfit, streamdf=streamdf, scaleup=scaleup, indxdf=indxdf)
}
calctarg <- function(lakenum, adults, year, targyears, adjust=c(1, 1, 0.25, 1, 1)) {
# lakenum = vector of lake numbers (1-5)
# adults = vector of lakewide adult sea lamprey estimates
# year = vector of years
# targyears = list (length 5) of selected years from which to calculate targets
# lake huron target is 25% of
targets <- data.frame(lake=1:5, target=rep(NA, 5), lo=rep(NA, 5), hi=rep(NA, 5))
for(i in 1:5) {
pick5 <- adults[lakenum==i & is.element(year, targyears[[i]]) & !is.na(adults)]
if(length(pick5) > 0) {
targets$target[i] <- mean(pick5)
n <- length(pick5)
ci <- qnorm(1 - 0.05/2) * sqrt(var(pick5)) / sqrt(n)
targets[i, c("lo", "hi")] <- mean(pick5) + c(-1, 1)*ci# using z dist (known variance)
targets[i, c("target", "lo", "hi")] <- adjust[i]*targets[i, c("target", "lo", "hi")]
} else {
targets[i, c("target", "lo", "hi")] <- c(NA, NA, NA)
}
}
targets
}
}
# bring in lake-wide spawner data
lk <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/LakePEdynamic.csv", as.is=T)
# bring in stream-specific data
dat <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/StreamPEdynamicALLCOLS.csv", as.is=T)
dat$ls <- dat$lscode
# 2014-04-09 Jess and Gale agreed that the East Au Gres (38) should be replaced with the Au Sable (36) in Lake Huron
# 2014-04-10 Jess thinks that we should just stick with the East Au Gres (38)
index.streams <- list(
Sup = c(1, 2, 9, 29, 31, 32, 62),
Mic = c(5, 6, 15, 24, 26, 35),
Hur = c(10, 16, 27, 32, 999, 38),
Eri = c(1, 2, 3, 7, 9),
Ont = c(5, 9, 22, 23, 36)
)
index.streams <- lapply(1:5, function(i) i + index.streams[[i]]/1000)
# estimate adult index of abundance for each lake using index streams
indices <- lapply(index.streams, index.est, dat, lk)
# combine index data for all lakes in one dataframe
indxall <- do.call(rbind, lapply(indices, "[[", "indxdf"))
# calculate targets 
sptargyrz <- list(1994:1998, 1988:1992, 1989:1993, 1991:1995, 1999:2003)
targyrz <- apply(sapply(sptargyrz, range), 2, paste, collapse="-")
# spawner model
targets.sm <- calctarg(lakenum=lk$lake, adults=lk$PE, year=lk$year, targyears=sptargyrz)
# adult index
targets.ai <- calctarg(lakenum=indxall$lake, adults=indxall$indxkeep, year=indxall$year, targyears=sptargyrz)
# spawner model targets scaled down to adult index
targets.sm.su <- cbind(lake=targets.sm[, 1], (1/sapply(indices, "[[", "scaleup")) * targets.sm[, -1])
# adult index adjusted
targets.ai.adj <- targets.ai
targets.ai.adj[is.na(targets.ai$target), ] <- targets.sm.su[is.na(targets.ai$target), ]
YEAR1 <- 1984
# create a Word document with results
doc <- startrtf(file="2014-10 SLCB Index", dir="C:/JVA/Lamprey/Adults/AdultIndex/2014", omi=c(1, 1.25, 1, 1.25))
heading("Index of Adult Sea Lamprey Abundance in each Great Lake")
heading(paste("Adams, Barber, Bravener, Steeves -", as.character(Sys.Date())), htype=2)
### Spawner model time series
heading("Purpose of the index", htype=3)
heading("Selection of index streams", htype=3)
heading("Calculation of index", htype=3)
heading("Assumptions", htype=3)
heading("Fate of current spawner model", htype=3)
para("Conversion factors: ", paste(Lakenames, round(sapply(indices, "[[", "scaleup"), 2), collapse=", "), ".")
# position of text for selected streams in each lake (for map drawing)
posp <- list(c(3, 1, 3, 1, 1, 3, 1),
c(2, 2, 2, 2, 2, 2),
c(4, 4, 4, 4, 4, 4),
c(2, 2, 2, 2, 2),
c(2, 2, 2, 2, 2, 2))
for(i in 1:5) {
mymap <- mapL[[i]]
mystreamdf <- indices[[i]]$streamdf
myindxdf <- indices[[i]]$indxdf
mystreamdf <- mystreamdf[mystreamdf$year >= YEAR1, ]
myindxdf <- myindxdf[myindxdf$year >= YEAR1, ]
### map of selected streams
fig <- function() {
map(xlim=range(mymap$x, na.rm=T), ylim=range(mymap$y, na.rm=T), col=NA, mar=rep(1, 4))
lines(mymap$x, mymap$y, col="darkgray", lwd=0.5)
with(mystreamdf[mystreamdf$year==2010, ], {
points(long, lat, cex=1.5, pch=16)
par(xpd=NA)
text(long, lat, strname, cex=1.2, pos=posp[[i]], font=2)
})
}
figu("Streams selected for inclusion in the Lake ", Lakenames[i], " index of adult sea lamprey abundance.", h=c(3, 6, 6, 3, 3)[i], w=6)
### colored table of mark-recap estimates of selected streams
m <- with(mystreamdf, tapply(Emr, list(year, substring(strname, 1, 10)), mean))
m <- m[, rev(order(apply(m, 2, median, na.rm=TRUE)))]
cols.in.table <- sapply(index.streams, length) + 1
table.width <- 6*cols.in.table/max(cols.in.table)
# add in a blurb on the model predicted values in the most recent year.
lastyear <- rev(dimnames(m)[[1]])[1]
lastrow <- m[lastyear, ]
missings <- names(lastrow[is.na(lastrow)])
misstext <- ""
if(length(missings)>0) {
preds <- with(mystreamdf, COMBmr[year==lastyear & strname %in% missings])
insert <- paste(paste(format(round(preds), big.mark=","), "for the", missings), collapse=", ")
if(length(missings)>1) {
misstext <- paste0("  In ", lastyear, ", these estimates were: ", insert, ".")
} else {
misstext <- paste0("  In ", lastyear, ", this estimate was ", insert, ".")
}
}
fig <- function() {
plot.table(format(round(m), big.mark=","), highlight=TRUE)
}
figu("Mark-recapture estimates from Lake ", Lakenames[i], " index streams.", 
"  Colors are used to highlight quantities from low (blue) to high (orange).", 
"  Streams are ordered according to their median estimates, highest (left) to lowest (right).", 
"  Abundances in streams without valid mark-recapture estimates (white rectangles) were estimated from the mean stream PE and the mean annual pattern,",
" weighting by the inverse CV2.", misstext, figid="Table ", fign=tabcount, newpage="port", capunder=FALSE, w=table.width[i], h=7)
tabcount <- tabcount + 1
figcount <- figcount - 1
### bar plot of individual index stream PEs
col7 <- c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69")
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
fig <- function() {
par(mar=c(4, 4, 1, 1), las=1, yaxs="i", cex=1.5)
a <- barplot(t(p)/1000, las=1, col=col7, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.01*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="Year", ylab="Adult abundance  (thousands)")
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2)
box()
legend("topleft", rev(colnames(p)), fill=rev(col7), cex=1)
}
figu("Adult sea lamprey abundance estimates for index streams of Lake ", Lakenames[i], ".", h=4.2, w=6)
### time series of PEs
fig <- function() {
par(mar=c(4, 4, 1, 1), cex=1.5, yaxs="i")
with(myindxdf, {
just <- year >= min(year[!is.na(indxkeep)])
yr <- 1.05*range(0, indxkeep.hi[just], na.rm=TRUE)/1000
plot(1, 1, xlim=range(year), ylim=yr, type="n", xlab="Year", ylab="Adults (thousands)", las=1)
arrows(year, indxkeep.lo/1000, year, indxkeep.hi/1000, length=0, angle=90, code=3, lwd=10, lend="square", col="#ffddc1")
abline(h=targets.ai.adj$target[i]/1000)
abline(h=targets.ai.adj[i, c("lo", "hi")]/1000, lty=2)
lines(year, indxkeep/1000, lwd=2, col=blindcolz[7], type="o", pch=17)
})
}
figu("Patterns over time in Lake ", Lakenames[i], " adult sea lampreys using the newly derived index.", 
"  Jackknife-type error bars for the annual abundance of adults are indicated by shaded rectangles.",
"  The index target is indicated by the horizontal line (with 95% confidence intervals).", h=3, w=6)
}
rm(mymap, mystreamdf, myindxdf, m, cols.in.table, table.width, lastrow, missings, misstext, preds, insert,
col7, p, yrz, pyrz)
### spawner model and adult index time series overlaid
fig <- function() {
par(mfrow=c(3, 2), mar=c(3, 3, 2, 3), oma=c(2, 2, 0, 0), cex=1.4, yaxs="i")
for(i in 1:5) {
mylk <- lk[lk$lake==i, ]# lake year PE lo hi
myindxdf <- indices[[i]]$indxdf# year lake indxraw n.mr indxkeep indxkeep.lo indxkeep.hi
convfac <- indices[[i]]$scaleup
x1 <- myindxdf$year
y1 <- myindxdf$indxkeep/1000
x2 <- mylk$year
y2 <- mylk$PE/convfac/1000
yr <- 1.05*range(0, y1, y2[x2>=YEAR1], na.rm=TRUE)
plot(1, 1, type="n", xlim=range(lk$year), ylim=yr, xlab="", ylab="", main=Lakenames[i], axes=FALSE)
axis(1)
axis(2, col=blindcolz[7], col.axis=blindcolz[7], las=1)
par(mgp=c(3, 2.2, 0))
axis(4, at=pretty(convfac*yr)/convfac, labels=pretty(convfac*yr), col=blindcolz[3], col.axis=blindcolz[3], las=1, hadj=1)
par(mgp=c(3, 1, 0))
box()
abline(h=targets.sm$target[i]/convfac/1000, col=blindcolz[3], lty=2)
abline(h=targets.ai.adj$target[i]/1000, col=blindcolz[7], lty=2)
lines(x2, y2, col=blindcolz[3], type="o", pch=18, lwd=2)
lines(x1, y1, col=blindcolz[7], type="o", pch=17, lwd=2)
if(i==1) {
plot(1, 1, type="n", xlab="", ylab="", axes=FALSE)
legend("center", c("Adult index", "Spawner model"), col=blindcolz[c(7, 3)], lwd=2, pch=c(17, 18))
}
}
mtext("Year", outer=TRUE, side=1, cex=1.8)
mtext("Adult abundance  (thousands)", outer=TRUE, side=2, cex=1.8)
}
figu("Patterns over time in adult sea lamprey abundance, comparing the newly derived index with the spawner model.",
"  Targets are indicated by dashed horizontal lines.",
"  Targets are based on averages from five years with historically acceptable wounding rates: ", paste(paste(targyrz, "in", Lakenames), collapse=", "), ".", 
w=6, h=7.5)
endrtf()
rm(targyrz, i)
names(indices[[1]])
# "indfit"   "streamdf" "scaleup"  "indxdf"
# scale up
round(sapply(indices, "[[", 3), 2)
# 3.84 1.85 2.82 1.01 2.40
indxall[7:11, ]
   # year lake   indxraw n.mr  indxkeep indxkeep.lo indxkeep.hi
# 7  1986    1 24275.673    5 24275.673   18726.753   27579.203
# 8  1987    1 10994.483    5 10994.483   10269.609   11494.884
# 9  1988    1 13630.037    5 13630.037   11710.612   14680.398
# 10 1989    1 20227.926    6 20227.926   18704.166   21988.594
# 11 1990    1  9332.001    5  9332.001    8435.646   11991.514
indxkeep
# C:\JVA\Lamprey\Adults\AdultIndex\2014\AdultIndex v2.r
{ # functions
# the following seven plot.table related function are from the Systmatic Investor Toolbox
# load Systematic Investor Toolbox
# require(RCurl)
# sit = getURLContent("https://github.com/systematicinvestor/SIT/raw/master/sit.gz", binary=TRUE, followlocation=TRUE, ssl.verifypeer=FALSE)
# con = gzcon(rawConnection(sit, "rb"))
# source(con)
# close(con)
draw.cell <- function(title, r, c, text.cex = 1, bg.col = 'white', frame.cell = T) {
if(!frame.cell) bcol = bg.col else bcol = 'black'
rect((2*(c - 1) + .5), -(r - .5), (2*c + .5), -(r + .5), col = bg.col, border = bcol)
if( c == 1) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else if( r == 1 ) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else {
text((2*c + .5), -r, title, adj = 1, cex = text.cex)
}
}
plot.table.helper.auto.adjust.cex <- function(temp.table, keep.all.same.cex = FALSE) {
nr = nrow(temp.table)
nc = ncol(temp.table)
all.xrange = diff(par()$usr[1:2]) / nc
xrange = matrix( strwidth(paste('  ', temp.table), units = 'user', cex = 1), nc = nc)
all.yrange = diff(par()$usr[3:4]) / nr
yrange = matrix( 5/3 * strheight(temp.table, units = 'user', cex = 1), nc = nc)
plot.matrix.cex = pmin( round(all.yrange / yrange, 2) , round(all.xrange / xrange, 2) )
header.col.cex = min(plot.matrix.cex[1,-1])
header.row.cex = min(plot.matrix.cex[-1,1])
title.cex = plot.matrix.cex[1, 1]
data.cex = min(plot.matrix.cex[-1, -1])
if ( keep.all.same.cex ) {
plot.matrix.cex[] = min(plot.matrix.cex)
} else {
plot.matrix.cex[1,-1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,-1]= min(c(header.col.cex, header.row.cex, data.cex))
plot.matrix.cex[1,1]= min(c(header.col.cex, header.row.cex, data.cex, title.cex))
plot.matrix.cex[1,-1] = min(c(header.col.cex))
plot.matrix.cex[-1,1] = min(c(header.row.cex))
plot.matrix.cex[-1,-1]= min(c(data.cex))
plot.matrix.cex[1,1]= min(c(title.cex))
}
return(plot.matrix.cex)
}
make.table <- function(nr, nc) {
savepar = par(mar = rep(1, 4))
plot(c(0.5, nc*2 + 0.5), c(-0.5, -(nr + 0.5)), xaxs = 'i', yaxs = 'i',
type = 'n', xlab = '', ylab = '', axes = FALSE)
savepar
}
trim <- function(s) {
s = sub(pattern = '^ +', replacement = '', x = s)
s = sub(pattern = ' +$', replacement = '', x = s)
return(s)
}
plot.table.param <- function(plot.matrix, smain = '', plot.matrix.cex, plot.matrix_bg.col, frame.cell = T, keep.all.same.cex = FALSE) {
n = nrow(plot.matrix)
pages = unique(c(seq(0, n, by = 120), n))
for(p in 1:(length(pages)-1)) {
rindex = (pages[p]+1) : pages[p+1]
temp.table = matrix('', nr = length(rindex)+1, nc = ncol(plot.matrix)+1)
temp.table[-1, -1] = plot.matrix[rindex,]
temp.table[1, -1] = colnames(plot.matrix)
temp.table[-1, 1] = rownames(plot.matrix)[rindex]
temp.table[1, 1] = smain
nr = nrow(temp.table)
nc = ncol(temp.table)
par(mar = c(0, 0, 0, 0), cex = 0.5)
oldpar = make.table(nr, nc)
text.cex = plot.matrix.cex[c(1, 1 + rindex), ]
text.cex = plot.table.helper.auto.adjust.cex(temp.table, keep.all.same.cex)
bg.col = plot.matrix_bg.col[c(1, 1 + rindex), ]
for(r in 1:nr) {
for(c in 1:nc) {
draw.cell( paste('', temp.table[r,c], '', sep=' '), r, c,
text.cex = text.cex[r,c], bg.col = bg.col[r,c], frame.cell = frame.cell)
}}
}
}
plot.table <- function(plot.matrix, smain="", text.cex=1, frame.cell=TRUE, highlight=FALSE, colorbar=FALSE, keep_all.same.cex=FALSE) {
if( is.null(rownames(plot.matrix)) & is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
if( ncol(temp.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[-1, -1, drop = FALSE]
colnames(plot.matrix) = temp.matrix[1, -1]
rownames(plot.matrix) = temp.matrix[-1, 1]
smain = temp.matrix[1, 1]
} else if( is.null(rownames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( ncol(plot.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[, -1, drop = FALSE]
colnames(plot.matrix) = colnames(temp.matrix)[-1]
rownames(plot.matrix) = temp.matrix[,1]
smain = colnames(temp.matrix)[1]
} else if( is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
plot.matrix = temp.matrix[-1, , drop = FALSE]
rownames(plot.matrix) = rownames(temp.matrix)[-1]
colnames(plot.matrix) = temp.matrix[1, ]
smain = rownames(temp.matrix)[1]
}
plot.matrix[which(trim(plot.matrix) == "NA")] = ""
plot.matrix[which(trim(plot.matrix) == "NA%")] = ""
plot.matrix[which(is.na(plot.matrix))] = ""
nr = nrow(plot.matrix) + 1
nc = ncol(plot.matrix) + 1
is_highlight = TRUE
if(is.logical(highlight)) {
is_highlight = highlight
if(highlight) highlight = plot.table.helper.color(plot.matrix)
}
if(!is_highlight) {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[seq(1, nr, 2), ] = "yellow"
plot.matrix_bg.col[1,] = "gray";
plot.table.param( plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
} else {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[1,] = "gray"
plot.matrix_bg.col[2:nr,2:nc] = highlight
plot.table.param(plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
}
}
plot.table.helper.color <- function (temp) {
temp = matrix(as.double(gsub("[%,$]", "", temp)), nrow(temp), ncol(temp))
highlight = as.vector(temp)
cols = rep(NA, length(highlight))
ncols = length(highlight[!is.na(highlight)])
cols[1:ncols] = rev(rainbow(ncols, start=0.5/6, end=3.5/6))
o = sort.list(highlight, na.last = TRUE, decreasing = FALSE)
o1 = sort.list(o, na.last = TRUE, decreasing = FALSE)
highlight = matrix(cols[o1], nrow = nrow(temp))
highlight[is.na(temp)] = NA
return(highlight)
}
ModelEst <- function(fit, df) {
# derive regression estimates from log(y) fit
mse <- rev(as.matrix(summary(fit)[[1]])[, "Mean Sq"])[1]
plpe <- predict(fit, newdata=df, se.fit=T)
m <- plpe$fit
v <- plpe$se.fit^2 + mse
exp(m + v/2)
}
myrange <- function(x) {
if(all(is.na(x))) r <- c(NA, NA) else r <- range(x, na.rm=TRUE)
return(r)
}
jackindex <- function(m) {
# m is a matrix of numbers (stream PEs) with observations (years) as rows and individuals (streams) as columns
if(any(is.na(m))) stop("The input matrix may not have any missing values.")
# calculate the index as the sum of the columns for each row
rowsum <- apply(m, 1, sum)
# calculate the mean of the index
avgind <- mean(rowsum)
# recalculate the index, leaving out one individual at a time
loo <- apply(m, 2, function(column) (rowsum - column))
# rescale the loo index, relative to mean
looscaled <- apply(loo, 2, function(x) x/mean(x))
# convert to original scale
looscaled2 <- looscaled * avgind
# calculate range
ranges <- t(apply(looscaled2, 1, range))
cbind(index=rowsum, lo=ranges[, 1], hi=ranges[, 2])
}
# selstreams <- index.streams[[1]] 
# allstreamdf <- dat
# alllakedf <- lk 
# min.nmr=2 
# show=FALSE
index.est <- function(selstreams, allstreamdf, alllakedf, min.nmr=2, show=FALSE) {
# INDEX OF ADULT SEA LAMPREY ABUNDANCE
### INPUTS
# selstreams = vector of stream ids, e.g., 1.064 (lake + strcode/1000)
# allstreamdf = data frame of mark-recap estimates for all streams, with vars:  year lake ls Emr CVmr
# alllakedf = data frame of lake-wide PEs from Mullett et al. (2003) spawner model with vars:  lake year PE
# min.nmr = minimum number of mark-recapture estimates needed in a year to generate an index, default 2
# show = print out a brief summary of the results, default FALSE
### OUTPUTS
# indfit = simple model used to predict missing mark-recap estimates
# streamdf = original allstreamdf, subsetted by selstreams, with estimates for missing mark-recaps
# indxdf = original alllakedf, subsetted by lake, with annual index, including raw (indxraw), kept based on min.nmr (indxkeep, indxkeep.lo, indxkeep.hi)
# scaleup = conversion factor used to scale up annual index to spawner model PE
streamdf <- allstreamdf[allstreamdf$ls %in% selstreams, ]
# error checks
check1 <- var(streamdf$lake)
if(is.na(check1) | is.null(check1)) stop("Either no streams selected or critical data missing.") else if(check1 > 0) stop("Selected streams should be only from ONE lake.")
if(any(is.na(match(c("year", "lake", "ls", "Emr", "CVmr"), names(allstreamdf))))) stop("allstreamdf must include these variables: year lake ls Emr CVmr.")
if(any(is.na(match(c("year", "lake", "PE"), names(alllakedf))))) stop("alllakedf must include these variables: lake year PE.")
# fill in missing mark-recap data
indfit <- aov(log(Emr) ~ as.factor(ls) + as.factor(year), data=streamdf, weights=1/CVmr^2)
# figure out estimable years (those with at least 1 m-r estimate)
n.mr <- tapply(!is.na(streamdf$Emr), streamdf$year, sum)
eyrs <- as.numeric(names(n.mr)[n.mr > 0.5])
estimable <- streamdf$year %in% eyrs
streamdf$Pmr <- NA
streamdf$Pmr[estimable] <- ModelEst(fit=indfit, df=streamdf[estimable, ])
streamdf$COMBmr <- ifelse(is.na(streamdf$Emr), streamdf$Pmr, streamdf$Emr)
# annual index (sum across streams)
indxdf <- aggregate(COMBmr ~ year + lake, streamdf, sum, na.rm=TRUE, na.action=na.pass)
names(indxdf)[names(indxdf)=="COMBmr"] <- "indxraw"
indxdf$indxraw[indxdf$indxraw==0] <- NA
# only keep lake-wide index for years with at least min.nmr mark-recap estimates
indxdf$n.mr <- n.mr
indxdf$indxkeep <- ifelse(indxdf$n.mr > (min.nmr - 0.5), indxdf$indxraw, NA)
indxdf$indxkeep.lo <- NA
indxdf$indxkeep.hi <- NA
# matrix of stream estimates (rows = years, columns = index streams)
streamests <- with(streamdf, tapply(COMBmr, list(year, ls), mean))
# selection of only those streams with a keepable index
selkeep <- !is.na(indxdf$indxkeep)
jack <- jackindex(streamests[selkeep, ])
indxdf$indxkeep.lo[selkeep] <- jack[, "lo"]
indxdf$indxkeep.hi[selkeep] <- jack[, "hi"]
# scale up the index to the spawner model PE
lk1 <- lk[lk$lake == streamdf$lake[1], ]
indxdf2 <- merge(lk1, indxdf, all=TRUE)
scaleup <- median(indxdf2$PE / indxdf2$indxkeep, na.rm=TRUE)
if(show) {
cat("\nindfit\n")
print(summary(indfit))
cat("\nstreamdf\n")
print(tail(streamdf[, c("lake", "year", "ls", "Emr", "CVmr", "Pmr", "COMBmr")]))
cat("\nscaleup\n")
print(scaleup)
cat("\nindxdf\n")
print(tail(indxdf[, c("lake", "year", "n.mr", "indxraw", "indxkeep", "indxkeep.lo", "indxkeep.hi")]))
}
list(indfit=indfit, streamdf=streamdf, scaleup=scaleup, indxdf=indxdf)
}
calctarg <- function(lakenum, adults, year, targyears, adjust=c(1, 1, 0.25, 1, 1)) {
# lakenum = vector of lake numbers (1-5)
# adults = vector of lakewide adult sea lamprey estimates
# year = vector of years
# targyears = list (length 5) of selected years from which to calculate targets
# lake huron target is 25% of
targets <- data.frame(lake=1:5, target=rep(NA, 5), lo=rep(NA, 5), hi=rep(NA, 5))
for(i in 1:5) {
pick5 <- adults[lakenum==i & is.element(year, targyears[[i]]) & !is.na(adults)]
if(length(pick5) > 0) {
targets$target[i] <- mean(pick5)
n <- length(pick5)
ci <- qnorm(1 - 0.05/2) * sqrt(var(pick5)) / sqrt(n)
targets[i, c("lo", "hi")] <- mean(pick5) + c(-1, 1)*ci# using z dist (known variance)
targets[i, c("target", "lo", "hi")] <- adjust[i]*targets[i, c("target", "lo", "hi")]
} else {
targets[i, c("target", "lo", "hi")] <- c(NA, NA, NA)
}
}
targets
}
}
# bring in lake-wide spawner data
lk <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/LakePEdynamic.csv", as.is=T)
# bring in stream-specific data
dat <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/StreamPEdynamicALLCOLS.csv", as.is=T)
dat$ls <- dat$lscode
# 2014-04-09 Jess and Gale agreed that the East Au Gres (38) should be replaced with the Au Sable (36) in Lake Huron
# 2014-04-10 Jess thinks that we should just stick with the East Au Gres (38)
index.streams <- list(
Sup = c(1, 2, 9, 29, 31, 32, 62),
Mic = c(5, 6, 15, 24, 26, 35),
Hur = c(10, 16, 27, 32, 999, 38),
Eri = c(1, 2, 3, 7, 9),
Ont = c(5, 9, 22, 23, 36)
)
index.streams <- lapply(1:5, function(i) i + index.streams[[i]]/1000)
# estimate adult index of abundance for each lake using index streams
indices <- lapply(index.streams, index.est, dat, lk)
# combine index data for all lakes in one dataframe
indxall <- do.call(rbind, lapply(indices, "[[", "indxdf"))
# calculate targets 
sptargyrz <- list(1994:1998, 1988:1992, 1989:1993, 1991:1995, 1999:2003)
targyrz <- apply(sapply(sptargyrz, range), 2, paste, collapse="-")
# spawner model
targets.sm <- calctarg(lakenum=lk$lake, adults=lk$PE, year=lk$year, targyears=sptargyrz)
# adult index
targets.ai <- calctarg(lakenum=indxall$lake, adults=indxall$indxkeep, year=indxall$year, targyears=sptargyrz)
# spawner model targets scaled down to adult index
targets.sm.su <- cbind(lake=targets.sm[, 1], (1/sapply(indices, "[[", "scaleup")) * targets.sm[, -1])
# adult index adjusted
targets.ai.adj <- targets.ai
targets.ai.adj[is.na(targets.ai$target), ] <- targets.sm.su[is.na(targets.ai$target), ]
YEAR1 <- 1984
# create a Word document with results
doc <- startrtf(file="2014-10 SLCB Index", dir="C:/JVA/Lamprey/Adults/AdultIndex/2014", omi=c(1, 1.25, 1, 1.25))
heading("Index of Adult Sea Lamprey Abundance in each Great Lake")
heading(paste("Adams, Barber, Bravener, Steeves -", as.character(Sys.Date())), htype=2)
### Spawner model time series
heading("Purpose of the index", htype=3)
heading("Selection of index streams", htype=3)
heading("Calculation of index", htype=3)
heading("Assumptions", htype=3)
heading("Fate of current spawner model", htype=3)
para("Conversion factors: ", paste(Lakenames, round(sapply(indices, "[[", "scaleup"), 2), collapse=", "), ".")
# position of text for selected streams in each lake (for map drawing)
posp <- list(c(3, 1, 3, 1, 1, 3, 1),
c(2, 2, 2, 2, 2, 2),
c(4, 4, 4, 4, 4, 4),
c(2, 2, 2, 2, 2),
c(2, 2, 2, 2, 2, 2))
i <- 4
mymap <- mapL[[i]]
mystreamdf <- indices[[i]]$streamdf
myindxdf <- indices[[i]]$indxdf
mystreamdf <- mystreamdf[mystreamdf$year >= YEAR1, ]
myindxdf <- myindxdf[myindxdf$year >= YEAR1, ]
### map of selected streams
fig <- function() {
map(xlim=range(mymap$x, na.rm=T), ylim=range(mymap$y, na.rm=T), col=NA, mar=rep(1, 4))
lines(mymap$x, mymap$y, col="darkgray", lwd=0.5)
with(mystreamdf[mystreamdf$year==2010, ], {
points(long, lat, cex=1.5, pch=16)
par(xpd=NA)
text(long, lat, strname, cex=1.2, pos=posp[[i]], font=2)
})
}
figu("Streams selected for inclusion in the Lake ", Lakenames[i], " index of adult sea lamprey abundance.", h=c(3, 6, 6, 3, 3)[i], w=6)
### colored table of mark-recap estimates of selected streams
m <- with(mystreamdf, tapply(Emr, list(year, substring(strname, 1, 10)), mean))
m <- m[, rev(order(apply(m, 2, median, na.rm=TRUE)))]
cols.in.table <- sapply(index.streams, length) + 1
table.width <- 6*cols.in.table/max(cols.in.table)
# add in a blurb on the model predicted values in the most recent year.
lastyear <- rev(dimnames(m)[[1]])[1]
lastrow <- m[lastyear, ]
missings <- names(lastrow[is.na(lastrow)])
misstext <- ""
if(length(missings)>0) {
preds <- with(mystreamdf, COMBmr[year==lastyear & strname %in% missings])
insert <- paste(paste(format(round(preds), big.mark=","), "for the", missings), collapse=", ")
if(length(missings)>1) {
misstext <- paste0("  In ", lastyear, ", these estimates were: ", insert, ".")
} else {
misstext <- paste0("  In ", lastyear, ", this estimate was ", insert, ".")
}
}
fig <- function() {
plot.table(format(round(m), big.mark=","), highlight=TRUE)
}
figu("Mark-recapture estimates from Lake ", Lakenames[i], " index streams.", 
"  Colors are used to highlight quantities from low (blue) to high (orange).", 
"  Streams are ordered according to their median estimates, highest (left) to lowest (right).", 
"  Abundances in streams without valid mark-recapture estimates (white rectangles) were estimated from the mean stream PE and the mean annual pattern,",
" weighting by the inverse CV2.", misstext, figid="Table ", fign=tabcount, newpage="port", capunder=FALSE, w=table.width[i], h=7)
tabcount <- tabcount + 1
figcount <- figcount - 1
indxkeep
myindex
myindxdf$indxkeep
p
### bar plot of individual index stream PEs
col7 <- c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69")
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
p
p[is.na(myindxdf$indxkeep), ] <- NA
p
### bar plot of individual index stream PEs
col7 <- c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69")
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p[is.na(myindxdf$indxkeep), ] <- NA
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
fig <- function() {
par(mar=c(4, 4, 1, 1), las=1, yaxs="i", cex=1.5)
a <- barplot(t(p)/1000, las=1, col=col7, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.01*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="Year", ylab="Adult abundance  (thousands)")
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2)
box()
legend("topleft", rev(colnames(p)), fill=rev(col7), cex=0.8)
}
fig()
search()
cleanup()
graphics.off()
# C:\JVA\Lamprey\Adults\AdultIndex\2014\AdultIndex v2.r
{ # functions
# the following seven plot.table related function are from the Systmatic Investor Toolbox
# load Systematic Investor Toolbox
# require(RCurl)
# sit = getURLContent("https://github.com/systematicinvestor/SIT/raw/master/sit.gz", binary=TRUE, followlocation=TRUE, ssl.verifypeer=FALSE)
# con = gzcon(rawConnection(sit, "rb"))
# source(con)
# close(con)
draw.cell <- function(title, r, c, text.cex = 1, bg.col = 'white', frame.cell = T) {
if(!frame.cell) bcol = bg.col else bcol = 'black'
rect((2*(c - 1) + .5), -(r - .5), (2*c + .5), -(r + .5), col = bg.col, border = bcol)
if( c == 1) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else if( r == 1 ) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else {
text((2*c + .5), -r, title, adj = 1, cex = text.cex)
}
}
plot.table.helper.auto.adjust.cex <- function(temp.table, keep.all.same.cex = FALSE) {
nr = nrow(temp.table)
nc = ncol(temp.table)
all.xrange = diff(par()$usr[1:2]) / nc
xrange = matrix( strwidth(paste('  ', temp.table), units = 'user', cex = 1), nc = nc)
all.yrange = diff(par()$usr[3:4]) / nr
yrange = matrix( 5/3 * strheight(temp.table, units = 'user', cex = 1), nc = nc)
plot.matrix.cex = pmin( round(all.yrange / yrange, 2) , round(all.xrange / xrange, 2) )
header.col.cex = min(plot.matrix.cex[1,-1])
header.row.cex = min(plot.matrix.cex[-1,1])
title.cex = plot.matrix.cex[1, 1]
data.cex = min(plot.matrix.cex[-1, -1])
if ( keep.all.same.cex ) {
plot.matrix.cex[] = min(plot.matrix.cex)
} else {
plot.matrix.cex[1,-1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,-1]= min(c(header.col.cex, header.row.cex, data.cex))
plot.matrix.cex[1,1]= min(c(header.col.cex, header.row.cex, data.cex, title.cex))
plot.matrix.cex[1,-1] = min(c(header.col.cex))
plot.matrix.cex[-1,1] = min(c(header.row.cex))
plot.matrix.cex[-1,-1]= min(c(data.cex))
plot.matrix.cex[1,1]= min(c(title.cex))
}
return(plot.matrix.cex)
}
make.table <- function(nr, nc) {
savepar = par(mar = rep(1, 4))
plot(c(0.5, nc*2 + 0.5), c(-0.5, -(nr + 0.5)), xaxs = 'i', yaxs = 'i',
type = 'n', xlab = '', ylab = '', axes = FALSE)
savepar
}
trim <- function(s) {
s = sub(pattern = '^ +', replacement = '', x = s)
s = sub(pattern = ' +$', replacement = '', x = s)
return(s)
}
plot.table.param <- function(plot.matrix, smain = '', plot.matrix.cex, plot.matrix_bg.col, frame.cell = T, keep.all.same.cex = FALSE) {
n = nrow(plot.matrix)
pages = unique(c(seq(0, n, by = 120), n))
for(p in 1:(length(pages)-1)) {
rindex = (pages[p]+1) : pages[p+1]
temp.table = matrix('', nr = length(rindex)+1, nc = ncol(plot.matrix)+1)
temp.table[-1, -1] = plot.matrix[rindex,]
temp.table[1, -1] = colnames(plot.matrix)
temp.table[-1, 1] = rownames(plot.matrix)[rindex]
temp.table[1, 1] = smain
nr = nrow(temp.table)
nc = ncol(temp.table)
par(mar = c(0, 0, 0, 0), cex = 0.5)
oldpar = make.table(nr, nc)
text.cex = plot.matrix.cex[c(1, 1 + rindex), ]
text.cex = plot.table.helper.auto.adjust.cex(temp.table, keep.all.same.cex)
bg.col = plot.matrix_bg.col[c(1, 1 + rindex), ]
for(r in 1:nr) {
for(c in 1:nc) {
draw.cell( paste('', temp.table[r,c], '', sep=' '), r, c,
text.cex = text.cex[r,c], bg.col = bg.col[r,c], frame.cell = frame.cell)
}}
}
}
plot.table <- function(plot.matrix, smain="", text.cex=1, frame.cell=TRUE, highlight=FALSE, colorbar=FALSE, keep_all.same.cex=FALSE) {
if( is.null(rownames(plot.matrix)) & is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
if( ncol(temp.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[-1, -1, drop = FALSE]
colnames(plot.matrix) = temp.matrix[1, -1]
rownames(plot.matrix) = temp.matrix[-1, 1]
smain = temp.matrix[1, 1]
} else if( is.null(rownames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( ncol(plot.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[, -1, drop = FALSE]
colnames(plot.matrix) = colnames(temp.matrix)[-1]
rownames(plot.matrix) = temp.matrix[,1]
smain = colnames(temp.matrix)[1]
} else if( is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
plot.matrix = temp.matrix[-1, , drop = FALSE]
rownames(plot.matrix) = rownames(temp.matrix)[-1]
colnames(plot.matrix) = temp.matrix[1, ]
smain = rownames(temp.matrix)[1]
}
plot.matrix[which(trim(plot.matrix) == "NA")] = ""
plot.matrix[which(trim(plot.matrix) == "NA%")] = ""
plot.matrix[which(is.na(plot.matrix))] = ""
nr = nrow(plot.matrix) + 1
nc = ncol(plot.matrix) + 1
is_highlight = TRUE
if(is.logical(highlight)) {
is_highlight = highlight
if(highlight) highlight = plot.table.helper.color(plot.matrix)
}
if(!is_highlight) {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[seq(1, nr, 2), ] = "yellow"
plot.matrix_bg.col[1,] = "gray";
plot.table.param( plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
} else {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[1,] = "gray"
plot.matrix_bg.col[2:nr,2:nc] = highlight
plot.table.param(plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
}
}
plot.table.helper.color <- function (temp) {
temp = matrix(as.double(gsub("[%,$]", "", temp)), nrow(temp), ncol(temp))
highlight = as.vector(temp)
cols = rep(NA, length(highlight))
ncols = length(highlight[!is.na(highlight)])
cols[1:ncols] = rev(rainbow(ncols, start=0.5/6, end=3.5/6))
o = sort.list(highlight, na.last = TRUE, decreasing = FALSE)
o1 = sort.list(o, na.last = TRUE, decreasing = FALSE)
highlight = matrix(cols[o1], nrow = nrow(temp))
highlight[is.na(temp)] = NA
return(highlight)
}
ModelEst <- function(fit, df) {
# derive regression estimates from log(y) fit
mse <- rev(as.matrix(summary(fit)[[1]])[, "Mean Sq"])[1]
plpe <- predict(fit, newdata=df, se.fit=T)
m <- plpe$fit
v <- plpe$se.fit^2 + mse
exp(m + v/2)
}
myrange <- function(x) {
if(all(is.na(x))) r <- c(NA, NA) else r <- range(x, na.rm=TRUE)
return(r)
}
jackindex <- function(m) {
# m is a matrix of numbers (stream PEs) with observations (years) as rows and individuals (streams) as columns
if(any(is.na(m))) stop("The input matrix may not have any missing values.")
# calculate the index as the sum of the columns for each row
rowsum <- apply(m, 1, sum)
# calculate the mean of the index
avgind <- mean(rowsum)
# recalculate the index, leaving out one individual at a time
loo <- apply(m, 2, function(column) (rowsum - column))
# rescale the loo index, relative to mean
looscaled <- apply(loo, 2, function(x) x/mean(x))
# convert to original scale
looscaled2 <- looscaled * avgind
# calculate range
ranges <- t(apply(looscaled2, 1, range))
cbind(index=rowsum, lo=ranges[, 1], hi=ranges[, 2])
}
# selstreams <- index.streams[[1]] 
# allstreamdf <- dat
# alllakedf <- lk 
# min.nmr=2 
# show=FALSE
index.est <- function(selstreams, allstreamdf, alllakedf, min.nmr=2, show=FALSE) {
# INDEX OF ADULT SEA LAMPREY ABUNDANCE
### INPUTS
# selstreams = vector of stream ids, e.g., 1.064 (lake + strcode/1000)
# allstreamdf = data frame of mark-recap estimates for all streams, with vars:  year lake ls Emr CVmr
# alllakedf = data frame of lake-wide PEs from Mullett et al. (2003) spawner model with vars:  lake year PE
# min.nmr = minimum number of mark-recapture estimates needed in a year to generate an index, default 2
# show = print out a brief summary of the results, default FALSE
### OUTPUTS
# indfit = simple model used to predict missing mark-recap estimates
# streamdf = original allstreamdf, subsetted by selstreams, with estimates for missing mark-recaps
# indxdf = original alllakedf, subsetted by lake, with annual index, including raw (indxraw), kept based on min.nmr (indxkeep, indxkeep.lo, indxkeep.hi)
# scaleup = conversion factor used to scale up annual index to spawner model PE
streamdf <- allstreamdf[allstreamdf$ls %in% selstreams, ]
# error checks
check1 <- var(streamdf$lake)
if(is.na(check1) | is.null(check1)) stop("Either no streams selected or critical data missing.") else if(check1 > 0) stop("Selected streams should be only from ONE lake.")
if(any(is.na(match(c("year", "lake", "ls", "Emr", "CVmr"), names(allstreamdf))))) stop("allstreamdf must include these variables: year lake ls Emr CVmr.")
if(any(is.na(match(c("year", "lake", "PE"), names(alllakedf))))) stop("alllakedf must include these variables: lake year PE.")
# fill in missing mark-recap data
indfit <- aov(log(Emr) ~ as.factor(ls) + as.factor(year), data=streamdf, weights=1/CVmr^2)
# figure out estimable years (those with at least 1 m-r estimate)
n.mr <- tapply(!is.na(streamdf$Emr), streamdf$year, sum)
eyrs <- as.numeric(names(n.mr)[n.mr > 0.5])
estimable <- streamdf$year %in% eyrs
streamdf$Pmr <- NA
streamdf$Pmr[estimable] <- ModelEst(fit=indfit, df=streamdf[estimable, ])
streamdf$COMBmr <- ifelse(is.na(streamdf$Emr), streamdf$Pmr, streamdf$Emr)
# annual index (sum across streams)
indxdf <- aggregate(COMBmr ~ year + lake, streamdf, sum, na.rm=TRUE, na.action=na.pass)
names(indxdf)[names(indxdf)=="COMBmr"] <- "indxraw"
indxdf$indxraw[indxdf$indxraw==0] <- NA
# only keep lake-wide index for years with at least min.nmr mark-recap estimates
indxdf$n.mr <- n.mr
indxdf$indxkeep <- ifelse(indxdf$n.mr > (min.nmr - 0.5), indxdf$indxraw, NA)
indxdf$indxkeep.lo <- NA
indxdf$indxkeep.hi <- NA
# matrix of stream estimates (rows = years, columns = index streams)
streamests <- with(streamdf, tapply(COMBmr, list(year, ls), mean))
# selection of only those streams with a keepable index
selkeep <- !is.na(indxdf$indxkeep)
jack <- jackindex(streamests[selkeep, ])
indxdf$indxkeep.lo[selkeep] <- jack[, "lo"]
indxdf$indxkeep.hi[selkeep] <- jack[, "hi"]
# scale up the index to the spawner model PE
lk1 <- lk[lk$lake == streamdf$lake[1], ]
indxdf2 <- merge(lk1, indxdf, all=TRUE)
scaleup <- median(indxdf2$PE / indxdf2$indxkeep, na.rm=TRUE)
if(show) {
cat("\nindfit\n")
print(summary(indfit))
cat("\nstreamdf\n")
print(tail(streamdf[, c("lake", "year", "ls", "Emr", "CVmr", "Pmr", "COMBmr")]))
cat("\nscaleup\n")
print(scaleup)
cat("\nindxdf\n")
print(tail(indxdf[, c("lake", "year", "n.mr", "indxraw", "indxkeep", "indxkeep.lo", "indxkeep.hi")]))
}
list(indfit=indfit, streamdf=streamdf, scaleup=scaleup, indxdf=indxdf)
}
calctarg <- function(lakenum, adults, year, targyears, adjust=c(1, 1, 0.25, 1, 1)) {
# lakenum = vector of lake numbers (1-5)
# adults = vector of lakewide adult sea lamprey estimates
# year = vector of years
# targyears = list (length 5) of selected years from which to calculate targets
# lake huron target is 25% of
targets <- data.frame(lake=1:5, target=rep(NA, 5), lo=rep(NA, 5), hi=rep(NA, 5))
for(i in 1:5) {
pick5 <- adults[lakenum==i & is.element(year, targyears[[i]]) & !is.na(adults)]
if(length(pick5) > 0) {
targets$target[i] <- mean(pick5)
n <- length(pick5)
ci <- qnorm(1 - 0.05/2) * sqrt(var(pick5)) / sqrt(n)
targets[i, c("lo", "hi")] <- mean(pick5) + c(-1, 1)*ci# using z dist (known variance)
targets[i, c("target", "lo", "hi")] <- adjust[i]*targets[i, c("target", "lo", "hi")]
} else {
targets[i, c("target", "lo", "hi")] <- c(NA, NA, NA)
}
}
targets
}
}
# bring in lake-wide spawner data
lk <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/LakePEdynamic.csv", as.is=T)
# bring in stream-specific data
dat <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/StreamPEdynamicALLCOLS.csv", as.is=T)
dat$ls <- dat$lscode
# 2014-04-09 Jess and Gale agreed that the East Au Gres (38) should be replaced with the Au Sable (36) in Lake Huron
# 2014-04-10 Jess thinks that we should just stick with the East Au Gres (38)
index.streams <- list(
Sup = c(1, 2, 9, 29, 31, 32, 62),
Mic = c(5, 6, 15, 24, 26, 35),
Hur = c(10, 16, 27, 32, 999, 38),
Eri = c(1, 2, 3, 7, 9),
Ont = c(5, 9, 22, 23, 36)
)
index.streams <- lapply(1:5, function(i) i + index.streams[[i]]/1000)
# estimate adult index of abundance for each lake using index streams
indices <- lapply(index.streams, index.est, dat, lk)
# combine index data for all lakes in one dataframe
indxall <- do.call(rbind, lapply(indices, "[[", "indxdf"))
# calculate targets 
sptargyrz <- list(1994:1998, 1988:1992, 1989:1993, 1991:1995, 1999:2003)
targyrz <- apply(sapply(sptargyrz, range), 2, paste, collapse="-")
# spawner model
targets.sm <- calctarg(lakenum=lk$lake, adults=lk$PE, year=lk$year, targyears=sptargyrz)
# adult index
targets.ai <- calctarg(lakenum=indxall$lake, adults=indxall$indxkeep, year=indxall$year, targyears=sptargyrz)
# spawner model targets scaled down to adult index
targets.sm.su <- cbind(lake=targets.sm[, 1], (1/sapply(indices, "[[", "scaleup")) * targets.sm[, -1])
# adult index adjusted
targets.ai.adj <- targets.ai
targets.ai.adj[is.na(targets.ai$target), ] <- targets.sm.su[is.na(targets.ai$target), ]
YEAR1 <- 1984
# create a Word document with results
doc <- startrtf(file="2014-10 SLCB Index", dir="C:/JVA/Lamprey/Adults/AdultIndex/2014", omi=c(1, 1.25, 1, 1.25))
heading("Index of Adult Sea Lamprey Abundance in each Great Lake")
heading(paste("Adams, Barber, Bravener, Steeves -", as.character(Sys.Date())), htype=2)
### Spawner model time series
heading("Purpose of the index", htype=3)
heading("Selection of index streams", htype=3)
heading("Calculation of index", htype=3)
heading("Assumptions", htype=3)
heading("Fate of current spawner model", htype=3)
para("Conversion factors: ", paste(Lakenames, round(sapply(indices, "[[", "scaleup"), 2), collapse=", "), ".")
# position of text for selected streams in each lake (for map drawing)
posp <- list(c(3, 1, 3, 1, 1, 3, 1),
c(2, 2, 2, 2, 2, 2),
c(4, 4, 4, 4, 4, 4),
c(2, 2, 2, 2, 2),
c(2, 2, 2, 2, 2, 2))
for(i in 1:5) {
mymap <- mapL[[i]]
mystreamdf <- indices[[i]]$streamdf
myindxdf <- indices[[i]]$indxdf
mystreamdf <- mystreamdf[mystreamdf$year >= YEAR1, ]
myindxdf <- myindxdf[myindxdf$year >= YEAR1, ]
### map of selected streams
fig <- function() {
map(xlim=range(mymap$x, na.rm=T), ylim=range(mymap$y, na.rm=T), col=NA, mar=rep(1, 4))
lines(mymap$x, mymap$y, col="darkgray", lwd=0.5)
with(mystreamdf[mystreamdf$year==2010, ], {
points(long, lat, cex=1.5, pch=16)
par(xpd=NA)
text(long, lat, strname, cex=1.2, pos=posp[[i]], font=2)
})
}
figu("Streams selected for inclusion in the Lake ", Lakenames[i], " index of adult sea lamprey abundance.", h=c(3, 6, 6, 3, 3)[i], w=6)
### colored table of mark-recap estimates of selected streams
m <- with(mystreamdf, tapply(Emr, list(year, substring(strname, 1, 10)), mean))
m <- m[, rev(order(apply(m, 2, median, na.rm=TRUE)))]
cols.in.table <- sapply(index.streams, length) + 1
table.width <- 6*cols.in.table/max(cols.in.table)
# add in a blurb on the model predicted values in the most recent year.
lastyear <- rev(dimnames(m)[[1]])[1]
lastrow <- m[lastyear, ]
missings <- names(lastrow[is.na(lastrow)])
misstext <- ""
if(length(missings)>0) {
preds <- with(mystreamdf, COMBmr[year==lastyear & strname %in% missings])
insert <- paste(paste(format(round(preds), big.mark=","), "for the", missings), collapse=", ")
if(length(missings)>1) {
misstext <- paste0("  In ", lastyear, ", these estimates were: ", insert, ".")
} else {
misstext <- paste0("  In ", lastyear, ", this estimate was ", insert, ".")
}
}
fig <- function() {
plot.table(format(round(m), big.mark=","), highlight=TRUE)
}
figu("Mark-recapture estimates from Lake ", Lakenames[i], " index streams.", 
"  Colors are used to highlight quantities from low (blue) to high (orange).", 
"  Streams are ordered according to their median estimates, highest (left) to lowest (right).", 
"  Abundances in streams without valid mark-recapture estimates (white rectangles) were estimated from the mean stream PE and the mean annual pattern,",
" weighting by the inverse CV2.", misstext, figid="Table ", fign=tabcount, newpage="port", capunder=FALSE, w=table.width[i], h=7)
tabcount <- tabcount + 1
figcount <- figcount - 1
### bar plot of individual index stream PEs
col7 <- c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69")
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p[is.na(myindxdf$indxkeep), ] <- NA
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
fig <- function() {
par(mar=c(4, 4, 1, 1), las=1, yaxs="i", cex=1.5)
a <- barplot(t(p)/1000, las=1, col=col7, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.01*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="Year", ylab="Adult abundance  (thousands)")
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2)
box()
legend("topleft", rev(colnames(p)), fill=rev(col7), cex=0.8)
}
figu("Adult sea lamprey abundance estimates for index streams of Lake ", Lakenames[i], ".", h=4.2, w=6)
### time series of PEs
fig <- function() {
par(mar=c(4, 4, 1, 1), cex=1.5, yaxs="i")
with(myindxdf, {
just <- year >= min(year[!is.na(indxkeep)])
yr <- 1.05*range(0, indxkeep.hi[just], na.rm=TRUE)/1000
plot(1, 1, xlim=range(year), ylim=yr, type="n", xlab="Year", ylab="Adults (thousands)", las=1)
arrows(year, indxkeep.lo/1000, year, indxkeep.hi/1000, length=0, angle=90, code=3, lwd=10, lend="square", col="#ffddc1")
abline(h=targets.ai.adj$target[i]/1000)
abline(h=targets.ai.adj[i, c("lo", "hi")]/1000, lty=2)
lines(year, indxkeep/1000, lwd=2, col=blindcolz[7], type="o", pch=17)
})
}
figu("Patterns over time in Lake ", Lakenames[i], " adult sea lampreys using the newly derived index.", 
"  Jackknife-type error bars for the annual abundance of adults are indicated by shaded rectangles.",
"  The index target is indicated by the horizontal line (with 95% confidence intervals).", h=3, w=6)
}
rm(mymap, mystreamdf, myindxdf, m, cols.in.table, table.width, lastrow, missings, misstext, preds, insert,
col7, p, yrz, pyrz)
### spawner model and adult index time series overlaid
fig <- function() {
par(mfrow=c(3, 2), mar=c(3, 3, 2, 3), oma=c(2, 2, 0, 0), cex=1.4, yaxs="i")
for(i in 1:5) {
mylk <- lk[lk$lake==i, ]# lake year PE lo hi
myindxdf <- indices[[i]]$indxdf# year lake indxraw n.mr indxkeep indxkeep.lo indxkeep.hi
convfac <- indices[[i]]$scaleup
x1 <- myindxdf$year
y1 <- myindxdf$indxkeep/1000
x2 <- mylk$year
y2 <- mylk$PE/convfac/1000
yr <- 1.05*range(0, y1, y2[x2>=YEAR1], na.rm=TRUE)
plot(1, 1, type="n", xlim=range(lk$year), ylim=yr, xlab="", ylab="", main=Lakenames[i], axes=FALSE)
axis(1)
axis(2, col=blindcolz[7], col.axis=blindcolz[7], las=1)
par(mgp=c(3, 2.2, 0))
axis(4, at=pretty(convfac*yr)/convfac, labels=pretty(convfac*yr), col=blindcolz[3], col.axis=blindcolz[3], las=1, hadj=1)
par(mgp=c(3, 1, 0))
box()
abline(h=targets.sm$target[i]/convfac/1000, col=blindcolz[3], lty=2)
abline(h=targets.ai.adj$target[i]/1000, col=blindcolz[7], lty=2)
lines(x2, y2, col=blindcolz[3], type="o", pch=18, lwd=2)
lines(x1, y1, col=blindcolz[7], type="o", pch=17, lwd=2)
if(i==1) {
plot(1, 1, type="n", xlab="", ylab="", axes=FALSE)
legend("center", c("Adult index", "Spawner model"), col=blindcolz[c(7, 3)], lwd=2, pch=c(17, 18))
}
}
mtext("Year", outer=TRUE, side=1, cex=1.8)
mtext("Adult abundance  (thousands)", outer=TRUE, side=2, cex=1.8)
}
figu("Patterns over time in adult sea lamprey abundance, comparing the newly derived index with the spawner model.",
"  Targets are indicated by dashed horizontal lines.",
"  Targets are based on averages from five years with historically acceptable wounding rates: ", paste(paste(targyrz, "in", Lakenames), collapse=", "), ".", 
w=6, h=7.5)
endrtf()
rm(targyrz, i)
names(indices[[1]])
# "indfit"   "streamdf" "scaleup"  "indxdf"
# scale up
round(sapply(indices, "[[", 3), 2)
# 3.84 1.85 2.82 1.01 2.40
indxall[7:11, ]
   # year lake   indxraw n.mr  indxkeep indxkeep.lo indxkeep.hi
# 7  1986    1 24275.673    5 24275.673   18726.753   27579.203
# 8  1987    1 10994.483    5 10994.483   10269.609   11494.884
# 9  1988    1 13630.037    5 13630.037   11710.612   14680.398
# 10 1989    1 20227.926    6 20227.926   18704.166   21988.594
# 11 1990    1  9332.001    5  9332.001    8435.646   11991.514
# C:\JVA\Lamprey\Adults\AdultIndex\2014\AdultIndex v2.r
{ # functions
# the following seven plot.table related function are from the Systmatic Investor Toolbox
# load Systematic Investor Toolbox
# require(RCurl)
# sit = getURLContent("https://github.com/systematicinvestor/SIT/raw/master/sit.gz", binary=TRUE, followlocation=TRUE, ssl.verifypeer=FALSE)
# con = gzcon(rawConnection(sit, "rb"))
# source(con)
# close(con)
draw.cell <- function(title, r, c, text.cex = 1, bg.col = 'white', frame.cell = T) {
if(!frame.cell) bcol = bg.col else bcol = 'black'
rect((2*(c - 1) + .5), -(r - .5), (2*c + .5), -(r + .5), col = bg.col, border = bcol)
if( c == 1) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else if( r == 1 ) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else {
text((2*c + .5), -r, title, adj = 1, cex = text.cex)
}
}
plot.table.helper.auto.adjust.cex <- function(temp.table, keep.all.same.cex = FALSE) {
nr = nrow(temp.table)
nc = ncol(temp.table)
all.xrange = diff(par()$usr[1:2]) / nc
xrange = matrix( strwidth(paste('  ', temp.table), units = 'user', cex = 1), nc = nc)
all.yrange = diff(par()$usr[3:4]) / nr
yrange = matrix( 5/3 * strheight(temp.table, units = 'user', cex = 1), nc = nc)
plot.matrix.cex = pmin( round(all.yrange / yrange, 2) , round(all.xrange / xrange, 2) )
header.col.cex = min(plot.matrix.cex[1,-1])
header.row.cex = min(plot.matrix.cex[-1,1])
title.cex = plot.matrix.cex[1, 1]
data.cex = min(plot.matrix.cex[-1, -1])
if ( keep.all.same.cex ) {
plot.matrix.cex[] = min(plot.matrix.cex)
} else {
plot.matrix.cex[1,-1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,-1]= min(c(header.col.cex, header.row.cex, data.cex))
plot.matrix.cex[1,1]= min(c(header.col.cex, header.row.cex, data.cex, title.cex))
plot.matrix.cex[1,-1] = min(c(header.col.cex))
plot.matrix.cex[-1,1] = min(c(header.row.cex))
plot.matrix.cex[-1,-1]= min(c(data.cex))
plot.matrix.cex[1,1]= min(c(title.cex))
}
return(plot.matrix.cex)
}
make.table <- function(nr, nc) {
savepar = par(mar = rep(1, 4))
plot(c(0.5, nc*2 + 0.5), c(-0.5, -(nr + 0.5)), xaxs = 'i', yaxs = 'i',
type = 'n', xlab = '', ylab = '', axes = FALSE)
savepar
}
trim <- function(s) {
s = sub(pattern = '^ +', replacement = '', x = s)
s = sub(pattern = ' +$', replacement = '', x = s)
return(s)
}
plot.table.param <- function(plot.matrix, smain = '', plot.matrix.cex, plot.matrix_bg.col, frame.cell = T, keep.all.same.cex = FALSE) {
n = nrow(plot.matrix)
pages = unique(c(seq(0, n, by = 120), n))
for(p in 1:(length(pages)-1)) {
rindex = (pages[p]+1) : pages[p+1]
temp.table = matrix('', nr = length(rindex)+1, nc = ncol(plot.matrix)+1)
temp.table[-1, -1] = plot.matrix[rindex,]
temp.table[1, -1] = colnames(plot.matrix)
temp.table[-1, 1] = rownames(plot.matrix)[rindex]
temp.table[1, 1] = smain
nr = nrow(temp.table)
nc = ncol(temp.table)
par(mar = c(0, 0, 0, 0), cex = 0.5)
oldpar = make.table(nr, nc)
text.cex = plot.matrix.cex[c(1, 1 + rindex), ]
text.cex = plot.table.helper.auto.adjust.cex(temp.table, keep.all.same.cex)
bg.col = plot.matrix_bg.col[c(1, 1 + rindex), ]
for(r in 1:nr) {
for(c in 1:nc) {
draw.cell( paste('', temp.table[r,c], '', sep=' '), r, c,
text.cex = text.cex[r,c], bg.col = bg.col[r,c], frame.cell = frame.cell)
}}
}
}
plot.table <- function(plot.matrix, smain="", text.cex=1, frame.cell=TRUE, highlight=FALSE, colorbar=FALSE, keep_all.same.cex=FALSE) {
if( is.null(rownames(plot.matrix)) & is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
if( ncol(temp.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[-1, -1, drop = FALSE]
colnames(plot.matrix) = temp.matrix[1, -1]
rownames(plot.matrix) = temp.matrix[-1, 1]
smain = temp.matrix[1, 1]
} else if( is.null(rownames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( ncol(plot.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[, -1, drop = FALSE]
colnames(plot.matrix) = colnames(temp.matrix)[-1]
rownames(plot.matrix) = temp.matrix[,1]
smain = colnames(temp.matrix)[1]
} else if( is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
plot.matrix = temp.matrix[-1, , drop = FALSE]
rownames(plot.matrix) = rownames(temp.matrix)[-1]
colnames(plot.matrix) = temp.matrix[1, ]
smain = rownames(temp.matrix)[1]
}
plot.matrix[which(trim(plot.matrix) == "NA")] = ""
plot.matrix[which(trim(plot.matrix) == "NA%")] = ""
plot.matrix[which(is.na(plot.matrix))] = ""
nr = nrow(plot.matrix) + 1
nc = ncol(plot.matrix) + 1
is_highlight = TRUE
if(is.logical(highlight)) {
is_highlight = highlight
if(highlight) highlight = plot.table.helper.color(plot.matrix)
}
if(!is_highlight) {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[seq(1, nr, 2), ] = "yellow"
plot.matrix_bg.col[1,] = "gray";
plot.table.param( plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
} else {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[1,] = "gray"
plot.matrix_bg.col[2:nr,2:nc] = highlight
plot.table.param(plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
}
}
plot.table.helper.color <- function (temp) {
temp = matrix(as.double(gsub("[%,$]", "", temp)), nrow(temp), ncol(temp))
highlight = as.vector(temp)
cols = rep(NA, length(highlight))
ncols = length(highlight[!is.na(highlight)])
cols[1:ncols] = rev(rainbow(ncols, start=0.5/6, end=3.5/6))
o = sort.list(highlight, na.last = TRUE, decreasing = FALSE)
o1 = sort.list(o, na.last = TRUE, decreasing = FALSE)
highlight = matrix(cols[o1], nrow = nrow(temp))
highlight[is.na(temp)] = NA
return(highlight)
}
ModelEst <- function(fit, df) {
# derive regression estimates from log(y) fit
mse <- rev(as.matrix(summary(fit)[[1]])[, "Mean Sq"])[1]
plpe <- predict(fit, newdata=df, se.fit=T)
m <- plpe$fit
v <- plpe$se.fit^2 + mse
exp(m + v/2)
}
myrange <- function(x) {
if(all(is.na(x))) r <- c(NA, NA) else r <- range(x, na.rm=TRUE)
return(r)
}
jackindex <- function(m) {
# m is a matrix of numbers (stream PEs) with observations (years) as rows and individuals (streams) as columns
if(any(is.na(m))) stop("The input matrix may not have any missing values.")
# calculate the index as the sum of the columns for each row
rowsum <- apply(m, 1, sum)
# calculate the mean of the index
avgind <- mean(rowsum)
# recalculate the index, leaving out one individual at a time
loo <- apply(m, 2, function(column) (rowsum - column))
# rescale the loo index, relative to mean
looscaled <- apply(loo, 2, function(x) x/mean(x))
# convert to original scale
looscaled2 <- looscaled * avgind
# calculate range
ranges <- t(apply(looscaled2, 1, range))
cbind(index=rowsum, lo=ranges[, 1], hi=ranges[, 2])
}
# selstreams <- index.streams[[1]] 
# allstreamdf <- dat
# alllakedf <- lk 
# min.nmr=2 
# show=FALSE
index.est <- function(selstreams, allstreamdf, alllakedf, min.nmr=2, show=FALSE) {
# INDEX OF ADULT SEA LAMPREY ABUNDANCE
### INPUTS
# selstreams = vector of stream ids, e.g., 1.064 (lake + strcode/1000)
# allstreamdf = data frame of mark-recap estimates for all streams, with vars:  year lake ls Emr CVmr
# alllakedf = data frame of lake-wide PEs from Mullett et al. (2003) spawner model with vars:  lake year PE
# min.nmr = minimum number of mark-recapture estimates needed in a year to generate an index, default 2
# show = print out a brief summary of the results, default FALSE
### OUTPUTS
# indfit = simple model used to predict missing mark-recap estimates
# streamdf = original allstreamdf, subsetted by selstreams, with estimates for missing mark-recaps
# indxdf = original alllakedf, subsetted by lake, with annual index, including raw (indxraw), kept based on min.nmr (indxkeep, indxkeep.lo, indxkeep.hi)
# scaleup = conversion factor used to scale up annual index to spawner model PE
streamdf <- allstreamdf[allstreamdf$ls %in% selstreams, ]
# error checks
check1 <- var(streamdf$lake)
if(is.na(check1) | is.null(check1)) stop("Either no streams selected or critical data missing.") else if(check1 > 0) stop("Selected streams should be only from ONE lake.")
if(any(is.na(match(c("year", "lake", "ls", "Emr", "CVmr"), names(allstreamdf))))) stop("allstreamdf must include these variables: year lake ls Emr CVmr.")
if(any(is.na(match(c("year", "lake", "PE"), names(alllakedf))))) stop("alllakedf must include these variables: lake year PE.")
# fill in missing mark-recap data
indfit <- aov(log(Emr) ~ as.factor(ls) + as.factor(year), data=streamdf, weights=1/CVmr^2)
# figure out estimable years (those with at least 1 m-r estimate)
n.mr <- tapply(!is.na(streamdf$Emr), streamdf$year, sum)
eyrs <- as.numeric(names(n.mr)[n.mr > 0.5])
estimable <- streamdf$year %in% eyrs
streamdf$Pmr <- NA
streamdf$Pmr[estimable] <- ModelEst(fit=indfit, df=streamdf[estimable, ])
streamdf$COMBmr <- ifelse(is.na(streamdf$Emr), streamdf$Pmr, streamdf$Emr)
# annual index (sum across streams)
indxdf <- aggregate(COMBmr ~ year + lake, streamdf, sum, na.rm=TRUE, na.action=na.pass)
names(indxdf)[names(indxdf)=="COMBmr"] <- "indxraw"
indxdf$indxraw[indxdf$indxraw==0] <- NA
# only keep lake-wide index for years with at least min.nmr mark-recap estimates
indxdf$n.mr <- n.mr
indxdf$indxkeep <- ifelse(indxdf$n.mr > (min.nmr - 0.5), indxdf$indxraw, NA)
indxdf$indxkeep.lo <- NA
indxdf$indxkeep.hi <- NA
# matrix of stream estimates (rows = years, columns = index streams)
streamests <- with(streamdf, tapply(COMBmr, list(year, ls), mean))
# selection of only those streams with a keepable index
selkeep <- !is.na(indxdf$indxkeep)
jack <- jackindex(streamests[selkeep, ])
indxdf$indxkeep.lo[selkeep] <- jack[, "lo"]
indxdf$indxkeep.hi[selkeep] <- jack[, "hi"]
# scale up the index to the spawner model PE
lk1 <- lk[lk$lake == streamdf$lake[1], ]
indxdf2 <- merge(lk1, indxdf, all=TRUE)
scaleup <- median(indxdf2$PE / indxdf2$indxkeep, na.rm=TRUE)
if(show) {
cat("\nindfit\n")
print(summary(indfit))
cat("\nstreamdf\n")
print(tail(streamdf[, c("lake", "year", "ls", "Emr", "CVmr", "Pmr", "COMBmr")]))
cat("\nscaleup\n")
print(scaleup)
cat("\nindxdf\n")
print(tail(indxdf[, c("lake", "year", "n.mr", "indxraw", "indxkeep", "indxkeep.lo", "indxkeep.hi")]))
}
list(indfit=indfit, streamdf=streamdf, scaleup=scaleup, indxdf=indxdf)
}
calctarg <- function(lakenum, adults, year, targyears, adjust=c(1, 1, 0.25, 1, 1)) {
# lakenum = vector of lake numbers (1-5)
# adults = vector of lakewide adult sea lamprey estimates
# year = vector of years
# targyears = list (length 5) of selected years from which to calculate targets
# lake huron target is 25% of
targets <- data.frame(lake=1:5, target=rep(NA, 5), lo=rep(NA, 5), hi=rep(NA, 5))
for(i in 1:5) {
pick5 <- adults[lakenum==i & is.element(year, targyears[[i]]) & !is.na(adults)]
if(length(pick5) > 0) {
targets$target[i] <- mean(pick5)
n <- length(pick5)
ci <- qnorm(1 - 0.05/2) * sqrt(var(pick5)) / sqrt(n)
targets[i, c("lo", "hi")] <- mean(pick5) + c(-1, 1)*ci# using z dist (known variance)
targets[i, c("target", "lo", "hi")] <- adjust[i]*targets[i, c("target", "lo", "hi")]
} else {
targets[i, c("target", "lo", "hi")] <- c(NA, NA, NA)
}
}
targets
}
}
# bring in lake-wide spawner data
lk <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/LakePEdynamic.csv", as.is=T)
# bring in stream-specific data
dat <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/StreamPEdynamicALLCOLS.csv", as.is=T)
dat$ls <- dat$lscode
# 2014-04-09 Jess and Gale agreed that the East Au Gres (38) should be replaced with the Au Sable (36) in Lake Huron
# 2014-04-10 Jess thinks that we should just stick with the East Au Gres (38)
index.streams <- list(
Sup = c(1, 2, 9, 29, 31, 32, 62),
Mic = c(5, 6, 15, 24, 26, 35),
Hur = c(10, 16, 27, 32, 999, 38),
Eri = c(1, 2, 3, 7, 9),
Ont = c(5, 9, 22, 23, 36)
)
index.streams <- lapply(1:5, function(i) i + index.streams[[i]]/1000)
# estimate adult index of abundance for each lake using index streams
indices <- lapply(index.streams, index.est, dat, lk)
# combine index data for all lakes in one dataframe
indxall <- do.call(rbind, lapply(indices, "[[", "indxdf"))
# calculate targets 
sptargyrz <- list(1994:1998, 1988:1992, 1989:1993, 1991:1995, 1999:2003)
targyrz <- apply(sapply(sptargyrz, range), 2, paste, collapse="-")
# spawner model
targets.sm <- calctarg(lakenum=lk$lake, adults=lk$PE, year=lk$year, targyears=sptargyrz)
# adult index
targets.ai <- calctarg(lakenum=indxall$lake, adults=indxall$indxkeep, year=indxall$year, targyears=sptargyrz)
# spawner model targets scaled down to adult index
targets.sm.su <- cbind(lake=targets.sm[, 1], (1/sapply(indices, "[[", "scaleup")) * targets.sm[, -1])
# adult index adjusted
targets.ai.adj <- targets.ai
targets.ai.adj[is.na(targets.ai$target), ] <- targets.sm.su[is.na(targets.ai$target), ]
YEAR1 <- 1984
# create a Word document with results
doc <- startrtf(file="2014-10 SLCB Index", dir="C:/JVA/Lamprey/Adults/AdultIndex/2014", omi=c(1, 1.25, 1, 1.25))
heading("Index of Adult Sea Lamprey Abundance in each Great Lake")
heading(paste("Adams, Barber, Bravener, Steeves -", as.character(Sys.Date())), htype=2)
### Spawner model time series
heading("Purpose of the index", htype=3)
heading("Selection of index streams", htype=3)
heading("Calculation of index", htype=3)
heading("Assumptions", htype=3)
heading("Fate of current spawner model", htype=3)
para("Conversion factors: ", paste(Lakenames, round(sapply(indices, "[[", "scaleup"), 2), collapse=", "), ".")
# position of text for selected streams in each lake (for map drawing)
posp <- list(c(3, 1, 3, 1, 1, 3, 1),
c(2, 2, 2, 2, 2, 2),
c(4, 4, 4, 4, 4, 4),
c(2, 2, 2, 2, 2),
c(2, 2, 2, 2, 2, 2))
for(i in 1:5) {
mymap <- mapL[[i]]
mystreamdf <- indices[[i]]$streamdf
myindxdf <- indices[[i]]$indxdf
mystreamdf <- mystreamdf[mystreamdf$year >= YEAR1, ]
myindxdf <- myindxdf[myindxdf$year >= YEAR1, ]
### map of selected streams
fig <- function() {
map(xlim=range(mymap$x, na.rm=T), ylim=range(mymap$y, na.rm=T), col=NA, mar=rep(1, 4))
lines(mymap$x, mymap$y, col="darkgray", lwd=0.5)
with(mystreamdf[mystreamdf$year==2010, ], {
points(long, lat, cex=1.5, pch=16)
par(xpd=NA)
text(long, lat, strname, cex=1.2, pos=posp[[i]], font=2)
})
}
figu("Streams selected for inclusion in the Lake ", Lakenames[i], " index of adult sea lamprey abundance.", h=c(3, 6, 6, 3, 3)[i], w=6)
### colored table of mark-recap estimates of selected streams
m <- with(mystreamdf, tapply(Emr, list(year, substring(strname, 1, 10)), mean))
m <- m[, rev(order(apply(m, 2, median, na.rm=TRUE)))]
cols.in.table <- sapply(index.streams, length) + 1
table.width <- 6*cols.in.table/max(cols.in.table)
# add in a blurb on the model predicted values in the most recent year.
lastyear <- rev(dimnames(m)[[1]])[1]
lastrow <- m[lastyear, ]
missings <- names(lastrow[is.na(lastrow)])
misstext <- ""
if(length(missings)>0) {
preds <- with(mystreamdf, COMBmr[year==lastyear & strname %in% missings])
insert <- paste(paste(format(round(preds), big.mark=","), "for the", missings), collapse=", ")
if(length(missings)>1) {
misstext <- paste0("  In ", lastyear, ", these estimates were: ", insert, ".")
} else {
misstext <- paste0("  In ", lastyear, ", this estimate was ", insert, ".")
}
}
fig <- function() {
plot.table(format(round(m), big.mark=","), highlight=TRUE)
}
figu("Mark-recapture estimates from Lake ", Lakenames[i], " index streams.", 
"  Colors are used to highlight quantities from low (blue) to high (orange).", 
"  Streams are ordered according to their median estimates, highest (left) to lowest (right).", 
"  Abundances in streams without valid mark-recapture estimates (white rectangles) were estimated from the mean stream PE and the mean annual pattern,",
" weighting by the inverse CV2.", misstext, figid="Table ", fign=tabcount, newpage="port", capunder=FALSE, w=table.width[i], h=7)
tabcount <- tabcount + 1
figcount <- figcount - 1
### bar plot of individual index stream PEs
col7 <- c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69")
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p[is.na(myindxdf$indxkeep), ] <- NA
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
fig <- function() {
par(mar=c(4, 4, 1, 1), las=1, yaxs="i", cex=1.5)
a <- barplot(t(p)/1000, las=1, col=col7, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.01*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="Year", ylab="Adult abundance  (thousands)")
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2)
box()
legend("topleft", rev(colnames(p)), fill=rev(col7), cex=0.7)
}
figu("Adult sea lamprey abundance estimates for index streams of Lake ", Lakenames[i], ".", h=4.2, w=6)
### time series of PEs
fig <- function() {
par(mar=c(4, 4, 1, 1), cex=1.5, yaxs="i")
with(myindxdf, {
just <- year >= min(year[!is.na(indxkeep)])
yr <- 1.05*range(0, indxkeep.hi[just], na.rm=TRUE)/1000
plot(1, 1, xlim=range(year), ylim=yr, type="n", xlab="Year", ylab="Adults (thousands)", las=1)
arrows(year, indxkeep.lo/1000, year, indxkeep.hi/1000, length=0, angle=90, code=3, lwd=10, lend="square", col="#ffddc1")
abline(h=targets.ai.adj$target[i]/1000)
abline(h=targets.ai.adj[i, c("lo", "hi")]/1000, lty=2)
lines(year, indxkeep/1000, lwd=2, col=blindcolz[7], type="o", pch=17)
})
}
figu("Patterns over time in Lake ", Lakenames[i], " adult sea lampreys using the newly derived index.", 
"  Jackknife-type error bars for the annual abundance of adults are indicated by shaded rectangles.",
"  The index target is indicated by the horizontal line (with 95% confidence intervals).", h=3, w=6)
}
rm(mymap, mystreamdf, myindxdf, m, cols.in.table, table.width, lastrow, missings, misstext, preds, insert,
col7, p, yrz, pyrz)
### spawner model and adult index time series overlaid
fig <- function() {
par(mfrow=c(3, 2), mar=c(3, 3, 2, 3), oma=c(2, 2, 0, 0), cex=1.4, yaxs="i")
for(i in 1:5) {
mylk <- lk[lk$lake==i, ]# lake year PE lo hi
myindxdf <- indices[[i]]$indxdf# year lake indxraw n.mr indxkeep indxkeep.lo indxkeep.hi
convfac <- indices[[i]]$scaleup
x1 <- myindxdf$year
y1 <- myindxdf$indxkeep/1000
x2 <- mylk$year
y2 <- mylk$PE/convfac/1000
yr <- 1.05*range(0, y1, y2[x2>=YEAR1], na.rm=TRUE)
plot(1, 1, type="n", xlim=range(lk$year), ylim=yr, xlab="", ylab="", main=Lakenames[i], axes=FALSE)
axis(1)
axis(2, col=blindcolz[7], col.axis=blindcolz[7], las=1)
par(mgp=c(3, 2.2, 0))
axis(4, at=pretty(convfac*yr)/convfac, labels=pretty(convfac*yr), col=blindcolz[3], col.axis=blindcolz[3], las=1, hadj=1)
par(mgp=c(3, 1, 0))
box()
abline(h=targets.sm$target[i]/convfac/1000, col=blindcolz[3], lty=2)
abline(h=targets.ai.adj$target[i]/1000, col=blindcolz[7], lty=2)
lines(x2, y2, col=blindcolz[3], type="o", pch=18, lwd=2)
lines(x1, y1, col=blindcolz[7], type="o", pch=17, lwd=2)
if(i==1) {
plot(1, 1, type="n", xlab="", ylab="", axes=FALSE)
legend("center", c("Adult index", "Spawner model"), col=blindcolz[c(7, 3)], lwd=2, pch=c(17, 18))
}
}
mtext("Year", outer=TRUE, side=1, cex=1.8)
mtext("Adult abundance  (thousands)", outer=TRUE, side=2, cex=1.8)
}
figu("Patterns over time in adult sea lamprey abundance, comparing the newly derived index with the spawner model.",
"  Targets are indicated by dashed horizontal lines.",
"  Targets are based on averages from five years with historically acceptable wounding rates: ", paste(paste(targyrz, "in", Lakenames), collapse=", "), ".", 
w=6, h=7.5)
endrtf()
rm(targyrz, i)
names(indices[[1]])
# "indfit"   "streamdf" "scaleup"  "indxdf"
# scale up
round(sapply(indices, "[[", 3), 2)
# 3.84 1.85 2.82 1.01 2.40
indxall[7:11, ]
   # year lake   indxraw n.mr  indxkeep indxkeep.lo indxkeep.hi
# 7  1986    1 24275.673    5 24275.673   18726.753   27579.203
# 8  1987    1 10994.483    5 10994.483   10269.609   11494.884
# 9  1988    1 13630.037    5 13630.037   11710.612   14680.398
# 10 1989    1 20227.926    6 20227.926   18704.166   21988.594
# 11 1990    1  9332.001    5  9332.001    8435.646   11991.514
?legend
p
# C:\JVA\Lamprey\Adults\AdultIndex\2014\AdultIndex v2.r
{ # functions
# the following seven plot.table related function are from the Systmatic Investor Toolbox
# load Systematic Investor Toolbox
# require(RCurl)
# sit = getURLContent("https://github.com/systematicinvestor/SIT/raw/master/sit.gz", binary=TRUE, followlocation=TRUE, ssl.verifypeer=FALSE)
# con = gzcon(rawConnection(sit, "rb"))
# source(con)
# close(con)
draw.cell <- function(title, r, c, text.cex = 1, bg.col = 'white', frame.cell = T) {
if(!frame.cell) bcol = bg.col else bcol = 'black'
rect((2*(c - 1) + .5), -(r - .5), (2*c + .5), -(r + .5), col = bg.col, border = bcol)
if( c == 1) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else if( r == 1 ) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else {
text((2*c + .5), -r, title, adj = 1, cex = text.cex)
}
}
plot.table.helper.auto.adjust.cex <- function(temp.table, keep.all.same.cex = FALSE) {
nr = nrow(temp.table)
nc = ncol(temp.table)
all.xrange = diff(par()$usr[1:2]) / nc
xrange = matrix( strwidth(paste('  ', temp.table), units = 'user', cex = 1), nc = nc)
all.yrange = diff(par()$usr[3:4]) / nr
yrange = matrix( 5/3 * strheight(temp.table, units = 'user', cex = 1), nc = nc)
plot.matrix.cex = pmin( round(all.yrange / yrange, 2) , round(all.xrange / xrange, 2) )
header.col.cex = min(plot.matrix.cex[1,-1])
header.row.cex = min(plot.matrix.cex[-1,1])
title.cex = plot.matrix.cex[1, 1]
data.cex = min(plot.matrix.cex[-1, -1])
if ( keep.all.same.cex ) {
plot.matrix.cex[] = min(plot.matrix.cex)
} else {
plot.matrix.cex[1,-1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,-1]= min(c(header.col.cex, header.row.cex, data.cex))
plot.matrix.cex[1,1]= min(c(header.col.cex, header.row.cex, data.cex, title.cex))
plot.matrix.cex[1,-1] = min(c(header.col.cex))
plot.matrix.cex[-1,1] = min(c(header.row.cex))
plot.matrix.cex[-1,-1]= min(c(data.cex))
plot.matrix.cex[1,1]= min(c(title.cex))
}
return(plot.matrix.cex)
}
make.table <- function(nr, nc) {
savepar = par(mar = rep(1, 4))
plot(c(0.5, nc*2 + 0.5), c(-0.5, -(nr + 0.5)), xaxs = 'i', yaxs = 'i',
type = 'n', xlab = '', ylab = '', axes = FALSE)
savepar
}
trim <- function(s) {
s = sub(pattern = '^ +', replacement = '', x = s)
s = sub(pattern = ' +$', replacement = '', x = s)
return(s)
}
plot.table.param <- function(plot.matrix, smain = '', plot.matrix.cex, plot.matrix_bg.col, frame.cell = T, keep.all.same.cex = FALSE) {
n = nrow(plot.matrix)
pages = unique(c(seq(0, n, by = 120), n))
for(p in 1:(length(pages)-1)) {
rindex = (pages[p]+1) : pages[p+1]
temp.table = matrix('', nr = length(rindex)+1, nc = ncol(plot.matrix)+1)
temp.table[-1, -1] = plot.matrix[rindex,]
temp.table[1, -1] = colnames(plot.matrix)
temp.table[-1, 1] = rownames(plot.matrix)[rindex]
temp.table[1, 1] = smain
nr = nrow(temp.table)
nc = ncol(temp.table)
par(mar = c(0, 0, 0, 0), cex = 0.5)
oldpar = make.table(nr, nc)
text.cex = plot.matrix.cex[c(1, 1 + rindex), ]
text.cex = plot.table.helper.auto.adjust.cex(temp.table, keep.all.same.cex)
bg.col = plot.matrix_bg.col[c(1, 1 + rindex), ]
for(r in 1:nr) {
for(c in 1:nc) {
draw.cell( paste('', temp.table[r,c], '', sep=' '), r, c,
text.cex = text.cex[r,c], bg.col = bg.col[r,c], frame.cell = frame.cell)
}}
}
}
plot.table <- function(plot.matrix, smain="", text.cex=1, frame.cell=TRUE, highlight=FALSE, colorbar=FALSE, keep_all.same.cex=FALSE) {
if( is.null(rownames(plot.matrix)) & is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
if( ncol(temp.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[-1, -1, drop = FALSE]
colnames(plot.matrix) = temp.matrix[1, -1]
rownames(plot.matrix) = temp.matrix[-1, 1]
smain = temp.matrix[1, 1]
} else if( is.null(rownames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( ncol(plot.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[, -1, drop = FALSE]
colnames(plot.matrix) = colnames(temp.matrix)[-1]
rownames(plot.matrix) = temp.matrix[,1]
smain = colnames(temp.matrix)[1]
} else if( is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
plot.matrix = temp.matrix[-1, , drop = FALSE]
rownames(plot.matrix) = rownames(temp.matrix)[-1]
colnames(plot.matrix) = temp.matrix[1, ]
smain = rownames(temp.matrix)[1]
}
plot.matrix[which(trim(plot.matrix) == "NA")] = ""
plot.matrix[which(trim(plot.matrix) == "NA%")] = ""
plot.matrix[which(is.na(plot.matrix))] = ""
nr = nrow(plot.matrix) + 1
nc = ncol(plot.matrix) + 1
is_highlight = TRUE
if(is.logical(highlight)) {
is_highlight = highlight
if(highlight) highlight = plot.table.helper.color(plot.matrix)
}
if(!is_highlight) {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[seq(1, nr, 2), ] = "yellow"
plot.matrix_bg.col[1,] = "gray";
plot.table.param( plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
} else {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[1,] = "gray"
plot.matrix_bg.col[2:nr,2:nc] = highlight
plot.table.param(plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
}
}
plot.table.helper.color <- function (temp) {
temp = matrix(as.double(gsub("[%,$]", "", temp)), nrow(temp), ncol(temp))
highlight = as.vector(temp)
cols = rep(NA, length(highlight))
ncols = length(highlight[!is.na(highlight)])
cols[1:ncols] = rev(rainbow(ncols, start=0.5/6, end=3.5/6))
o = sort.list(highlight, na.last = TRUE, decreasing = FALSE)
o1 = sort.list(o, na.last = TRUE, decreasing = FALSE)
highlight = matrix(cols[o1], nrow = nrow(temp))
highlight[is.na(temp)] = NA
return(highlight)
}
ModelEst <- function(fit, df) {
# derive regression estimates from log(y) fit
mse <- rev(as.matrix(summary(fit)[[1]])[, "Mean Sq"])[1]
plpe <- predict(fit, newdata=df, se.fit=T)
m <- plpe$fit
v <- plpe$se.fit^2 + mse
exp(m + v/2)
}
myrange <- function(x) {
if(all(is.na(x))) r <- c(NA, NA) else r <- range(x, na.rm=TRUE)
return(r)
}
jackindex <- function(m) {
# m is a matrix of numbers (stream PEs) with observations (years) as rows and individuals (streams) as columns
if(any(is.na(m))) stop("The input matrix may not have any missing values.")
# calculate the index as the sum of the columns for each row
rowsum <- apply(m, 1, sum)
# calculate the mean of the index
avgind <- mean(rowsum)
# recalculate the index, leaving out one individual at a time
loo <- apply(m, 2, function(column) (rowsum - column))
# rescale the loo index, relative to mean
looscaled <- apply(loo, 2, function(x) x/mean(x))
# convert to original scale
looscaled2 <- looscaled * avgind
# calculate range
ranges <- t(apply(looscaled2, 1, range))
cbind(index=rowsum, lo=ranges[, 1], hi=ranges[, 2])
}
# selstreams <- index.streams[[1]] 
# allstreamdf <- dat
# alllakedf <- lk 
# min.nmr=2 
# show=FALSE
index.est <- function(selstreams, allstreamdf, alllakedf, min.nmr=2, show=FALSE) {
# INDEX OF ADULT SEA LAMPREY ABUNDANCE
### INPUTS
# selstreams = vector of stream ids, e.g., 1.064 (lake + strcode/1000)
# allstreamdf = data frame of mark-recap estimates for all streams, with vars:  year lake ls Emr CVmr
# alllakedf = data frame of lake-wide PEs from Mullett et al. (2003) spawner model with vars:  lake year PE
# min.nmr = minimum number of mark-recapture estimates needed in a year to generate an index, default 2
# show = print out a brief summary of the results, default FALSE
### OUTPUTS
# indfit = simple model used to predict missing mark-recap estimates
# streamdf = original allstreamdf, subsetted by selstreams, with estimates for missing mark-recaps
# indxdf = original alllakedf, subsetted by lake, with annual index, including raw (indxraw), kept based on min.nmr (indxkeep, indxkeep.lo, indxkeep.hi)
# scaleup = conversion factor used to scale up annual index to spawner model PE
streamdf <- allstreamdf[allstreamdf$ls %in% selstreams, ]
# error checks
check1 <- var(streamdf$lake)
if(is.na(check1) | is.null(check1)) stop("Either no streams selected or critical data missing.") else if(check1 > 0) stop("Selected streams should be only from ONE lake.")
if(any(is.na(match(c("year", "lake", "ls", "Emr", "CVmr"), names(allstreamdf))))) stop("allstreamdf must include these variables: year lake ls Emr CVmr.")
if(any(is.na(match(c("year", "lake", "PE"), names(alllakedf))))) stop("alllakedf must include these variables: lake year PE.")
# fill in missing mark-recap data
indfit <- aov(log(Emr) ~ as.factor(ls) + as.factor(year), data=streamdf, weights=1/CVmr^2)
# figure out estimable years (those with at least 1 m-r estimate)
n.mr <- tapply(!is.na(streamdf$Emr), streamdf$year, sum)
eyrs <- as.numeric(names(n.mr)[n.mr > 0.5])
estimable <- streamdf$year %in% eyrs
streamdf$Pmr <- NA
streamdf$Pmr[estimable] <- ModelEst(fit=indfit, df=streamdf[estimable, ])
streamdf$COMBmr <- ifelse(is.na(streamdf$Emr), streamdf$Pmr, streamdf$Emr)
# annual index (sum across streams)
indxdf <- aggregate(COMBmr ~ year + lake, streamdf, sum, na.rm=TRUE, na.action=na.pass)
names(indxdf)[names(indxdf)=="COMBmr"] <- "indxraw"
indxdf$indxraw[indxdf$indxraw==0] <- NA
# only keep lake-wide index for years with at least min.nmr mark-recap estimates
indxdf$n.mr <- n.mr
indxdf$indxkeep <- ifelse(indxdf$n.mr > (min.nmr - 0.5), indxdf$indxraw, NA)
indxdf$indxkeep.lo <- NA
indxdf$indxkeep.hi <- NA
# matrix of stream estimates (rows = years, columns = index streams)
streamests <- with(streamdf, tapply(COMBmr, list(year, ls), mean))
# selection of only those streams with a keepable index
selkeep <- !is.na(indxdf$indxkeep)
jack <- jackindex(streamests[selkeep, ])
indxdf$indxkeep.lo[selkeep] <- jack[, "lo"]
indxdf$indxkeep.hi[selkeep] <- jack[, "hi"]
# scale up the index to the spawner model PE
lk1 <- lk[lk$lake == streamdf$lake[1], ]
indxdf2 <- merge(lk1, indxdf, all=TRUE)
scaleup <- median(indxdf2$PE / indxdf2$indxkeep, na.rm=TRUE)
if(show) {
cat("\nindfit\n")
print(summary(indfit))
cat("\nstreamdf\n")
print(tail(streamdf[, c("lake", "year", "ls", "Emr", "CVmr", "Pmr", "COMBmr")]))
cat("\nscaleup\n")
print(scaleup)
cat("\nindxdf\n")
print(tail(indxdf[, c("lake", "year", "n.mr", "indxraw", "indxkeep", "indxkeep.lo", "indxkeep.hi")]))
}
list(indfit=indfit, streamdf=streamdf, scaleup=scaleup, indxdf=indxdf)
}
calctarg <- function(lakenum, adults, year, targyears, adjust=c(1, 1, 0.25, 1, 1)) {
# lakenum = vector of lake numbers (1-5)
# adults = vector of lakewide adult sea lamprey estimates
# year = vector of years
# targyears = list (length 5) of selected years from which to calculate targets
# lake huron target is 25% of
targets <- data.frame(lake=1:5, target=rep(NA, 5), lo=rep(NA, 5), hi=rep(NA, 5))
for(i in 1:5) {
pick5 <- adults[lakenum==i & is.element(year, targyears[[i]]) & !is.na(adults)]
if(length(pick5) > 0) {
targets$target[i] <- mean(pick5)
n <- length(pick5)
ci <- qnorm(1 - 0.05/2) * sqrt(var(pick5)) / sqrt(n)
targets[i, c("lo", "hi")] <- mean(pick5) + c(-1, 1)*ci# using z dist (known variance)
targets[i, c("target", "lo", "hi")] <- adjust[i]*targets[i, c("target", "lo", "hi")]
} else {
targets[i, c("target", "lo", "hi")] <- c(NA, NA, NA)
}
}
targets
}
}
# bring in lake-wide spawner data
lk <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/LakePEdynamic.csv", as.is=T)
# bring in stream-specific data
dat <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/StreamPEdynamicALLCOLS.csv", as.is=T)
dat$ls <- dat$lscode
# 2014-04-09 Jess and Gale agreed that the East Au Gres (38) should be replaced with the Au Sable (36) in Lake Huron
# 2014-04-10 Jess thinks that we should just stick with the East Au Gres (38)
index.streams <- list(
Sup = c(1, 2, 9, 29, 31, 32, 62),
Mic = c(5, 6, 15, 24, 26, 35),
Hur = c(10, 16, 27, 32, 999, 38),
Eri = c(1, 2, 3, 7, 9),
Ont = c(5, 9, 22, 23, 36)
)
index.streams <- lapply(1:5, function(i) i + index.streams[[i]]/1000)
# estimate adult index of abundance for each lake using index streams
indices <- lapply(index.streams, index.est, dat, lk)
# combine index data for all lakes in one dataframe
indxall <- do.call(rbind, lapply(indices, "[[", "indxdf"))
# calculate targets 
sptargyrz <- list(1994:1998, 1988:1992, 1989:1993, 1991:1995, 1999:2003)
targyrz <- apply(sapply(sptargyrz, range), 2, paste, collapse="-")
# spawner model
targets.sm <- calctarg(lakenum=lk$lake, adults=lk$PE, year=lk$year, targyears=sptargyrz)
# adult index
targets.ai <- calctarg(lakenum=indxall$lake, adults=indxall$indxkeep, year=indxall$year, targyears=sptargyrz)
# spawner model targets scaled down to adult index
targets.sm.su <- cbind(lake=targets.sm[, 1], (1/sapply(indices, "[[", "scaleup")) * targets.sm[, -1])
# adult index adjusted
targets.ai.adj <- targets.ai
targets.ai.adj[is.na(targets.ai$target), ] <- targets.sm.su[is.na(targets.ai$target), ]
YEAR1 <- 1984
# create a Word document with results
doc <- startrtf(file="2014-10 SLCB Index", dir="C:/JVA/Lamprey/Adults/AdultIndex/2014", omi=c(1, 1.25, 1, 1.25))
heading("Index of Adult Sea Lamprey Abundance in each Great Lake")
heading(paste("Adams, Barber, Bravener, Steeves -", as.character(Sys.Date())), htype=2)
### Spawner model time series
heading("Purpose of the index", htype=3)
heading("Selection of index streams", htype=3)
heading("Calculation of index", htype=3)
heading("Assumptions", htype=3)
heading("Fate of current spawner model", htype=3)
para("Conversion factors: ", paste(Lakenames, round(sapply(indices, "[[", "scaleup"), 2), collapse=", "), ".")
# position of text for selected streams in each lake (for map drawing)
posp <- list(c(3, 1, 3, 1, 1, 3, 1),
c(2, 2, 2, 2, 2, 2),
c(4, 4, 4, 4, 4, 4),
c(2, 2, 2, 2, 2),
c(2, 2, 2, 2, 2, 2))
for(i in 1:5) {
mymap <- mapL[[i]]
mystreamdf <- indices[[i]]$streamdf
myindxdf <- indices[[i]]$indxdf
mystreamdf <- mystreamdf[mystreamdf$year >= YEAR1, ]
myindxdf <- myindxdf[myindxdf$year >= YEAR1, ]
### map of selected streams
fig <- function() {
map(xlim=range(mymap$x, na.rm=T), ylim=range(mymap$y, na.rm=T), col=NA, mar=rep(1, 4))
lines(mymap$x, mymap$y, col="darkgray", lwd=0.5)
with(mystreamdf[mystreamdf$year==2010, ], {
points(long, lat, cex=1.5, pch=16)
par(xpd=NA)
text(long, lat, strname, cex=1.2, pos=posp[[i]], font=2)
})
}
figu("Streams selected for inclusion in the Lake ", Lakenames[i], " index of adult sea lamprey abundance.", h=c(3, 6, 6, 3, 3)[i], w=6)
### colored table of mark-recap estimates of selected streams
m <- with(mystreamdf, tapply(Emr, list(year, substring(strname, 1, 10)), mean))
m <- m[, rev(order(apply(m, 2, median, na.rm=TRUE)))]
cols.in.table <- sapply(index.streams, length) + 1
table.width <- 6*cols.in.table/max(cols.in.table)
# add in a blurb on the model predicted values in the most recent year.
lastyear <- rev(dimnames(m)[[1]])[1]
lastrow <- m[lastyear, ]
missings <- names(lastrow[is.na(lastrow)])
misstext <- ""
if(length(missings)>0) {
preds <- with(mystreamdf, COMBmr[year==lastyear & strname %in% missings])
insert <- paste(paste(format(round(preds), big.mark=","), "for the", missings), collapse=", ")
if(length(missings)>1) {
misstext <- paste0("  In ", lastyear, ", these estimates were: ", insert, ".")
} else {
misstext <- paste0("  In ", lastyear, ", this estimate was ", insert, ".")
}
}
fig <- function() {
plot.table(format(round(m), big.mark=","), highlight=TRUE)
}
figu("Mark-recapture estimates from Lake ", Lakenames[i], " index streams.", 
"  Colors are used to highlight quantities from low (blue) to high (orange).", 
"  Streams are ordered according to their median estimates, highest (left) to lowest (right).", 
"  Abundances in streams without valid mark-recapture estimates (white rectangles) were estimated from the mean stream PE and the mean annual pattern,",
" weighting by the inverse CV2.", misstext, figid="Table ", fign=tabcount, newpage="port", capunder=FALSE, w=table.width[i], h=7)
tabcount <- tabcount + 1
figcount <- figcount - 1
### bar plot of individual index stream PEs
col7 <- c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69")
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p[is.na(myindxdf$indxkeep), ] <- NA
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
fig <- function() {
par(mar=c(4, 4, 1, 1), las=1, yaxs="i", cex=1.5)
a <- barplot(t(p)/1000, las=1, col=col7, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.01*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="Year", ylab="Adult abundance  (thousands)")
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2)
box()
legend("topleft", rev(colnames(p)), fill=rev(col7[1:dim(p)[2]]), cex=0.75, bty="n")
}
figu("Adult sea lamprey abundance estimates for index streams of Lake ", Lakenames[i], ".", h=4.2, w=6)
### time series of PEs
fig <- function() {
par(mar=c(4, 4, 1, 1), cex=1.5, yaxs="i")
with(myindxdf, {
just <- year >= min(year[!is.na(indxkeep)])
yr <- 1.05*range(0, indxkeep.hi[just], na.rm=TRUE)/1000
plot(1, 1, xlim=range(year), ylim=yr, type="n", xlab="Year", ylab="Adults (thousands)", las=1)
arrows(year, indxkeep.lo/1000, year, indxkeep.hi/1000, length=0, angle=90, code=3, lwd=10, lend="square", col="#ffddc1")
abline(h=targets.ai.adj$target[i]/1000)
abline(h=targets.ai.adj[i, c("lo", "hi")]/1000, lty=2)
lines(year, indxkeep/1000, lwd=2, col=blindcolz[7], type="o", pch=17)
})
}
figu("Patterns over time in Lake ", Lakenames[i], " adult sea lampreys using the newly derived index.", 
"  Jackknife-type error bars for the annual abundance of adults are indicated by shaded rectangles.",
"  The index target is indicated by the horizontal line (with 95% confidence intervals).", h=3, w=6)
}
rm(mymap, mystreamdf, myindxdf, m, cols.in.table, table.width, lastrow, missings, misstext, preds, insert,
col7, p, yrz, pyrz)
### spawner model and adult index time series overlaid
fig <- function() {
par(mfrow=c(3, 2), mar=c(3, 3, 2, 3), oma=c(2, 2, 0, 0), cex=1.4, yaxs="i")
for(i in 1:5) {
mylk <- lk[lk$lake==i, ]# lake year PE lo hi
myindxdf <- indices[[i]]$indxdf# year lake indxraw n.mr indxkeep indxkeep.lo indxkeep.hi
convfac <- indices[[i]]$scaleup
x1 <- myindxdf$year
y1 <- myindxdf$indxkeep/1000
x2 <- mylk$year
y2 <- mylk$PE/convfac/1000
yr <- 1.05*range(0, y1, y2[x2>=YEAR1], na.rm=TRUE)
plot(1, 1, type="n", xlim=range(lk$year), ylim=yr, xlab="", ylab="", main=Lakenames[i], axes=FALSE)
axis(1)
axis(2, col=blindcolz[7], col.axis=blindcolz[7], las=1)
par(mgp=c(3, 2.2, 0))
axis(4, at=pretty(convfac*yr)/convfac, labels=pretty(convfac*yr), col=blindcolz[3], col.axis=blindcolz[3], las=1, hadj=1)
par(mgp=c(3, 1, 0))
box()
abline(h=targets.sm$target[i]/convfac/1000, col=blindcolz[3], lty=2)
abline(h=targets.ai.adj$target[i]/1000, col=blindcolz[7], lty=2)
lines(x2, y2, col=blindcolz[3], type="o", pch=18, lwd=2)
lines(x1, y1, col=blindcolz[7], type="o", pch=17, lwd=2)
if(i==1) {
plot(1, 1, type="n", xlab="", ylab="", axes=FALSE)
legend("center", c("Adult index", "Spawner model"), col=blindcolz[c(7, 3)], lwd=2, pch=c(17, 18))
}
}
mtext("Year", outer=TRUE, side=1, cex=1.8)
mtext("Adult abundance  (thousands)", outer=TRUE, side=2, cex=1.8)
}
figu("Patterns over time in adult sea lamprey abundance, comparing the newly derived index with the spawner model.",
"  Targets are indicated by dashed horizontal lines.",
"  Targets are based on averages from five years with historically acceptable wounding rates: ", paste(paste(targyrz, "in", Lakenames), collapse=", "), ".", 
w=6, h=7.5)
endrtf()
rm(targyrz, i)
names(indices[[1]])
# "indfit"   "streamdf" "scaleup"  "indxdf"
# scale up
round(sapply(indices, "[[", 3), 2)
# 3.84 1.85 2.82 1.01 2.40
indxall[7:11, ]
   # year lake   indxraw n.mr  indxkeep indxkeep.lo indxkeep.hi
# 7  1986    1 24275.673    5 24275.673   18726.753   27579.203
# 8  1987    1 10994.483    5 10994.483   10269.609   11494.884
# 9  1988    1 13630.037    5 13630.037   11710.612   14680.398
# 10 1989    1 20227.926    6 20227.926   18704.166   21988.594
# 11 1990    1  9332.001    5  9332.001    8435.646   11991.514
dim(map5)
# C:\JVA\Lamprey\Adults\AdultIndex\2014\AdultIndex v2.r
{ # functions
# the following seven plot.table related function are from the Systmatic Investor Toolbox
# load Systematic Investor Toolbox
# require(RCurl)
# sit = getURLContent("https://github.com/systematicinvestor/SIT/raw/master/sit.gz", binary=TRUE, followlocation=TRUE, ssl.verifypeer=FALSE)
# con = gzcon(rawConnection(sit, "rb"))
# source(con)
# close(con)
draw.cell <- function(title, r, c, text.cex = 1, bg.col = 'white', frame.cell = T) {
if(!frame.cell) bcol = bg.col else bcol = 'black'
rect((2*(c - 1) + .5), -(r - .5), (2*c + .5), -(r + .5), col = bg.col, border = bcol)
if( c == 1) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else if( r == 1 ) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else {
text((2*c + .5), -r, title, adj = 1, cex = text.cex)
}
}
plot.table.helper.auto.adjust.cex <- function(temp.table, keep.all.same.cex = FALSE) {
nr = nrow(temp.table)
nc = ncol(temp.table)
all.xrange = diff(par()$usr[1:2]) / nc
xrange = matrix( strwidth(paste('  ', temp.table), units = 'user', cex = 1), nc = nc)
all.yrange = diff(par()$usr[3:4]) / nr
yrange = matrix( 5/3 * strheight(temp.table, units = 'user', cex = 1), nc = nc)
plot.matrix.cex = pmin( round(all.yrange / yrange, 2) , round(all.xrange / xrange, 2) )
header.col.cex = min(plot.matrix.cex[1,-1])
header.row.cex = min(plot.matrix.cex[-1,1])
title.cex = plot.matrix.cex[1, 1]
data.cex = min(plot.matrix.cex[-1, -1])
if ( keep.all.same.cex ) {
plot.matrix.cex[] = min(plot.matrix.cex)
} else {
plot.matrix.cex[1,-1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,-1]= min(c(header.col.cex, header.row.cex, data.cex))
plot.matrix.cex[1,1]= min(c(header.col.cex, header.row.cex, data.cex, title.cex))
plot.matrix.cex[1,-1] = min(c(header.col.cex))
plot.matrix.cex[-1,1] = min(c(header.row.cex))
plot.matrix.cex[-1,-1]= min(c(data.cex))
plot.matrix.cex[1,1]= min(c(title.cex))
}
return(plot.matrix.cex)
}
make.table <- function(nr, nc) {
savepar = par(mar = rep(1, 4))
plot(c(0.5, nc*2 + 0.5), c(-0.5, -(nr + 0.5)), xaxs = 'i', yaxs = 'i',
type = 'n', xlab = '', ylab = '', axes = FALSE)
savepar
}
trim <- function(s) {
s = sub(pattern = '^ +', replacement = '', x = s)
s = sub(pattern = ' +$', replacement = '', x = s)
return(s)
}
plot.table.param <- function(plot.matrix, smain = '', plot.matrix.cex, plot.matrix_bg.col, frame.cell = T, keep.all.same.cex = FALSE) {
n = nrow(plot.matrix)
pages = unique(c(seq(0, n, by = 120), n))
for(p in 1:(length(pages)-1)) {
rindex = (pages[p]+1) : pages[p+1]
temp.table = matrix('', nr = length(rindex)+1, nc = ncol(plot.matrix)+1)
temp.table[-1, -1] = plot.matrix[rindex,]
temp.table[1, -1] = colnames(plot.matrix)
temp.table[-1, 1] = rownames(plot.matrix)[rindex]
temp.table[1, 1] = smain
nr = nrow(temp.table)
nc = ncol(temp.table)
par(mar = c(0, 0, 0, 0), cex = 0.5)
oldpar = make.table(nr, nc)
text.cex = plot.matrix.cex[c(1, 1 + rindex), ]
text.cex = plot.table.helper.auto.adjust.cex(temp.table, keep.all.same.cex)
bg.col = plot.matrix_bg.col[c(1, 1 + rindex), ]
for(r in 1:nr) {
for(c in 1:nc) {
draw.cell( paste('', temp.table[r,c], '', sep=' '), r, c,
text.cex = text.cex[r,c], bg.col = bg.col[r,c], frame.cell = frame.cell)
}}
}
}
plot.table <- function(plot.matrix, smain="", text.cex=1, frame.cell=TRUE, highlight=FALSE, colorbar=FALSE, keep_all.same.cex=FALSE) {
if( is.null(rownames(plot.matrix)) & is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
if( ncol(temp.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[-1, -1, drop = FALSE]
colnames(plot.matrix) = temp.matrix[1, -1]
rownames(plot.matrix) = temp.matrix[-1, 1]
smain = temp.matrix[1, 1]
} else if( is.null(rownames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( ncol(plot.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[, -1, drop = FALSE]
colnames(plot.matrix) = colnames(temp.matrix)[-1]
rownames(plot.matrix) = temp.matrix[,1]
smain = colnames(temp.matrix)[1]
} else if( is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
plot.matrix = temp.matrix[-1, , drop = FALSE]
rownames(plot.matrix) = rownames(temp.matrix)[-1]
colnames(plot.matrix) = temp.matrix[1, ]
smain = rownames(temp.matrix)[1]
}
plot.matrix[which(trim(plot.matrix) == "NA")] = ""
plot.matrix[which(trim(plot.matrix) == "NA%")] = ""
plot.matrix[which(is.na(plot.matrix))] = ""
nr = nrow(plot.matrix) + 1
nc = ncol(plot.matrix) + 1
is_highlight = TRUE
if(is.logical(highlight)) {
is_highlight = highlight
if(highlight) highlight = plot.table.helper.color(plot.matrix)
}
if(!is_highlight) {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[seq(1, nr, 2), ] = "yellow"
plot.matrix_bg.col[1,] = "gray";
plot.table.param( plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
} else {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[1,] = "gray"
plot.matrix_bg.col[2:nr,2:nc] = highlight
plot.table.param(plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
}
}
plot.table.helper.color <- function (temp) {
temp = matrix(as.double(gsub("[%,$]", "", temp)), nrow(temp), ncol(temp))
highlight = as.vector(temp)
cols = rep(NA, length(highlight))
ncols = length(highlight[!is.na(highlight)])
cols[1:ncols] = rev(rainbow(ncols, start=0.5/6, end=3.5/6))
o = sort.list(highlight, na.last = TRUE, decreasing = FALSE)
o1 = sort.list(o, na.last = TRUE, decreasing = FALSE)
highlight = matrix(cols[o1], nrow = nrow(temp))
highlight[is.na(temp)] = NA
return(highlight)
}
ModelEst <- function(fit, df) {
# derive regression estimates from log(y) fit
mse <- rev(as.matrix(summary(fit)[[1]])[, "Mean Sq"])[1]
plpe <- predict(fit, newdata=df, se.fit=T)
m <- plpe$fit
v <- plpe$se.fit^2 + mse
exp(m + v/2)
}
myrange <- function(x) {
if(all(is.na(x))) r <- c(NA, NA) else r <- range(x, na.rm=TRUE)
return(r)
}
jackindex <- function(m) {
# m is a matrix of numbers (stream PEs) with observations (years) as rows and individuals (streams) as columns
if(any(is.na(m))) stop("The input matrix may not have any missing values.")
# calculate the index as the sum of the columns for each row
rowsum <- apply(m, 1, sum)
# calculate the mean of the index
avgind <- mean(rowsum)
# recalculate the index, leaving out one individual at a time
loo <- apply(m, 2, function(column) (rowsum - column))
# rescale the loo index, relative to mean
looscaled <- apply(loo, 2, function(x) x/mean(x))
# convert to original scale
looscaled2 <- looscaled * avgind
# calculate range
ranges <- t(apply(looscaled2, 1, range))
cbind(index=rowsum, lo=ranges[, 1], hi=ranges[, 2])
}
# selstreams <- index.streams[[1]] 
# allstreamdf <- dat
# alllakedf <- lk 
# min.nmr=2 
# show=FALSE
index.est <- function(selstreams, allstreamdf, alllakedf, min.nmr=2, show=FALSE) {
# INDEX OF ADULT SEA LAMPREY ABUNDANCE
### INPUTS
# selstreams = vector of stream ids, e.g., 1.064 (lake + strcode/1000)
# allstreamdf = data frame of mark-recap estimates for all streams, with vars:  year lake ls Emr CVmr
# alllakedf = data frame of lake-wide PEs from Mullett et al. (2003) spawner model with vars:  lake year PE
# min.nmr = minimum number of mark-recapture estimates needed in a year to generate an index, default 2
# show = print out a brief summary of the results, default FALSE
### OUTPUTS
# indfit = simple model used to predict missing mark-recap estimates
# streamdf = original allstreamdf, subsetted by selstreams, with estimates for missing mark-recaps
# indxdf = original alllakedf, subsetted by lake, with annual index, including raw (indxraw), kept based on min.nmr (indxkeep, indxkeep.lo, indxkeep.hi)
# scaleup = conversion factor used to scale up annual index to spawner model PE
streamdf <- allstreamdf[allstreamdf$ls %in% selstreams, ]
# error checks
check1 <- var(streamdf$lake)
if(is.na(check1) | is.null(check1)) stop("Either no streams selected or critical data missing.") else if(check1 > 0) stop("Selected streams should be only from ONE lake.")
if(any(is.na(match(c("year", "lake", "ls", "Emr", "CVmr"), names(allstreamdf))))) stop("allstreamdf must include these variables: year lake ls Emr CVmr.")
if(any(is.na(match(c("year", "lake", "PE"), names(alllakedf))))) stop("alllakedf must include these variables: lake year PE.")
# fill in missing mark-recap data
indfit <- aov(log(Emr) ~ as.factor(ls) + as.factor(year), data=streamdf, weights=1/CVmr^2)
# figure out estimable years (those with at least 1 m-r estimate)
n.mr <- tapply(!is.na(streamdf$Emr), streamdf$year, sum)
eyrs <- as.numeric(names(n.mr)[n.mr > 0.5])
estimable <- streamdf$year %in% eyrs
streamdf$Pmr <- NA
streamdf$Pmr[estimable] <- ModelEst(fit=indfit, df=streamdf[estimable, ])
streamdf$COMBmr <- ifelse(is.na(streamdf$Emr), streamdf$Pmr, streamdf$Emr)
# annual index (sum across streams)
indxdf <- aggregate(COMBmr ~ year + lake, streamdf, sum, na.rm=TRUE, na.action=na.pass)
names(indxdf)[names(indxdf)=="COMBmr"] <- "indxraw"
indxdf$indxraw[indxdf$indxraw==0] <- NA
# only keep lake-wide index for years with at least min.nmr mark-recap estimates
indxdf$n.mr <- n.mr
indxdf$indxkeep <- ifelse(indxdf$n.mr > (min.nmr - 0.5), indxdf$indxraw, NA)
indxdf$indxkeep.lo <- NA
indxdf$indxkeep.hi <- NA
# matrix of stream estimates (rows = years, columns = index streams)
streamests <- with(streamdf, tapply(COMBmr, list(year, ls), mean))
# selection of only those streams with a keepable index
selkeep <- !is.na(indxdf$indxkeep)
jack <- jackindex(streamests[selkeep, ])
indxdf$indxkeep.lo[selkeep] <- jack[, "lo"]
indxdf$indxkeep.hi[selkeep] <- jack[, "hi"]
# scale up the index to the spawner model PE
lk1 <- lk[lk$lake == streamdf$lake[1], ]
indxdf2 <- merge(lk1, indxdf, all=TRUE)
scaleup <- median(indxdf2$PE / indxdf2$indxkeep, na.rm=TRUE)
if(show) {
cat("\nindfit\n")
print(summary(indfit))
cat("\nstreamdf\n")
print(tail(streamdf[, c("lake", "year", "ls", "Emr", "CVmr", "Pmr", "COMBmr")]))
cat("\nscaleup\n")
print(scaleup)
cat("\nindxdf\n")
print(tail(indxdf[, c("lake", "year", "n.mr", "indxraw", "indxkeep", "indxkeep.lo", "indxkeep.hi")]))
}
list(indfit=indfit, streamdf=streamdf, scaleup=scaleup, indxdf=indxdf)
}
calctarg <- function(lakenum, adults, year, targyears, adjust=c(1, 1, 0.25, 1, 1)) {
# lakenum = vector of lake numbers (1-5)
# adults = vector of lakewide adult sea lamprey estimates
# year = vector of years
# targyears = list (length 5) of selected years from which to calculate targets
# lake huron target is 25% of
targets <- data.frame(lake=1:5, target=rep(NA, 5), lo=rep(NA, 5), hi=rep(NA, 5))
for(i in 1:5) {
pick5 <- adults[lakenum==i & is.element(year, targyears[[i]]) & !is.na(adults)]
if(length(pick5) > 0) {
targets$target[i] <- mean(pick5)
n <- length(pick5)
ci <- qnorm(1 - 0.05/2) * sqrt(var(pick5)) / sqrt(n)
targets[i, c("lo", "hi")] <- mean(pick5) + c(-1, 1)*ci# using z dist (known variance)
targets[i, c("target", "lo", "hi")] <- adjust[i]*targets[i, c("target", "lo", "hi")]
} else {
targets[i, c("target", "lo", "hi")] <- c(NA, NA, NA)
}
}
targets
}
}
# bring in lake-wide spawner data
lk <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/LakePEdynamic.csv", as.is=T)
# bring in stream-specific data
dat <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/StreamPEdynamicALLCOLS.csv", as.is=T)
dat$ls <- dat$lscode
# 2014-04-09 Jess and Gale agreed that the East Au Gres (38) should be replaced with the Au Sable (36) in Lake Huron
# 2014-04-10 Jess thinks that we should just stick with the East Au Gres (38)
index.streams <- list(
Sup = c(1, 2, 9, 29, 31, 32, 62),
Mic = c(5, 6, 15, 24, 26, 35),
Hur = c(10, 16, 27, 32, 999, 38),
Eri = c(1, 2, 3, 7, 9),
Ont = c(5, 9, 22, 23, 36)
)
index.streams <- lapply(1:5, function(i) i + index.streams[[i]]/1000)
# estimate adult index of abundance for each lake using index streams
indices <- lapply(index.streams, index.est, dat, lk)
# combine index data for all lakes in one dataframe
indxall <- do.call(rbind, lapply(indices, "[[", "indxdf"))
# calculate targets 
sptargyrz <- list(1994:1998, 1988:1992, 1989:1993, 1991:1995, 1999:2003)
targyrz <- apply(sapply(sptargyrz, range), 2, paste, collapse="-")
# spawner model
targets.sm <- calctarg(lakenum=lk$lake, adults=lk$PE, year=lk$year, targyears=sptargyrz)
# adult index
targets.ai <- calctarg(lakenum=indxall$lake, adults=indxall$indxkeep, year=indxall$year, targyears=sptargyrz)
# spawner model targets scaled down to adult index
targets.sm.su <- cbind(lake=targets.sm[, 1], (1/sapply(indices, "[[", "scaleup")) * targets.sm[, -1])
# adult index adjusted
targets.ai.adj <- targets.ai
targets.ai.adj[is.na(targets.ai$target), ] <- targets.sm.su[is.na(targets.ai$target), ]
YEAR1 <- 1984
# create a Word document with results
doc <- startrtf(file="2014-10 SLCB Index", dir="C:/JVA/Lamprey/Adults/AdultIndex/2014", omi=c(1, 1.25, 1, 1.25))
heading("Index of Adult Sea Lamprey Abundance in each Great Lake")
heading(paste("Adams, Barber, Bravener, Steeves -", as.character(Sys.Date())), htype=2)
### Spawner model time series
heading("Purpose of the index", htype=3)
heading("Selection of index streams", htype=3)
heading("Calculation of index", htype=3)
heading("Assumptions", htype=3)
heading("Fate of current spawner model", htype=3)
para("Conversion factors: ", paste(Lakenames, round(sapply(indices, "[[", "scaleup"), 2), collapse=", "), ".")
# position of text for selected streams in each lake (for map drawing)
posp <- list(c(3, 1, 3, 1, 1, 3, 1),
c(2, 2, 2, 2, 2, 2),
c(4, 4, 4, 4, 4, 4),
c(2, 2, 2, 2, 2),
c(2, 2, 2, 2, 2, 2))
### map of selected streams
mymap <- map5
fig <- function() {
map(xlim=range(mymap$x, na.rm=T), ylim=range(mymap$y, na.rm=T), col=NA, mar=rep(1, 4))
lines(mymap$x, mymap$y, col="darkgray", lwd=0.5)
for(i in 1:5) {
mystreamdf <- indices[[i]]$streamdf
with(mystreamdf[mystreamdf$year==2010, ], {
points(long, lat, cex=1.5, pch=16)
par(xpd=NA)
text(long, lat, strname, cex=1.2, pos=posp[[i]], font=2)
})
}
}
windows()
fig()
col7 <- c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69")
par(mar=c(4, 4, 1, 1), mfrow=c(3, 2), las=1, yaxs="i", cex=1.5)
fig <- function() {
for(i in 1:5) {
mymap <- mapL[[i]]
mystreamdf <- indices[[i]]$streamdf
myindxdf <- indices[[i]]$indxdf
mystreamdf <- mystreamdf[mystreamdf$year >= YEAR1, ]
myindxdf <- myindxdf[myindxdf$year >= YEAR1, ]
### bar plot of individual index stream PEs
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p[is.na(myindxdf$indxkeep), ] <- NA
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
a <- barplot(t(p)/1000, las=1, col=col7, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.01*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="Year", ylab="Adult abundance  (thousands)")
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2)
box()
legend("topleft", rev(colnames(p)), fill=rev(col7[1:dim(p)[2]]), cex=0.75, bty="n")
if(i==1) {
frame()
}
}
}
windows()
fig()
col7 <- c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69")
fig <- function() {
par(mar=c(4, 4, 1, 1), mfrow=c(3, 2), las=1, yaxs="i", cex=1.5)
for(i in 1:5) {
mymap <- mapL[[i]]
mystreamdf <- indices[[i]]$streamdf
myindxdf <- indices[[i]]$indxdf
mystreamdf <- mystreamdf[mystreamdf$year >= YEAR1, ]
myindxdf <- myindxdf[myindxdf$year >= YEAR1, ]
### bar plot of individual index stream PEs
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p[is.na(myindxdf$indxkeep), ] <- NA
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
a <- barplot(t(p)/1000, las=1, col=col7, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.01*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="Year", ylab="Adult abundance  (thousands)")
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2)
box()
legend("topleft", rev(colnames(p)), fill=rev(col7[1:dim(p)[2]]), cex=0.75, bty="n")
if(i==1) {
frame()
}
}
}
fig()
cleanup()
graphics.off()
# C:\JVA\Lamprey\Adults\AdultIndex\2014\AdultIndex v2.r
{ # functions
# the following seven plot.table related function are from the Systmatic Investor Toolbox
# load Systematic Investor Toolbox
# require(RCurl)
# sit = getURLContent("https://github.com/systematicinvestor/SIT/raw/master/sit.gz", binary=TRUE, followlocation=TRUE, ssl.verifypeer=FALSE)
# con = gzcon(rawConnection(sit, "rb"))
# source(con)
# close(con)
draw.cell <- function(title, r, c, text.cex = 1, bg.col = 'white', frame.cell = T) {
if(!frame.cell) bcol = bg.col else bcol = 'black'
rect((2*(c - 1) + .5), -(r - .5), (2*c + .5), -(r + .5), col = bg.col, border = bcol)
if( c == 1) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else if( r == 1 ) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else {
text((2*c + .5), -r, title, adj = 1, cex = text.cex)
}
}
plot.table.helper.auto.adjust.cex <- function(temp.table, keep.all.same.cex = FALSE) {
nr = nrow(temp.table)
nc = ncol(temp.table)
all.xrange = diff(par()$usr[1:2]) / nc
xrange = matrix( strwidth(paste('  ', temp.table), units = 'user', cex = 1), nc = nc)
all.yrange = diff(par()$usr[3:4]) / nr
yrange = matrix( 5/3 * strheight(temp.table, units = 'user', cex = 1), nc = nc)
plot.matrix.cex = pmin( round(all.yrange / yrange, 2) , round(all.xrange / xrange, 2) )
header.col.cex = min(plot.matrix.cex[1,-1])
header.row.cex = min(plot.matrix.cex[-1,1])
title.cex = plot.matrix.cex[1, 1]
data.cex = min(plot.matrix.cex[-1, -1])
if ( keep.all.same.cex ) {
plot.matrix.cex[] = min(plot.matrix.cex)
} else {
plot.matrix.cex[1,-1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,-1]= min(c(header.col.cex, header.row.cex, data.cex))
plot.matrix.cex[1,1]= min(c(header.col.cex, header.row.cex, data.cex, title.cex))
plot.matrix.cex[1,-1] = min(c(header.col.cex))
plot.matrix.cex[-1,1] = min(c(header.row.cex))
plot.matrix.cex[-1,-1]= min(c(data.cex))
plot.matrix.cex[1,1]= min(c(title.cex))
}
return(plot.matrix.cex)
}
make.table <- function(nr, nc) {
savepar = par(mar = rep(1, 4))
plot(c(0.5, nc*2 + 0.5), c(-0.5, -(nr + 0.5)), xaxs = 'i', yaxs = 'i',
type = 'n', xlab = '', ylab = '', axes = FALSE)
savepar
}
trim <- function(s) {
s = sub(pattern = '^ +', replacement = '', x = s)
s = sub(pattern = ' +$', replacement = '', x = s)
return(s)
}
plot.table.param <- function(plot.matrix, smain = '', plot.matrix.cex, plot.matrix_bg.col, frame.cell = T, keep.all.same.cex = FALSE) {
n = nrow(plot.matrix)
pages = unique(c(seq(0, n, by = 120), n))
for(p in 1:(length(pages)-1)) {
rindex = (pages[p]+1) : pages[p+1]
temp.table = matrix('', nr = length(rindex)+1, nc = ncol(plot.matrix)+1)
temp.table[-1, -1] = plot.matrix[rindex,]
temp.table[1, -1] = colnames(plot.matrix)
temp.table[-1, 1] = rownames(plot.matrix)[rindex]
temp.table[1, 1] = smain
nr = nrow(temp.table)
nc = ncol(temp.table)
par(mar = c(0, 0, 0, 0), cex = 0.5)
oldpar = make.table(nr, nc)
text.cex = plot.matrix.cex[c(1, 1 + rindex), ]
text.cex = plot.table.helper.auto.adjust.cex(temp.table, keep.all.same.cex)
bg.col = plot.matrix_bg.col[c(1, 1 + rindex), ]
for(r in 1:nr) {
for(c in 1:nc) {
draw.cell( paste('', temp.table[r,c], '', sep=' '), r, c,
text.cex = text.cex[r,c], bg.col = bg.col[r,c], frame.cell = frame.cell)
}}
}
}
plot.table <- function(plot.matrix, smain="", text.cex=1, frame.cell=TRUE, highlight=FALSE, colorbar=FALSE, keep_all.same.cex=FALSE) {
if( is.null(rownames(plot.matrix)) & is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
if( ncol(temp.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[-1, -1, drop = FALSE]
colnames(plot.matrix) = temp.matrix[1, -1]
rownames(plot.matrix) = temp.matrix[-1, 1]
smain = temp.matrix[1, 1]
} else if( is.null(rownames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( ncol(plot.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[, -1, drop = FALSE]
colnames(plot.matrix) = colnames(temp.matrix)[-1]
rownames(plot.matrix) = temp.matrix[,1]
smain = colnames(temp.matrix)[1]
} else if( is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
plot.matrix = temp.matrix[-1, , drop = FALSE]
rownames(plot.matrix) = rownames(temp.matrix)[-1]
colnames(plot.matrix) = temp.matrix[1, ]
smain = rownames(temp.matrix)[1]
}
plot.matrix[which(trim(plot.matrix) == "NA")] = ""
plot.matrix[which(trim(plot.matrix) == "NA%")] = ""
plot.matrix[which(is.na(plot.matrix))] = ""
nr = nrow(plot.matrix) + 1
nc = ncol(plot.matrix) + 1
is_highlight = TRUE
if(is.logical(highlight)) {
is_highlight = highlight
if(highlight) highlight = plot.table.helper.color(plot.matrix)
}
if(!is_highlight) {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[seq(1, nr, 2), ] = "yellow"
plot.matrix_bg.col[1,] = "gray";
plot.table.param( plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
} else {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[1,] = "gray"
plot.matrix_bg.col[2:nr,2:nc] = highlight
plot.table.param(plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
}
}
plot.table.helper.color <- function (temp) {
temp = matrix(as.double(gsub("[%,$]", "", temp)), nrow(temp), ncol(temp))
highlight = as.vector(temp)
cols = rep(NA, length(highlight))
ncols = length(highlight[!is.na(highlight)])
cols[1:ncols] = rev(rainbow(ncols, start=0.5/6, end=3.5/6))
o = sort.list(highlight, na.last = TRUE, decreasing = FALSE)
o1 = sort.list(o, na.last = TRUE, decreasing = FALSE)
highlight = matrix(cols[o1], nrow = nrow(temp))
highlight[is.na(temp)] = NA
return(highlight)
}
ModelEst <- function(fit, df) {
# derive regression estimates from log(y) fit
mse <- rev(as.matrix(summary(fit)[[1]])[, "Mean Sq"])[1]
plpe <- predict(fit, newdata=df, se.fit=T)
m <- plpe$fit
v <- plpe$se.fit^2 + mse
exp(m + v/2)
}
myrange <- function(x) {
if(all(is.na(x))) r <- c(NA, NA) else r <- range(x, na.rm=TRUE)
return(r)
}
jackindex <- function(m) {
# m is a matrix of numbers (stream PEs) with observations (years) as rows and individuals (streams) as columns
if(any(is.na(m))) stop("The input matrix may not have any missing values.")
# calculate the index as the sum of the columns for each row
rowsum <- apply(m, 1, sum)
# calculate the mean of the index
avgind <- mean(rowsum)
# recalculate the index, leaving out one individual at a time
loo <- apply(m, 2, function(column) (rowsum - column))
# rescale the loo index, relative to mean
looscaled <- apply(loo, 2, function(x) x/mean(x))
# convert to original scale
looscaled2 <- looscaled * avgind
# calculate range
ranges <- t(apply(looscaled2, 1, range))
cbind(index=rowsum, lo=ranges[, 1], hi=ranges[, 2])
}
# selstreams <- index.streams[[1]] 
# allstreamdf <- dat
# alllakedf <- lk 
# min.nmr=2 
# show=FALSE
index.est <- function(selstreams, allstreamdf, alllakedf, min.nmr=2, show=FALSE) {
# INDEX OF ADULT SEA LAMPREY ABUNDANCE
### INPUTS
# selstreams = vector of stream ids, e.g., 1.064 (lake + strcode/1000)
# allstreamdf = data frame of mark-recap estimates for all streams, with vars:  year lake ls Emr CVmr
# alllakedf = data frame of lake-wide PEs from Mullett et al. (2003) spawner model with vars:  lake year PE
# min.nmr = minimum number of mark-recapture estimates needed in a year to generate an index, default 2
# show = print out a brief summary of the results, default FALSE
### OUTPUTS
# indfit = simple model used to predict missing mark-recap estimates
# streamdf = original allstreamdf, subsetted by selstreams, with estimates for missing mark-recaps
# indxdf = original alllakedf, subsetted by lake, with annual index, including raw (indxraw), kept based on min.nmr (indxkeep, indxkeep.lo, indxkeep.hi)
# scaleup = conversion factor used to scale up annual index to spawner model PE
streamdf <- allstreamdf[allstreamdf$ls %in% selstreams, ]
# error checks
check1 <- var(streamdf$lake)
if(is.na(check1) | is.null(check1)) stop("Either no streams selected or critical data missing.") else if(check1 > 0) stop("Selected streams should be only from ONE lake.")
if(any(is.na(match(c("year", "lake", "ls", "Emr", "CVmr"), names(allstreamdf))))) stop("allstreamdf must include these variables: year lake ls Emr CVmr.")
if(any(is.na(match(c("year", "lake", "PE"), names(alllakedf))))) stop("alllakedf must include these variables: lake year PE.")
# fill in missing mark-recap data
indfit <- aov(log(Emr) ~ as.factor(ls) + as.factor(year), data=streamdf, weights=1/CVmr^2)
# figure out estimable years (those with at least 1 m-r estimate)
n.mr <- tapply(!is.na(streamdf$Emr), streamdf$year, sum)
eyrs <- as.numeric(names(n.mr)[n.mr > 0.5])
estimable <- streamdf$year %in% eyrs
streamdf$Pmr <- NA
streamdf$Pmr[estimable] <- ModelEst(fit=indfit, df=streamdf[estimable, ])
streamdf$COMBmr <- ifelse(is.na(streamdf$Emr), streamdf$Pmr, streamdf$Emr)
# annual index (sum across streams)
indxdf <- aggregate(COMBmr ~ year + lake, streamdf, sum, na.rm=TRUE, na.action=na.pass)
names(indxdf)[names(indxdf)=="COMBmr"] <- "indxraw"
indxdf$indxraw[indxdf$indxraw==0] <- NA
# only keep lake-wide index for years with at least min.nmr mark-recap estimates
indxdf$n.mr <- n.mr
indxdf$indxkeep <- ifelse(indxdf$n.mr > (min.nmr - 0.5), indxdf$indxraw, NA)
indxdf$indxkeep.lo <- NA
indxdf$indxkeep.hi <- NA
# matrix of stream estimates (rows = years, columns = index streams)
streamests <- with(streamdf, tapply(COMBmr, list(year, ls), mean))
# selection of only those streams with a keepable index
selkeep <- !is.na(indxdf$indxkeep)
jack <- jackindex(streamests[selkeep, ])
indxdf$indxkeep.lo[selkeep] <- jack[, "lo"]
indxdf$indxkeep.hi[selkeep] <- jack[, "hi"]
# scale up the index to the spawner model PE
lk1 <- lk[lk$lake == streamdf$lake[1], ]
indxdf2 <- merge(lk1, indxdf, all=TRUE)
scaleup <- median(indxdf2$PE / indxdf2$indxkeep, na.rm=TRUE)
if(show) {
cat("\nindfit\n")
print(summary(indfit))
cat("\nstreamdf\n")
print(tail(streamdf[, c("lake", "year", "ls", "Emr", "CVmr", "Pmr", "COMBmr")]))
cat("\nscaleup\n")
print(scaleup)
cat("\nindxdf\n")
print(tail(indxdf[, c("lake", "year", "n.mr", "indxraw", "indxkeep", "indxkeep.lo", "indxkeep.hi")]))
}
list(indfit=indfit, streamdf=streamdf, scaleup=scaleup, indxdf=indxdf)
}
calctarg <- function(lakenum, adults, year, targyears, adjust=c(1, 1, 0.25, 1, 1)) {
# lakenum = vector of lake numbers (1-5)
# adults = vector of lakewide adult sea lamprey estimates
# year = vector of years
# targyears = list (length 5) of selected years from which to calculate targets
# lake huron target is 25% of
targets <- data.frame(lake=1:5, target=rep(NA, 5), lo=rep(NA, 5), hi=rep(NA, 5))
for(i in 1:5) {
pick5 <- adults[lakenum==i & is.element(year, targyears[[i]]) & !is.na(adults)]
if(length(pick5) > 0) {
targets$target[i] <- mean(pick5)
n <- length(pick5)
ci <- qnorm(1 - 0.05/2) * sqrt(var(pick5)) / sqrt(n)
targets[i, c("lo", "hi")] <- mean(pick5) + c(-1, 1)*ci# using z dist (known variance)
targets[i, c("target", "lo", "hi")] <- adjust[i]*targets[i, c("target", "lo", "hi")]
} else {
targets[i, c("target", "lo", "hi")] <- c(NA, NA, NA)
}
}
targets
}
}
# bring in lake-wide spawner data
lk <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/LakePEdynamic.csv", as.is=T)
# bring in stream-specific data
dat <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/StreamPEdynamicALLCOLS.csv", as.is=T)
dat$ls <- dat$lscode
# 2014-04-09 Jess and Gale agreed that the East Au Gres (38) should be replaced with the Au Sable (36) in Lake Huron
# 2014-04-10 Jess thinks that we should just stick with the East Au Gres (38)
index.streams <- list(
Sup = c(1, 2, 9, 29, 31, 32, 62),
Mic = c(5, 6, 15, 24, 26, 35),
Hur = c(10, 16, 27, 32, 999, 38),
Eri = c(1, 2, 3, 7, 9),
Ont = c(5, 9, 22, 23, 36)
)
index.streams <- lapply(1:5, function(i) i + index.streams[[i]]/1000)
# estimate adult index of abundance for each lake using index streams
indices <- lapply(index.streams, index.est, dat, lk)
# combine index data for all lakes in one dataframe
indxall <- do.call(rbind, lapply(indices, "[[", "indxdf"))
# calculate targets 
sptargyrz <- list(1994:1998, 1988:1992, 1989:1993, 1991:1995, 1999:2003)
targyrz <- apply(sapply(sptargyrz, range), 2, paste, collapse="-")
# spawner model
targets.sm <- calctarg(lakenum=lk$lake, adults=lk$PE, year=lk$year, targyears=sptargyrz)
# adult index
targets.ai <- calctarg(lakenum=indxall$lake, adults=indxall$indxkeep, year=indxall$year, targyears=sptargyrz)
# spawner model targets scaled down to adult index
targets.sm.su <- cbind(lake=targets.sm[, 1], (1/sapply(indices, "[[", "scaleup")) * targets.sm[, -1])
# adult index adjusted
targets.ai.adj <- targets.ai
targets.ai.adj[is.na(targets.ai$target), ] <- targets.sm.su[is.na(targets.ai$target), ]
YEAR1 <- 1984
# create a Word document with results
doc <- startrtf(file="2014-10 SLCB Index", dir="C:/JVA/Lamprey/Adults/AdultIndex/2014", omi=c(1, 1.25, 1, 1.25))
heading("Index of Adult Sea Lamprey Abundance in each Great Lake")
heading(paste("Adams, Barber, Bravener, Steeves -", as.character(Sys.Date())), htype=2)
### Spawner model time series
heading("Purpose of the index", htype=3)
heading("Selection of index streams", htype=3)
heading("Calculation of index", htype=3)
heading("Assumptions", htype=3)
heading("Fate of current spawner model", htype=3)
para("Conversion factors: ", paste(Lakenames, round(sapply(indices, "[[", "scaleup"), 2), collapse=", "), ".")
# position of text for selected streams in each lake (for map drawing)
posp <- list(c(3, 1, 3, 1, 1, 3, 1),
c(2, 2, 2, 2, 2, 2),
c(4, 4, 4, 4, 4, 4),
c(2, 2, 2, 2, 2),
c(2, 2, 2, 2, 2, 2))
### map of selected streams
mymap <- map5
fig <- function() {
par(mar=c(0, 0, 0, 0))
map(xlim=range(mymap$x, na.rm=T), ylim=range(mymap$y, na.rm=T), col=NA, mar=rep(1, 4))
lines(mymap$x, mymap$y, col="darkgray", lwd=0.5)
for(i in 1:5) {
mystreamdf <- indices[[i]]$streamdf
with(mystreamdf[mystreamdf$year==2010, ], {
points(long, lat, cex=1.5, pch=16)
par(xpd=NA)
text(long, lat, strname, cex=1.2, pos=posp[[i]], font=2)
})
}
}
figu("Streams selected for inclusion in the index of adult sea lamprey abundance.", w=9, h=5.5)
### bar plot of individual index stream PEs
col7 <- c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69")
fig <- function() {
par(mar=c(3, 3, 2, 1), mfrow=c(3, 2), las=1, yaxs="i", oma=c(2, 2, 0, 0), cex=1.4)
for(i in 1:5) {
mymap <- mapL[[i]]
mystreamdf <- indices[[i]]$streamdf
myindxdf <- indices[[i]]$indxdf
mystreamdf <- mystreamdf[mystreamdf$year >= YEAR1, ]
myindxdf <- myindxdf[myindxdf$year >= YEAR1, ]
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p[is.na(myindxdf$indxkeep), ] <- NA
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
a <- barplot(t(p)/1000, las=1, col=col7, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.01*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="", ylab="", main=Lakenames[i])
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2)
box()
legend("topleft", rev(colnames(p)), fill=rev(col7[1:dim(p)[2]]), cex=0.75, bty="n")
if(i==1) {
frame()
}
}
mtext("Year", outer=TRUE, side=1, cex=1.8)
mtext("Adult abundance  (thousands)", outer=TRUE, side=2, cex=1.8)
}
figu("Adult sea lamprey abundance estimates for index streams.", w=6, h=7.5)
### spawner model and adult index time series overlaid
fig <- function() {
par(mfrow=c(3, 2), mar=c(3, 3, 2, 3), oma=c(2, 2, 0, 0), cex=1.4, yaxs="i")
for(i in 1:5) {
mylk <- lk[lk$lake==i, ]# lake year PE lo hi
myindxdf <- indices[[i]]$indxdf# year lake indxraw n.mr indxkeep indxkeep.lo indxkeep.hi
convfac <- indices[[i]]$scaleup
x1 <- myindxdf$year
y1 <- myindxdf$indxkeep/1000
x2 <- mylk$year
y2 <- mylk$PE/convfac/1000
yr <- 1.05*range(0, y1, y2[x2>=YEAR1], na.rm=TRUE)
plot(1, 1, type="n", xlim=range(lk$year), ylim=yr, xlab="", ylab="", main=Lakenames[i], axes=FALSE)
axis(1)
axis(2, col=blindcolz[7], col.axis=blindcolz[7], las=1)
par(mgp=c(3, 2.2, 0))
axis(4, at=pretty(convfac*yr)/convfac, labels=pretty(convfac*yr), col=blindcolz[3], col.axis=blindcolz[3], las=1, hadj=1)
par(mgp=c(3, 1, 0))
box()
abline(h=targets.sm$target[i]/convfac/1000, col=blindcolz[3], lty=2)
abline(h=targets.ai.adj$target[i]/1000, col=blindcolz[7], lty=2)
lines(x2, y2, col=blindcolz[3], type="o", pch=18, lwd=2)
lines(x1, y1, col=blindcolz[7], type="o", pch=17, lwd=2)
if(i==1) {
plot(1, 1, type="n", xlab="", ylab="", axes=FALSE)
legend("center", c("Adult index", "Spawner model"), col=blindcolz[c(7, 3)], lwd=2, pch=c(17, 18))
}
}
mtext("Year", outer=TRUE, side=1, cex=1.8)
mtext("Adult abundance  (thousands)", outer=TRUE, side=2, cex=1.8)
}
figu("Patterns over time in adult sea lamprey abundance, comparing the newly derived index with the spawner model.",
"  Targets are indicated by dashed horizontal lines.",
"  Targets are based on averages from five years with historically acceptable wounding rates: ", paste(paste(targyrz, "in", Lakenames), collapse=", "), ".", 
w=6, h=7.5)
endrtf()
rm(targyrz, i)
names(indices[[1]])
# "indfit"   "streamdf" "scaleup"  "indxdf"
# scale up
round(sapply(indices, "[[", 3), 2)
# 3.84 1.85 2.82 1.01 2.40
indxall[7:11, ]
   # year lake   indxraw n.mr  indxkeep indxkeep.lo indxkeep.hi
# 7  1986    1 24275.673    5 24275.673   18726.753   27579.203
# 8  1987    1 10994.483    5 10994.483   10269.609   11494.884
# 9  1988    1 13630.037    5 13630.037   11710.612   14680.398
# 10 1989    1 20227.926    6 20227.926   18704.166   21988.594
# 11 1990    1  9332.001    5  9332.001    8435.646   11991.514
# C:\JVA\Lamprey\Adults\AdultIndex\2014\AdultIndex v2.r
{ # functions
# the following seven plot.table related function are from the Systmatic Investor Toolbox
# load Systematic Investor Toolbox
# require(RCurl)
# sit = getURLContent("https://github.com/systematicinvestor/SIT/raw/master/sit.gz", binary=TRUE, followlocation=TRUE, ssl.verifypeer=FALSE)
# con = gzcon(rawConnection(sit, "rb"))
# source(con)
# close(con)
draw.cell <- function(title, r, c, text.cex = 1, bg.col = 'white', frame.cell = T) {
if(!frame.cell) bcol = bg.col else bcol = 'black'
rect((2*(c - 1) + .5), -(r - .5), (2*c + .5), -(r + .5), col = bg.col, border = bcol)
if( c == 1) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else if( r == 1 ) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else {
text((2*c + .5), -r, title, adj = 1, cex = text.cex)
}
}
plot.table.helper.auto.adjust.cex <- function(temp.table, keep.all.same.cex = FALSE) {
nr = nrow(temp.table)
nc = ncol(temp.table)
all.xrange = diff(par()$usr[1:2]) / nc
xrange = matrix( strwidth(paste('  ', temp.table), units = 'user', cex = 1), nc = nc)
all.yrange = diff(par()$usr[3:4]) / nr
yrange = matrix( 5/3 * strheight(temp.table, units = 'user', cex = 1), nc = nc)
plot.matrix.cex = pmin( round(all.yrange / yrange, 2) , round(all.xrange / xrange, 2) )
header.col.cex = min(plot.matrix.cex[1,-1])
header.row.cex = min(plot.matrix.cex[-1,1])
title.cex = plot.matrix.cex[1, 1]
data.cex = min(plot.matrix.cex[-1, -1])
if ( keep.all.same.cex ) {
plot.matrix.cex[] = min(plot.matrix.cex)
} else {
plot.matrix.cex[1,-1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,-1]= min(c(header.col.cex, header.row.cex, data.cex))
plot.matrix.cex[1,1]= min(c(header.col.cex, header.row.cex, data.cex, title.cex))
plot.matrix.cex[1,-1] = min(c(header.col.cex))
plot.matrix.cex[-1,1] = min(c(header.row.cex))
plot.matrix.cex[-1,-1]= min(c(data.cex))
plot.matrix.cex[1,1]= min(c(title.cex))
}
return(plot.matrix.cex)
}
make.table <- function(nr, nc) {
savepar = par(mar = rep(1, 4))
plot(c(0.5, nc*2 + 0.5), c(-0.5, -(nr + 0.5)), xaxs = 'i', yaxs = 'i',
type = 'n', xlab = '', ylab = '', axes = FALSE)
savepar
}
trim <- function(s) {
s = sub(pattern = '^ +', replacement = '', x = s)
s = sub(pattern = ' +$', replacement = '', x = s)
return(s)
}
plot.table.param <- function(plot.matrix, smain = '', plot.matrix.cex, plot.matrix_bg.col, frame.cell = T, keep.all.same.cex = FALSE) {
n = nrow(plot.matrix)
pages = unique(c(seq(0, n, by = 120), n))
for(p in 1:(length(pages)-1)) {
rindex = (pages[p]+1) : pages[p+1]
temp.table = matrix('', nr = length(rindex)+1, nc = ncol(plot.matrix)+1)
temp.table[-1, -1] = plot.matrix[rindex,]
temp.table[1, -1] = colnames(plot.matrix)
temp.table[-1, 1] = rownames(plot.matrix)[rindex]
temp.table[1, 1] = smain
nr = nrow(temp.table)
nc = ncol(temp.table)
par(mar = c(0, 0, 0, 0), cex = 0.5)
oldpar = make.table(nr, nc)
text.cex = plot.matrix.cex[c(1, 1 + rindex), ]
text.cex = plot.table.helper.auto.adjust.cex(temp.table, keep.all.same.cex)
bg.col = plot.matrix_bg.col[c(1, 1 + rindex), ]
for(r in 1:nr) {
for(c in 1:nc) {
draw.cell( paste('', temp.table[r,c], '', sep=' '), r, c,
text.cex = text.cex[r,c], bg.col = bg.col[r,c], frame.cell = frame.cell)
}}
}
}
plot.table <- function(plot.matrix, smain="", text.cex=1, frame.cell=TRUE, highlight=FALSE, colorbar=FALSE, keep_all.same.cex=FALSE) {
if( is.null(rownames(plot.matrix)) & is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
if( ncol(temp.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[-1, -1, drop = FALSE]
colnames(plot.matrix) = temp.matrix[1, -1]
rownames(plot.matrix) = temp.matrix[-1, 1]
smain = temp.matrix[1, 1]
} else if( is.null(rownames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( ncol(plot.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[, -1, drop = FALSE]
colnames(plot.matrix) = colnames(temp.matrix)[-1]
rownames(plot.matrix) = temp.matrix[,1]
smain = colnames(temp.matrix)[1]
} else if( is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
plot.matrix = temp.matrix[-1, , drop = FALSE]
rownames(plot.matrix) = rownames(temp.matrix)[-1]
colnames(plot.matrix) = temp.matrix[1, ]
smain = rownames(temp.matrix)[1]
}
plot.matrix[which(trim(plot.matrix) == "NA")] = ""
plot.matrix[which(trim(plot.matrix) == "NA%")] = ""
plot.matrix[which(is.na(plot.matrix))] = ""
nr = nrow(plot.matrix) + 1
nc = ncol(plot.matrix) + 1
is_highlight = TRUE
if(is.logical(highlight)) {
is_highlight = highlight
if(highlight) highlight = plot.table.helper.color(plot.matrix)
}
if(!is_highlight) {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[seq(1, nr, 2), ] = "yellow"
plot.matrix_bg.col[1,] = "gray";
plot.table.param( plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
} else {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[1,] = "gray"
plot.matrix_bg.col[2:nr,2:nc] = highlight
plot.table.param(plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
}
}
plot.table.helper.color <- function (temp) {
temp = matrix(as.double(gsub("[%,$]", "", temp)), nrow(temp), ncol(temp))
highlight = as.vector(temp)
cols = rep(NA, length(highlight))
ncols = length(highlight[!is.na(highlight)])
cols[1:ncols] = rev(rainbow(ncols, start=0.5/6, end=3.5/6))
o = sort.list(highlight, na.last = TRUE, decreasing = FALSE)
o1 = sort.list(o, na.last = TRUE, decreasing = FALSE)
highlight = matrix(cols[o1], nrow = nrow(temp))
highlight[is.na(temp)] = NA
return(highlight)
}
ModelEst <- function(fit, df) {
# derive regression estimates from log(y) fit
mse <- rev(as.matrix(summary(fit)[[1]])[, "Mean Sq"])[1]
plpe <- predict(fit, newdata=df, se.fit=T)
m <- plpe$fit
v <- plpe$se.fit^2 + mse
exp(m + v/2)
}
myrange <- function(x) {
if(all(is.na(x))) r <- c(NA, NA) else r <- range(x, na.rm=TRUE)
return(r)
}
jackindex <- function(m) {
# m is a matrix of numbers (stream PEs) with observations (years) as rows and individuals (streams) as columns
if(any(is.na(m))) stop("The input matrix may not have any missing values.")
# calculate the index as the sum of the columns for each row
rowsum <- apply(m, 1, sum)
# calculate the mean of the index
avgind <- mean(rowsum)
# recalculate the index, leaving out one individual at a time
loo <- apply(m, 2, function(column) (rowsum - column))
# rescale the loo index, relative to mean
looscaled <- apply(loo, 2, function(x) x/mean(x))
# convert to original scale
looscaled2 <- looscaled * avgind
# calculate range
ranges <- t(apply(looscaled2, 1, range))
cbind(index=rowsum, lo=ranges[, 1], hi=ranges[, 2])
}
# selstreams <- index.streams[[1]] 
# allstreamdf <- dat
# alllakedf <- lk 
# min.nmr=2 
# show=FALSE
index.est <- function(selstreams, allstreamdf, alllakedf, min.nmr=2, show=FALSE) {
# INDEX OF ADULT SEA LAMPREY ABUNDANCE
### INPUTS
# selstreams = vector of stream ids, e.g., 1.064 (lake + strcode/1000)
# allstreamdf = data frame of mark-recap estimates for all streams, with vars:  year lake ls Emr CVmr
# alllakedf = data frame of lake-wide PEs from Mullett et al. (2003) spawner model with vars:  lake year PE
# min.nmr = minimum number of mark-recapture estimates needed in a year to generate an index, default 2
# show = print out a brief summary of the results, default FALSE
### OUTPUTS
# indfit = simple model used to predict missing mark-recap estimates
# streamdf = original allstreamdf, subsetted by selstreams, with estimates for missing mark-recaps
# indxdf = original alllakedf, subsetted by lake, with annual index, including raw (indxraw), kept based on min.nmr (indxkeep, indxkeep.lo, indxkeep.hi)
# scaleup = conversion factor used to scale up annual index to spawner model PE
streamdf <- allstreamdf[allstreamdf$ls %in% selstreams, ]
# error checks
check1 <- var(streamdf$lake)
if(is.na(check1) | is.null(check1)) stop("Either no streams selected or critical data missing.") else if(check1 > 0) stop("Selected streams should be only from ONE lake.")
if(any(is.na(match(c("year", "lake", "ls", "Emr", "CVmr"), names(allstreamdf))))) stop("allstreamdf must include these variables: year lake ls Emr CVmr.")
if(any(is.na(match(c("year", "lake", "PE"), names(alllakedf))))) stop("alllakedf must include these variables: lake year PE.")
# fill in missing mark-recap data
indfit <- aov(log(Emr) ~ as.factor(ls) + as.factor(year), data=streamdf, weights=1/CVmr^2)
# figure out estimable years (those with at least 1 m-r estimate)
n.mr <- tapply(!is.na(streamdf$Emr), streamdf$year, sum)
eyrs <- as.numeric(names(n.mr)[n.mr > 0.5])
estimable <- streamdf$year %in% eyrs
streamdf$Pmr <- NA
streamdf$Pmr[estimable] <- ModelEst(fit=indfit, df=streamdf[estimable, ])
streamdf$COMBmr <- ifelse(is.na(streamdf$Emr), streamdf$Pmr, streamdf$Emr)
# annual index (sum across streams)
indxdf <- aggregate(COMBmr ~ year + lake, streamdf, sum, na.rm=TRUE, na.action=na.pass)
names(indxdf)[names(indxdf)=="COMBmr"] <- "indxraw"
indxdf$indxraw[indxdf$indxraw==0] <- NA
# only keep lake-wide index for years with at least min.nmr mark-recap estimates
indxdf$n.mr <- n.mr
indxdf$indxkeep <- ifelse(indxdf$n.mr > (min.nmr - 0.5), indxdf$indxraw, NA)
indxdf$indxkeep.lo <- NA
indxdf$indxkeep.hi <- NA
# matrix of stream estimates (rows = years, columns = index streams)
streamests <- with(streamdf, tapply(COMBmr, list(year, ls), mean))
# selection of only those streams with a keepable index
selkeep <- !is.na(indxdf$indxkeep)
jack <- jackindex(streamests[selkeep, ])
indxdf$indxkeep.lo[selkeep] <- jack[, "lo"]
indxdf$indxkeep.hi[selkeep] <- jack[, "hi"]
# scale up the index to the spawner model PE
lk1 <- lk[lk$lake == streamdf$lake[1], ]
indxdf2 <- merge(lk1, indxdf, all=TRUE)
scaleup <- median(indxdf2$PE / indxdf2$indxkeep, na.rm=TRUE)
if(show) {
cat("\nindfit\n")
print(summary(indfit))
cat("\nstreamdf\n")
print(tail(streamdf[, c("lake", "year", "ls", "Emr", "CVmr", "Pmr", "COMBmr")]))
cat("\nscaleup\n")
print(scaleup)
cat("\nindxdf\n")
print(tail(indxdf[, c("lake", "year", "n.mr", "indxraw", "indxkeep", "indxkeep.lo", "indxkeep.hi")]))
}
list(indfit=indfit, streamdf=streamdf, scaleup=scaleup, indxdf=indxdf)
}
calctarg <- function(lakenum, adults, year, targyears, adjust=c(1, 1, 0.25, 1, 1)) {
# lakenum = vector of lake numbers (1-5)
# adults = vector of lakewide adult sea lamprey estimates
# year = vector of years
# targyears = list (length 5) of selected years from which to calculate targets
# lake huron target is 25% of
targets <- data.frame(lake=1:5, target=rep(NA, 5), lo=rep(NA, 5), hi=rep(NA, 5))
for(i in 1:5) {
pick5 <- adults[lakenum==i & is.element(year, targyears[[i]]) & !is.na(adults)]
if(length(pick5) > 0) {
targets$target[i] <- mean(pick5)
n <- length(pick5)
ci <- qnorm(1 - 0.05/2) * sqrt(var(pick5)) / sqrt(n)
targets[i, c("lo", "hi")] <- mean(pick5) + c(-1, 1)*ci# using z dist (known variance)
targets[i, c("target", "lo", "hi")] <- adjust[i]*targets[i, c("target", "lo", "hi")]
} else {
targets[i, c("target", "lo", "hi")] <- c(NA, NA, NA)
}
}
targets
}
}
# bring in lake-wide spawner data
lk <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/LakePEdynamic.csv", as.is=T)
# bring in stream-specific data
dat <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/StreamPEdynamicALLCOLS.csv", as.is=T)
dat$ls <- dat$lscode
# 2014-04-09 Jess and Gale agreed that the East Au Gres (38) should be replaced with the Au Sable (36) in Lake Huron
# 2014-04-10 Jess thinks that we should just stick with the East Au Gres (38)
index.streams <- list(
Sup = c(1, 2, 9, 29, 31, 32, 62),
Mic = c(5, 6, 15, 24, 26, 35),
Hur = c(10, 16, 27, 32, 999, 38),
Eri = c(1, 2, 3, 7, 9),
Ont = c(5, 9, 22, 23, 36)
)
index.streams <- lapply(1:5, function(i) i + index.streams[[i]]/1000)
# estimate adult index of abundance for each lake using index streams
indices <- lapply(index.streams, index.est, dat, lk)
# combine index data for all lakes in one dataframe
indxall <- do.call(rbind, lapply(indices, "[[", "indxdf"))
# calculate targets 
sptargyrz <- list(1994:1998, 1988:1992, 1989:1993, 1991:1995, 1999:2003)
targyrz <- apply(sapply(sptargyrz, range), 2, paste, collapse="-")
# spawner model
targets.sm <- calctarg(lakenum=lk$lake, adults=lk$PE, year=lk$year, targyears=sptargyrz)
# adult index
targets.ai <- calctarg(lakenum=indxall$lake, adults=indxall$indxkeep, year=indxall$year, targyears=sptargyrz)
# spawner model targets scaled down to adult index
targets.sm.su <- cbind(lake=targets.sm[, 1], (1/sapply(indices, "[[", "scaleup")) * targets.sm[, -1])
# adult index adjusted
targets.ai.adj <- targets.ai
targets.ai.adj[is.na(targets.ai$target), ] <- targets.sm.su[is.na(targets.ai$target), ]
YEAR1 <- 1984
# create a Word document with results
doc <- startrtf(file="2014-10 SLCB Index", dir="C:/JVA/Lamprey/Adults/AdultIndex/2014", omi=c(1, 1.25, 1, 1.25))
heading("Index of Adult Sea Lamprey Abundance in each Great Lake")
heading(paste("Adams, Barber, Bravener, Steeves -", as.character(Sys.Date())), htype=2)
### Spawner model time series
heading("Purpose of the index", htype=3)
heading("Selection of index streams", htype=3)
heading("Calculation of index", htype=3)
heading("Assumptions", htype=3)
heading("Fate of current spawner model", htype=3)
para("Conversion factors: ", paste(Lakenames, round(sapply(indices, "[[", "scaleup"), 2), collapse=", "), ".")
# position of text for selected streams in each lake (for map drawing)
posp <- list(c(3, 1, 3, 1, 1, 3, 1),
c(2, 2, 2, 2, 2, 2),
c(4, 4, 4, 4, 4, 4),
c(2, 2, 2, 2, 2),
c(2, 2, 2, 2, 2, 2))
### map of selected streams
mymap <- map5
fig <- function() {
par(mar=c(0, 0, 0, 0))
map(xlim=range(mymap$x, na.rm=T), ylim=range(mymap$y, na.rm=T), col=NA, mar=rep(1, 4))
lines(mymap$x, mymap$y, col="darkgray", lwd=0.5)
for(i in 1:5) {
mystreamdf <- indices[[i]]$streamdf
with(mystreamdf[mystreamdf$year==2010, ], {
points(long, lat, cex=1.5, pch=16)
par(xpd=NA)
text(long, lat, strname, cex=1.2, pos=posp[[i]], font=2)
})
}
}
figu("Streams selected for inclusion in the index of adult sea lamprey abundance.", w=9, h=5.5)
### bar plot of individual index stream PEs
col7 <- c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69")
fig <- function() {
par(mar=c(3, 3, 2, 1), mfrow=c(3, 2), yaxs="i", oma=c(2, 2, 0, 0), cex=1.2)
for(i in 1:5) {
mymap <- mapL[[i]]
mystreamdf <- indices[[i]]$streamdf
myindxdf <- indices[[i]]$indxdf
mystreamdf <- mystreamdf[mystreamdf$year >= YEAR1, ]
myindxdf <- myindxdf[myindxdf$year >= YEAR1, ]
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p[is.na(myindxdf$indxkeep), ] <- NA
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
a <- barplot(t(p)/1000, las=1, col=col7, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.01*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="", ylab="", main=Lakenames[i], las=1)
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2)
box()
legend("topleft", rev(colnames(p)), fill=rev(col7[1:dim(p)[2]]), cex=0.5, bty="n")
if(i==1) {
frame()
}
}
mtext("Year", outer=TRUE, side=1)
mtext("Adult abundance  (thousands)", outer=TRUE, side=2, cex=1.2)
}
figu("Adult sea lamprey abundance estimates for index streams.", w=6, h=7.5)
### spawner model and adult index time series overlaid
fig <- function() {
par(mfrow=c(3, 2), mar=c(3, 3, 2, 3), oma=c(2, 2, 0, 0), cex=1.2, yaxs="i")
for(i in 1:5) {
mylk <- lk[lk$lake==i, ]# lake year PE lo hi
myindxdf <- indices[[i]]$indxdf# year lake indxraw n.mr indxkeep indxkeep.lo indxkeep.hi
convfac <- indices[[i]]$scaleup
x1 <- myindxdf$year
y1 <- myindxdf$indxkeep/1000
x2 <- mylk$year
y2 <- mylk$PE/convfac/1000
yr <- 1.05*range(0, y1, y2[x2>=YEAR1], na.rm=TRUE)
plot(1, 1, type="n", xlim=range(lk$year), ylim=yr, xlab="", ylab="", main=Lakenames[i], axes=FALSE)
axis(1)
axis(2, col=blindcolz[7], col.axis=blindcolz[7], las=1)
par(mgp=c(3, 2.2, 0))
axis(4, at=pretty(convfac*yr)/convfac, labels=pretty(convfac*yr), col=blindcolz[3], col.axis=blindcolz[3], las=1, hadj=1)
par(mgp=c(3, 1, 0))
box()
abline(h=targets.sm$target[i]/convfac/1000, col=blindcolz[3], lty=2)
abline(h=targets.ai.adj$target[i]/1000, col=blindcolz[7], lty=2)
lines(x2, y2, col=blindcolz[3], type="o", pch=18, lwd=2)
lines(x1, y1, col=blindcolz[7], type="o", pch=17, lwd=2)
if(i==1) {
plot(1, 1, type="n", xlab="", ylab="", axes=FALSE)
legend("center", c("Adult index", "Spawner model"), col=blindcolz[c(7, 3)], lwd=2, pch=c(17, 18))
}
}
mtext("Year", outer=TRUE, side=1, cex=1.8)
mtext("Adult abundance  (thousands)", outer=TRUE, side=2, cex=1.8)
}
figu("Patterns over time in adult sea lamprey abundance, comparing the newly derived index with the spawner model.",
"  Targets are indicated by dashed horizontal lines.",
"  Targets are based on averages from five years with historically acceptable wounding rates: ", paste(paste(targyrz, "in", Lakenames), collapse=", "), ".", 
w=6, h=7.5)
endrtf()
names(indices[[1]])
# "indfit"   "streamdf" "scaleup"  "indxdf"
# scale up
round(sapply(indices, "[[", 3), 2)
# 3.84 1.85 2.82 1.01 2.40
indxall[7:11, ]
   # year lake   indxraw n.mr  indxkeep indxkeep.lo indxkeep.hi
# 7  1986    1 24275.673    5 24275.673   18726.753   27579.203
# 8  1987    1 10994.483    5 10994.483   10269.609   11494.884
# 9  1988    1 13630.037    5 13630.037   11710.612   14680.398
# 10 1989    1 20227.926    6 20227.926   18704.166   21988.594
# 11 1990    1  9332.001    5  9332.001    8435.646   11991.514
# C:\JVA\Lamprey\Adults\AdultIndex\2014\AdultIndex v2.r
{ # functions
# the following seven plot.table related function are from the Systmatic Investor Toolbox
# load Systematic Investor Toolbox
# require(RCurl)
# sit = getURLContent("https://github.com/systematicinvestor/SIT/raw/master/sit.gz", binary=TRUE, followlocation=TRUE, ssl.verifypeer=FALSE)
# con = gzcon(rawConnection(sit, "rb"))
# source(con)
# close(con)
draw.cell <- function(title, r, c, text.cex = 1, bg.col = 'white', frame.cell = T) {
if(!frame.cell) bcol = bg.col else bcol = 'black'
rect((2*(c - 1) + .5), -(r - .5), (2*c + .5), -(r + .5), col = bg.col, border = bcol)
if( c == 1) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else if( r == 1 ) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else {
text((2*c + .5), -r, title, adj = 1, cex = text.cex)
}
}
plot.table.helper.auto.adjust.cex <- function(temp.table, keep.all.same.cex = FALSE) {
nr = nrow(temp.table)
nc = ncol(temp.table)
all.xrange = diff(par()$usr[1:2]) / nc
xrange = matrix( strwidth(paste('  ', temp.table), units = 'user', cex = 1), nc = nc)
all.yrange = diff(par()$usr[3:4]) / nr
yrange = matrix( 5/3 * strheight(temp.table, units = 'user', cex = 1), nc = nc)
plot.matrix.cex = pmin( round(all.yrange / yrange, 2) , round(all.xrange / xrange, 2) )
header.col.cex = min(plot.matrix.cex[1,-1])
header.row.cex = min(plot.matrix.cex[-1,1])
title.cex = plot.matrix.cex[1, 1]
data.cex = min(plot.matrix.cex[-1, -1])
if ( keep.all.same.cex ) {
plot.matrix.cex[] = min(plot.matrix.cex)
} else {
plot.matrix.cex[1,-1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,-1]= min(c(header.col.cex, header.row.cex, data.cex))
plot.matrix.cex[1,1]= min(c(header.col.cex, header.row.cex, data.cex, title.cex))
plot.matrix.cex[1,-1] = min(c(header.col.cex))
plot.matrix.cex[-1,1] = min(c(header.row.cex))
plot.matrix.cex[-1,-1]= min(c(data.cex))
plot.matrix.cex[1,1]= min(c(title.cex))
}
return(plot.matrix.cex)
}
make.table <- function(nr, nc) {
savepar = par(mar = rep(1, 4))
plot(c(0.5, nc*2 + 0.5), c(-0.5, -(nr + 0.5)), xaxs = 'i', yaxs = 'i',
type = 'n', xlab = '', ylab = '', axes = FALSE)
savepar
}
trim <- function(s) {
s = sub(pattern = '^ +', replacement = '', x = s)
s = sub(pattern = ' +$', replacement = '', x = s)
return(s)
}
plot.table.param <- function(plot.matrix, smain = '', plot.matrix.cex, plot.matrix_bg.col, frame.cell = T, keep.all.same.cex = FALSE) {
n = nrow(plot.matrix)
pages = unique(c(seq(0, n, by = 120), n))
for(p in 1:(length(pages)-1)) {
rindex = (pages[p]+1) : pages[p+1]
temp.table = matrix('', nr = length(rindex)+1, nc = ncol(plot.matrix)+1)
temp.table[-1, -1] = plot.matrix[rindex,]
temp.table[1, -1] = colnames(plot.matrix)
temp.table[-1, 1] = rownames(plot.matrix)[rindex]
temp.table[1, 1] = smain
nr = nrow(temp.table)
nc = ncol(temp.table)
par(mar = c(0, 0, 0, 0), cex = 0.5)
oldpar = make.table(nr, nc)
text.cex = plot.matrix.cex[c(1, 1 + rindex), ]
text.cex = plot.table.helper.auto.adjust.cex(temp.table, keep.all.same.cex)
bg.col = plot.matrix_bg.col[c(1, 1 + rindex), ]
for(r in 1:nr) {
for(c in 1:nc) {
draw.cell( paste('', temp.table[r,c], '', sep=' '), r, c,
text.cex = text.cex[r,c], bg.col = bg.col[r,c], frame.cell = frame.cell)
}}
}
}
plot.table <- function(plot.matrix, smain="", text.cex=1, frame.cell=TRUE, highlight=FALSE, colorbar=FALSE, keep_all.same.cex=FALSE) {
if( is.null(rownames(plot.matrix)) & is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
if( ncol(temp.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[-1, -1, drop = FALSE]
colnames(plot.matrix) = temp.matrix[1, -1]
rownames(plot.matrix) = temp.matrix[-1, 1]
smain = temp.matrix[1, 1]
} else if( is.null(rownames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( ncol(plot.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[, -1, drop = FALSE]
colnames(plot.matrix) = colnames(temp.matrix)[-1]
rownames(plot.matrix) = temp.matrix[,1]
smain = colnames(temp.matrix)[1]
} else if( is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
plot.matrix = temp.matrix[-1, , drop = FALSE]
rownames(plot.matrix) = rownames(temp.matrix)[-1]
colnames(plot.matrix) = temp.matrix[1, ]
smain = rownames(temp.matrix)[1]
}
plot.matrix[which(trim(plot.matrix) == "NA")] = ""
plot.matrix[which(trim(plot.matrix) == "NA%")] = ""
plot.matrix[which(is.na(plot.matrix))] = ""
nr = nrow(plot.matrix) + 1
nc = ncol(plot.matrix) + 1
is_highlight = TRUE
if(is.logical(highlight)) {
is_highlight = highlight
if(highlight) highlight = plot.table.helper.color(plot.matrix)
}
if(!is_highlight) {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[seq(1, nr, 2), ] = "yellow"
plot.matrix_bg.col[1,] = "gray";
plot.table.param( plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
} else {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[1,] = "gray"
plot.matrix_bg.col[2:nr,2:nc] = highlight
plot.table.param(plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
}
}
plot.table.helper.color <- function (temp) {
temp = matrix(as.double(gsub("[%,$]", "", temp)), nrow(temp), ncol(temp))
highlight = as.vector(temp)
cols = rep(NA, length(highlight))
ncols = length(highlight[!is.na(highlight)])
cols[1:ncols] = rev(rainbow(ncols, start=0.5/6, end=3.5/6))
o = sort.list(highlight, na.last = TRUE, decreasing = FALSE)
o1 = sort.list(o, na.last = TRUE, decreasing = FALSE)
highlight = matrix(cols[o1], nrow = nrow(temp))
highlight[is.na(temp)] = NA
return(highlight)
}
ModelEst <- function(fit, df) {
# derive regression estimates from log(y) fit
mse <- rev(as.matrix(summary(fit)[[1]])[, "Mean Sq"])[1]
plpe <- predict(fit, newdata=df, se.fit=T)
m <- plpe$fit
v <- plpe$se.fit^2 + mse
exp(m + v/2)
}
myrange <- function(x) {
if(all(is.na(x))) r <- c(NA, NA) else r <- range(x, na.rm=TRUE)
return(r)
}
jackindex <- function(m) {
# m is a matrix of numbers (stream PEs) with observations (years) as rows and individuals (streams) as columns
if(any(is.na(m))) stop("The input matrix may not have any missing values.")
# calculate the index as the sum of the columns for each row
rowsum <- apply(m, 1, sum)
# calculate the mean of the index
avgind <- mean(rowsum)
# recalculate the index, leaving out one individual at a time
loo <- apply(m, 2, function(column) (rowsum - column))
# rescale the loo index, relative to mean
looscaled <- apply(loo, 2, function(x) x/mean(x))
# convert to original scale
looscaled2 <- looscaled * avgind
# calculate range
ranges <- t(apply(looscaled2, 1, range))
cbind(index=rowsum, lo=ranges[, 1], hi=ranges[, 2])
}
# selstreams <- index.streams[[1]] 
# allstreamdf <- dat
# alllakedf <- lk 
# min.nmr=2 
# show=FALSE
index.est <- function(selstreams, allstreamdf, alllakedf, min.nmr=2, show=FALSE) {
# INDEX OF ADULT SEA LAMPREY ABUNDANCE
### INPUTS
# selstreams = vector of stream ids, e.g., 1.064 (lake + strcode/1000)
# allstreamdf = data frame of mark-recap estimates for all streams, with vars:  year lake ls Emr CVmr
# alllakedf = data frame of lake-wide PEs from Mullett et al. (2003) spawner model with vars:  lake year PE
# min.nmr = minimum number of mark-recapture estimates needed in a year to generate an index, default 2
# show = print out a brief summary of the results, default FALSE
### OUTPUTS
# indfit = simple model used to predict missing mark-recap estimates
# streamdf = original allstreamdf, subsetted by selstreams, with estimates for missing mark-recaps
# indxdf = original alllakedf, subsetted by lake, with annual index, including raw (indxraw), kept based on min.nmr (indxkeep, indxkeep.lo, indxkeep.hi)
# scaleup = conversion factor used to scale up annual index to spawner model PE
streamdf <- allstreamdf[allstreamdf$ls %in% selstreams, ]
# error checks
check1 <- var(streamdf$lake)
if(is.na(check1) | is.null(check1)) stop("Either no streams selected or critical data missing.") else if(check1 > 0) stop("Selected streams should be only from ONE lake.")
if(any(is.na(match(c("year", "lake", "ls", "Emr", "CVmr"), names(allstreamdf))))) stop("allstreamdf must include these variables: year lake ls Emr CVmr.")
if(any(is.na(match(c("year", "lake", "PE"), names(alllakedf))))) stop("alllakedf must include these variables: lake year PE.")
# fill in missing mark-recap data
indfit <- aov(log(Emr) ~ as.factor(ls) + as.factor(year), data=streamdf, weights=1/CVmr^2)
# figure out estimable years (those with at least 1 m-r estimate)
n.mr <- tapply(!is.na(streamdf$Emr), streamdf$year, sum)
eyrs <- as.numeric(names(n.mr)[n.mr > 0.5])
estimable <- streamdf$year %in% eyrs
streamdf$Pmr <- NA
streamdf$Pmr[estimable] <- ModelEst(fit=indfit, df=streamdf[estimable, ])
streamdf$COMBmr <- ifelse(is.na(streamdf$Emr), streamdf$Pmr, streamdf$Emr)
# annual index (sum across streams)
indxdf <- aggregate(COMBmr ~ year + lake, streamdf, sum, na.rm=TRUE, na.action=na.pass)
names(indxdf)[names(indxdf)=="COMBmr"] <- "indxraw"
indxdf$indxraw[indxdf$indxraw==0] <- NA
# only keep lake-wide index for years with at least min.nmr mark-recap estimates
indxdf$n.mr <- n.mr
indxdf$indxkeep <- ifelse(indxdf$n.mr > (min.nmr - 0.5), indxdf$indxraw, NA)
indxdf$indxkeep.lo <- NA
indxdf$indxkeep.hi <- NA
# matrix of stream estimates (rows = years, columns = index streams)
streamests <- with(streamdf, tapply(COMBmr, list(year, ls), mean))
# selection of only those streams with a keepable index
selkeep <- !is.na(indxdf$indxkeep)
jack <- jackindex(streamests[selkeep, ])
indxdf$indxkeep.lo[selkeep] <- jack[, "lo"]
indxdf$indxkeep.hi[selkeep] <- jack[, "hi"]
# scale up the index to the spawner model PE
lk1 <- lk[lk$lake == streamdf$lake[1], ]
indxdf2 <- merge(lk1, indxdf, all=TRUE)
scaleup <- median(indxdf2$PE / indxdf2$indxkeep, na.rm=TRUE)
if(show) {
cat("\nindfit\n")
print(summary(indfit))
cat("\nstreamdf\n")
print(tail(streamdf[, c("lake", "year", "ls", "Emr", "CVmr", "Pmr", "COMBmr")]))
cat("\nscaleup\n")
print(scaleup)
cat("\nindxdf\n")
print(tail(indxdf[, c("lake", "year", "n.mr", "indxraw", "indxkeep", "indxkeep.lo", "indxkeep.hi")]))
}
list(indfit=indfit, streamdf=streamdf, scaleup=scaleup, indxdf=indxdf)
}
calctarg <- function(lakenum, adults, year, targyears, adjust=c(1, 1, 0.25, 1, 1)) {
# lakenum = vector of lake numbers (1-5)
# adults = vector of lakewide adult sea lamprey estimates
# year = vector of years
# targyears = list (length 5) of selected years from which to calculate targets
# lake huron target is 25% of
targets <- data.frame(lake=1:5, target=rep(NA, 5), lo=rep(NA, 5), hi=rep(NA, 5))
for(i in 1:5) {
pick5 <- adults[lakenum==i & is.element(year, targyears[[i]]) & !is.na(adults)]
if(length(pick5) > 0) {
targets$target[i] <- mean(pick5)
n <- length(pick5)
ci <- qnorm(1 - 0.05/2) * sqrt(var(pick5)) / sqrt(n)
targets[i, c("lo", "hi")] <- mean(pick5) + c(-1, 1)*ci# using z dist (known variance)
targets[i, c("target", "lo", "hi")] <- adjust[i]*targets[i, c("target", "lo", "hi")]
} else {
targets[i, c("target", "lo", "hi")] <- c(NA, NA, NA)
}
}
targets
}
}
# bring in lake-wide spawner data
lk <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/LakePEdynamic.csv", as.is=T)
# bring in stream-specific data
dat <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/StreamPEdynamicALLCOLS.csv", as.is=T)
dat$ls <- dat$lscode
# 2014-04-09 Jess and Gale agreed that the East Au Gres (38) should be replaced with the Au Sable (36) in Lake Huron
# 2014-04-10 Jess thinks that we should just stick with the East Au Gres (38)
index.streams <- list(
Sup = c(1, 2, 9, 29, 31, 32, 62),
Mic = c(5, 6, 15, 24, 26, 35),
Hur = c(10, 16, 27, 32, 999, 38),
Eri = c(1, 2, 3, 7, 9),
Ont = c(5, 9, 22, 23, 36)
)
index.streams <- lapply(1:5, function(i) i + index.streams[[i]]/1000)
# estimate adult index of abundance for each lake using index streams
indices <- lapply(index.streams, index.est, dat, lk)
# combine index data for all lakes in one dataframe
indxall <- do.call(rbind, lapply(indices, "[[", "indxdf"))
# calculate targets 
sptargyrz <- list(1994:1998, 1988:1992, 1989:1993, 1991:1995, 1999:2003)
targyrz <- apply(sapply(sptargyrz, range), 2, paste, collapse="-")
# spawner model
targets.sm <- calctarg(lakenum=lk$lake, adults=lk$PE, year=lk$year, targyears=sptargyrz)
# adult index
targets.ai <- calctarg(lakenum=indxall$lake, adults=indxall$indxkeep, year=indxall$year, targyears=sptargyrz)
# spawner model targets scaled down to adult index
targets.sm.su <- cbind(lake=targets.sm[, 1], (1/sapply(indices, "[[", "scaleup")) * targets.sm[, -1])
# adult index adjusted
targets.ai.adj <- targets.ai
targets.ai.adj[is.na(targets.ai$target), ] <- targets.sm.su[is.na(targets.ai$target), ]
YEAR1 <- 1984
# create a Word document with results
doc <- startrtf(file="2014-10 SLCB Index", dir="C:/JVA/Lamprey/Adults/AdultIndex/2014", omi=c(1, 1.25, 1, 1.25))
heading("Index of Adult Sea Lamprey Abundance in each Great Lake")
heading(paste("Adams, Barber, Bravener, Steeves -", as.character(Sys.Date())), htype=2)
### Spawner model time series
heading("Purpose of the index", htype=3)
heading("Selection of index streams", htype=3)
heading("Calculation of index", htype=3)
heading("Assumptions", htype=3)
heading("Fate of current spawner model", htype=3)
para("Conversion factors: ", paste(Lakenames, round(sapply(indices, "[[", "scaleup"), 2), collapse=", "), ".")
# position of text for selected streams in each lake (for map drawing)
posp <- list(c(3, 1, 3, 1, 1, 3, 1),
c(2, 2, 2, 2, 2, 2),
c(4, 4, 4, 4, 4, 4),
c(2, 2, 2, 2, 2),
c(2, 2, 2, 2, 2, 2))
### map of selected streams
mymap <- map5
fig <- function() {
par(mar=c(0, 0, 0, 0))
map(xlim=range(mymap$x, na.rm=T), ylim=range(mymap$y, na.rm=T), col=NA, mar=rep(1, 4))
lines(mymap$x, mymap$y, col="darkgray", lwd=0.5)
for(i in 1:5) {
mystreamdf <- indices[[i]]$streamdf
with(mystreamdf[mystreamdf$year==2010, ], {
points(long, lat, cex=1.5, pch=16)
par(xpd=NA)
text(long, lat, strname, cex=1.2, pos=posp[[i]], font=2)
})
}
}
figu("Streams selected for inclusion in the index of adult sea lamprey abundance.", newpage="land", w=9, h=5.5)
### bar plot of individual index stream PEs
col7 <- c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69")
fig <- function() {
par(mar=c(3, 3, 1, 1), mfrow=c(3, 2), yaxs="i", oma=c(1.5, 1.5, 0, 0), cex=1.2)
for(i in 1:5) {
mymap <- mapL[[i]]
mystreamdf <- indices[[i]]$streamdf
myindxdf <- indices[[i]]$indxdf
mystreamdf <- mystreamdf[mystreamdf$year >= YEAR1, ]
myindxdf <- myindxdf[myindxdf$year >= YEAR1, ]
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p[is.na(myindxdf$indxkeep), ] <- NA
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
a <- barplot(t(p)/1000, las=1, col=col7, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.01*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="", ylab="", main=Lakenames[i], las=1)
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2)
box()
legend("topleft", rev(colnames(p)), fill=rev(col7[1:dim(p)[2]]), cex=0.5, bty="n")
if(i==1) {
frame()
}
}
mtext("Year", outer=TRUE, side=1)
mtext("Adult abundance  (thousands)", outer=TRUE, side=2)
}
figu("Adult sea lamprey abundance estimates for index streams.", newpage="port", w=6, h=7.5)
### spawner model and adult index time series overlaid
fig <- function() {
par(mfrow=c(3, 2), mar=c(3, 3, 1, 3), oma=c(1.5, 1.5, 0, 0), cex=1.2, yaxs="i")
for(i in 1:5) {
mylk <- lk[lk$lake==i, ]# lake year PE lo hi
myindxdf <- indices[[i]]$indxdf# year lake indxraw n.mr indxkeep indxkeep.lo indxkeep.hi
convfac <- indices[[i]]$scaleup
x1 <- myindxdf$year
y1 <- myindxdf$indxkeep/1000
x2 <- mylk$year
y2 <- mylk$PE/convfac/1000
yr <- 1.05*range(0, y1, y2[x2>=YEAR1], na.rm=TRUE)
plot(1, 1, type="n", xlim=range(lk$year), ylim=yr, xlab="", ylab="", main=Lakenames[i], axes=FALSE)
axis(1)
axis(2, col=blindcolz[7], col.axis=blindcolz[7], las=1)
par(mgp=c(3, 2.2, 0))
axis(4, at=pretty(convfac*yr)/convfac, labels=pretty(convfac*yr), col=blindcolz[3], col.axis=blindcolz[3], las=1, hadj=1)
par(mgp=c(3, 1, 0))
box()
abline(h=targets.sm$target[i]/convfac/1000, col=blindcolz[3], lty=2)
abline(h=targets.ai.adj$target[i]/1000, col=blindcolz[7], lty=2)
lines(x2, y2, col=blindcolz[3], type="o", pch=18, lwd=2)
lines(x1, y1, col=blindcolz[7], type="o", pch=17, lwd=2)
if(i==1) {
plot(1, 1, type="n", xlab="", ylab="", axes=FALSE)
legend("center", c("Adult index", "Spawner model"), col=blindcolz[c(7, 3)], lwd=2, pch=c(17, 18))
}
}
mtext("Year", outer=TRUE, side=1)
mtext("Adult abundance  (thousands)", outer=TRUE, side=2)
}
figu("Patterns over time in adult sea lamprey abundance, comparing the newly derived index with the spawner model.",
"  Targets are indicated by dashed horizontal lines.",
"  Targets are based on averages from five years with historically acceptable wounding rates: ", paste(paste(targyrz, "in", Lakenames), collapse=", "), ".", 
newpage="port", w=6, h=7.5)
endrtf()
names(indices[[1]])
# "indfit"   "streamdf" "scaleup"  "indxdf"
# scale up
round(sapply(indices, "[[", 3), 2)
# 3.84 1.85 2.82 1.01 2.40
indxall[7:11, ]
   # year lake   indxraw n.mr  indxkeep indxkeep.lo indxkeep.hi
# 7  1986    1 24275.673    5 24275.673   18726.753   27579.203
# 8  1987    1 10994.483    5 10994.483   10269.609   11494.884
# 9  1988    1 13630.037    5 13630.037   11710.612   14680.398
# 10 1989    1 20227.926    6 20227.926   18704.166   21988.594
# 11 1990    1  9332.001    5  9332.001    8435.646   11991.514
# C:\JVA\Lamprey\Adults\AdultIndex\2014\AdultIndex v2.r
{ # functions
# the following seven plot.table related function are from the Systmatic Investor Toolbox
# load Systematic Investor Toolbox
# require(RCurl)
# sit = getURLContent("https://github.com/systematicinvestor/SIT/raw/master/sit.gz", binary=TRUE, followlocation=TRUE, ssl.verifypeer=FALSE)
# con = gzcon(rawConnection(sit, "rb"))
# source(con)
# close(con)
draw.cell <- function(title, r, c, text.cex = 1, bg.col = 'white', frame.cell = T) {
if(!frame.cell) bcol = bg.col else bcol = 'black'
rect((2*(c - 1) + .5), -(r - .5), (2*c + .5), -(r + .5), col = bg.col, border = bcol)
if( c == 1) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else if( r == 1 ) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else {
text((2*c + .5), -r, title, adj = 1, cex = text.cex)
}
}
plot.table.helper.auto.adjust.cex <- function(temp.table, keep.all.same.cex = FALSE) {
nr = nrow(temp.table)
nc = ncol(temp.table)
all.xrange = diff(par()$usr[1:2]) / nc
xrange = matrix( strwidth(paste('  ', temp.table), units = 'user', cex = 1), nc = nc)
all.yrange = diff(par()$usr[3:4]) / nr
yrange = matrix( 5/3 * strheight(temp.table, units = 'user', cex = 1), nc = nc)
plot.matrix.cex = pmin( round(all.yrange / yrange, 2) , round(all.xrange / xrange, 2) )
header.col.cex = min(plot.matrix.cex[1,-1])
header.row.cex = min(plot.matrix.cex[-1,1])
title.cex = plot.matrix.cex[1, 1]
data.cex = min(plot.matrix.cex[-1, -1])
if ( keep.all.same.cex ) {
plot.matrix.cex[] = min(plot.matrix.cex)
} else {
plot.matrix.cex[1,-1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,-1]= min(c(header.col.cex, header.row.cex, data.cex))
plot.matrix.cex[1,1]= min(c(header.col.cex, header.row.cex, data.cex, title.cex))
plot.matrix.cex[1,-1] = min(c(header.col.cex))
plot.matrix.cex[-1,1] = min(c(header.row.cex))
plot.matrix.cex[-1,-1]= min(c(data.cex))
plot.matrix.cex[1,1]= min(c(title.cex))
}
return(plot.matrix.cex)
}
make.table <- function(nr, nc) {
savepar = par(mar = rep(1, 4))
plot(c(0.5, nc*2 + 0.5), c(-0.5, -(nr + 0.5)), xaxs = 'i', yaxs = 'i',
type = 'n', xlab = '', ylab = '', axes = FALSE)
savepar
}
trim <- function(s) {
s = sub(pattern = '^ +', replacement = '', x = s)
s = sub(pattern = ' +$', replacement = '', x = s)
return(s)
}
plot.table.param <- function(plot.matrix, smain = '', plot.matrix.cex, plot.matrix_bg.col, frame.cell = T, keep.all.same.cex = FALSE) {
n = nrow(plot.matrix)
pages = unique(c(seq(0, n, by = 120), n))
for(p in 1:(length(pages)-1)) {
rindex = (pages[p]+1) : pages[p+1]
temp.table = matrix('', nr = length(rindex)+1, nc = ncol(plot.matrix)+1)
temp.table[-1, -1] = plot.matrix[rindex,]
temp.table[1, -1] = colnames(plot.matrix)
temp.table[-1, 1] = rownames(plot.matrix)[rindex]
temp.table[1, 1] = smain
nr = nrow(temp.table)
nc = ncol(temp.table)
par(mar = c(0, 0, 0, 0), cex = 0.5)
oldpar = make.table(nr, nc)
text.cex = plot.matrix.cex[c(1, 1 + rindex), ]
text.cex = plot.table.helper.auto.adjust.cex(temp.table, keep.all.same.cex)
bg.col = plot.matrix_bg.col[c(1, 1 + rindex), ]
for(r in 1:nr) {
for(c in 1:nc) {
draw.cell( paste('', temp.table[r,c], '', sep=' '), r, c,
text.cex = text.cex[r,c], bg.col = bg.col[r,c], frame.cell = frame.cell)
}}
}
}
plot.table <- function(plot.matrix, smain="", text.cex=1, frame.cell=TRUE, highlight=FALSE, colorbar=FALSE, keep_all.same.cex=FALSE) {
if( is.null(rownames(plot.matrix)) & is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
if( ncol(temp.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[-1, -1, drop = FALSE]
colnames(plot.matrix) = temp.matrix[1, -1]
rownames(plot.matrix) = temp.matrix[-1, 1]
smain = temp.matrix[1, 1]
} else if( is.null(rownames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( ncol(plot.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[, -1, drop = FALSE]
colnames(plot.matrix) = colnames(temp.matrix)[-1]
rownames(plot.matrix) = temp.matrix[,1]
smain = colnames(temp.matrix)[1]
} else if( is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
plot.matrix = temp.matrix[-1, , drop = FALSE]
rownames(plot.matrix) = rownames(temp.matrix)[-1]
colnames(plot.matrix) = temp.matrix[1, ]
smain = rownames(temp.matrix)[1]
}
plot.matrix[which(trim(plot.matrix) == "NA")] = ""
plot.matrix[which(trim(plot.matrix) == "NA%")] = ""
plot.matrix[which(is.na(plot.matrix))] = ""
nr = nrow(plot.matrix) + 1
nc = ncol(plot.matrix) + 1
is_highlight = TRUE
if(is.logical(highlight)) {
is_highlight = highlight
if(highlight) highlight = plot.table.helper.color(plot.matrix)
}
if(!is_highlight) {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[seq(1, nr, 2), ] = "yellow"
plot.matrix_bg.col[1,] = "gray";
plot.table.param( plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
} else {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[1,] = "gray"
plot.matrix_bg.col[2:nr,2:nc] = highlight
plot.table.param(plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
}
}
plot.table.helper.color <- function (temp) {
temp = matrix(as.double(gsub("[%,$]", "", temp)), nrow(temp), ncol(temp))
highlight = as.vector(temp)
cols = rep(NA, length(highlight))
ncols = length(highlight[!is.na(highlight)])
cols[1:ncols] = rev(rainbow(ncols, start=0.5/6, end=3.5/6))
o = sort.list(highlight, na.last = TRUE, decreasing = FALSE)
o1 = sort.list(o, na.last = TRUE, decreasing = FALSE)
highlight = matrix(cols[o1], nrow = nrow(temp))
highlight[is.na(temp)] = NA
return(highlight)
}
ModelEst <- function(fit, df) {
# derive regression estimates from log(y) fit
mse <- rev(as.matrix(summary(fit)[[1]])[, "Mean Sq"])[1]
plpe <- predict(fit, newdata=df, se.fit=T)
m <- plpe$fit
v <- plpe$se.fit^2 + mse
exp(m + v/2)
}
myrange <- function(x) {
if(all(is.na(x))) r <- c(NA, NA) else r <- range(x, na.rm=TRUE)
return(r)
}
jackindex <- function(m) {
# m is a matrix of numbers (stream PEs) with observations (years) as rows and individuals (streams) as columns
if(any(is.na(m))) stop("The input matrix may not have any missing values.")
# calculate the index as the sum of the columns for each row
rowsum <- apply(m, 1, sum)
# calculate the mean of the index
avgind <- mean(rowsum)
# recalculate the index, leaving out one individual at a time
loo <- apply(m, 2, function(column) (rowsum - column))
# rescale the loo index, relative to mean
looscaled <- apply(loo, 2, function(x) x/mean(x))
# convert to original scale
looscaled2 <- looscaled * avgind
# calculate range
ranges <- t(apply(looscaled2, 1, range))
cbind(index=rowsum, lo=ranges[, 1], hi=ranges[, 2])
}
# selstreams <- index.streams[[1]] 
# allstreamdf <- dat
# alllakedf <- lk 
# min.nmr=2 
# show=FALSE
index.est <- function(selstreams, allstreamdf, alllakedf, min.nmr=2, show=FALSE) {
# INDEX OF ADULT SEA LAMPREY ABUNDANCE
### INPUTS
# selstreams = vector of stream ids, e.g., 1.064 (lake + strcode/1000)
# allstreamdf = data frame of mark-recap estimates for all streams, with vars:  year lake ls Emr CVmr
# alllakedf = data frame of lake-wide PEs from Mullett et al. (2003) spawner model with vars:  lake year PE
# min.nmr = minimum number of mark-recapture estimates needed in a year to generate an index, default 2
# show = print out a brief summary of the results, default FALSE
### OUTPUTS
# indfit = simple model used to predict missing mark-recap estimates
# streamdf = original allstreamdf, subsetted by selstreams, with estimates for missing mark-recaps
# indxdf = original alllakedf, subsetted by lake, with annual index, including raw (indxraw), kept based on min.nmr (indxkeep, indxkeep.lo, indxkeep.hi)
# scaleup = conversion factor used to scale up annual index to spawner model PE
streamdf <- allstreamdf[allstreamdf$ls %in% selstreams, ]
# error checks
check1 <- var(streamdf$lake)
if(is.na(check1) | is.null(check1)) stop("Either no streams selected or critical data missing.") else if(check1 > 0) stop("Selected streams should be only from ONE lake.")
if(any(is.na(match(c("year", "lake", "ls", "Emr", "CVmr"), names(allstreamdf))))) stop("allstreamdf must include these variables: year lake ls Emr CVmr.")
if(any(is.na(match(c("year", "lake", "PE"), names(alllakedf))))) stop("alllakedf must include these variables: lake year PE.")
# fill in missing mark-recap data
indfit <- aov(log(Emr) ~ as.factor(ls) + as.factor(year), data=streamdf, weights=1/CVmr^2)
# figure out estimable years (those with at least 1 m-r estimate)
n.mr <- tapply(!is.na(streamdf$Emr), streamdf$year, sum)
eyrs <- as.numeric(names(n.mr)[n.mr > 0.5])
estimable <- streamdf$year %in% eyrs
streamdf$Pmr <- NA
streamdf$Pmr[estimable] <- ModelEst(fit=indfit, df=streamdf[estimable, ])
streamdf$COMBmr <- ifelse(is.na(streamdf$Emr), streamdf$Pmr, streamdf$Emr)
# annual index (sum across streams)
indxdf <- aggregate(COMBmr ~ year + lake, streamdf, sum, na.rm=TRUE, na.action=na.pass)
names(indxdf)[names(indxdf)=="COMBmr"] <- "indxraw"
indxdf$indxraw[indxdf$indxraw==0] <- NA
# only keep lake-wide index for years with at least min.nmr mark-recap estimates
indxdf$n.mr <- n.mr
indxdf$indxkeep <- ifelse(indxdf$n.mr > (min.nmr - 0.5), indxdf$indxraw, NA)
indxdf$indxkeep.lo <- NA
indxdf$indxkeep.hi <- NA
# matrix of stream estimates (rows = years, columns = index streams)
streamests <- with(streamdf, tapply(COMBmr, list(year, ls), mean))
# selection of only those streams with a keepable index
selkeep <- !is.na(indxdf$indxkeep)
jack <- jackindex(streamests[selkeep, ])
indxdf$indxkeep.lo[selkeep] <- jack[, "lo"]
indxdf$indxkeep.hi[selkeep] <- jack[, "hi"]
# scale up the index to the spawner model PE
lk1 <- lk[lk$lake == streamdf$lake[1], ]
indxdf2 <- merge(lk1, indxdf, all=TRUE)
scaleup <- median(indxdf2$PE / indxdf2$indxkeep, na.rm=TRUE)
if(show) {
cat("\nindfit\n")
print(summary(indfit))
cat("\nstreamdf\n")
print(tail(streamdf[, c("lake", "year", "ls", "Emr", "CVmr", "Pmr", "COMBmr")]))
cat("\nscaleup\n")
print(scaleup)
cat("\nindxdf\n")
print(tail(indxdf[, c("lake", "year", "n.mr", "indxraw", "indxkeep", "indxkeep.lo", "indxkeep.hi")]))
}
list(indfit=indfit, streamdf=streamdf, scaleup=scaleup, indxdf=indxdf)
}
calctarg <- function(lakenum, adults, year, targyears, adjust=c(1, 1, 0.25, 1, 1)) {
# lakenum = vector of lake numbers (1-5)
# adults = vector of lakewide adult sea lamprey estimates
# year = vector of years
# targyears = list (length 5) of selected years from which to calculate targets
# lake huron target is 25% of
targets <- data.frame(lake=1:5, target=rep(NA, 5), lo=rep(NA, 5), hi=rep(NA, 5))
for(i in 1:5) {
pick5 <- adults[lakenum==i & is.element(year, targyears[[i]]) & !is.na(adults)]
if(length(pick5) > 0) {
targets$target[i] <- mean(pick5)
n <- length(pick5)
ci <- qnorm(1 - 0.05/2) * sqrt(var(pick5)) / sqrt(n)
targets[i, c("lo", "hi")] <- mean(pick5) + c(-1, 1)*ci# using z dist (known variance)
targets[i, c("target", "lo", "hi")] <- adjust[i]*targets[i, c("target", "lo", "hi")]
} else {
targets[i, c("target", "lo", "hi")] <- c(NA, NA, NA)
}
}
targets
}
}
# bring in lake-wide spawner data
lk <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/LakePEdynamic.csv", as.is=T)
# bring in stream-specific data
dat <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/StreamPEdynamicALLCOLS.csv", as.is=T)
dat$ls <- dat$lscode
# 2014-04-09 Jess and Gale agreed that the East Au Gres (38) should be replaced with the Au Sable (36) in Lake Huron
# 2014-04-10 Jess thinks that we should just stick with the East Au Gres (38)
index.streams <- list(
Sup = c(1, 2, 9, 29, 31, 32, 62),
Mic = c(5, 6, 15, 24, 26, 35),
Hur = c(10, 16, 27, 32, 999, 38),
Eri = c(1, 2, 3, 7, 9),
Ont = c(5, 9, 22, 23, 36)
)
index.streams <- lapply(1:5, function(i) i + index.streams[[i]]/1000)
# estimate adult index of abundance for each lake using index streams
indices <- lapply(index.streams, index.est, dat, lk)
# combine index data for all lakes in one dataframe
indxall <- do.call(rbind, lapply(indices, "[[", "indxdf"))
# calculate targets 
sptargyrz <- list(1994:1998, 1988:1992, 1989:1993, 1991:1995, 1999:2003)
targyrz <- apply(sapply(sptargyrz, range), 2, paste, collapse="-")
# spawner model
targets.sm <- calctarg(lakenum=lk$lake, adults=lk$PE, year=lk$year, targyears=sptargyrz)
# adult index
targets.ai <- calctarg(lakenum=indxall$lake, adults=indxall$indxkeep, year=indxall$year, targyears=sptargyrz)
# spawner model targets scaled down to adult index
targets.sm.su <- cbind(lake=targets.sm[, 1], (1/sapply(indices, "[[", "scaleup")) * targets.sm[, -1])
# adult index adjusted
targets.ai.adj <- targets.ai
targets.ai.adj[is.na(targets.ai$target), ] <- targets.sm.su[is.na(targets.ai$target), ]
YEAR1 <- 1984
# create a Word document with results
doc <- startrtf(file="2014-10 SLCB Index", dir="C:/JVA/Lamprey/Adults/AdultIndex/2014", omi=c(1, 1.25, 1, 1.25))
heading("Index of Adult Sea Lamprey Abundance in each Great Lake")
heading(paste("Adams, Barber, Bravener, Steeves -", as.character(Sys.Date())), htype=2)
### Spawner model time series
heading("Purpose of the index", htype=3)
heading("Selection of index streams", htype=3)
heading("Calculation of index", htype=3)
heading("Assumptions", htype=3)
heading("Fate of current spawner model", htype=3)
para("Conversion factors: ", paste(Lakenames, round(sapply(indices, "[[", "scaleup"), 2), collapse=", "), ".")
# position of text for selected streams in each lake (for map drawing)
posp <- list(c(3, 1, 3, 1, 1, 3, 1),
c(2, 2, 2, 2, 2, 2),
c(4, 4, 4, 4, 4, 4),
c(2, 2, 2, 2, 2),
c(2, 2, 2, 2, 2, 2))
### map of selected streams
mymap <- map5
fig <- function() {
par(mar=c(0, 0, 0, 0))
map(xlim=range(mymap$x, na.rm=T), ylim=range(mymap$y, na.rm=T), col=NA, mar=rep(1, 4))
lines(mymap$x, mymap$y, col="darkgray", lwd=0.5)
for(i in 1:5) {
mystreamdf <- indices[[i]]$streamdf
with(mystreamdf[mystreamdf$year==2010, ], {
points(long, lat, cex=1.5, pch=16)
par(xpd=NA)
text(long, lat, strname, cex=1.2, pos=posp[[i]], font=2)
})
}
}
figu("Streams selected for inclusion in the index of adult sea lamprey abundance.", newpage="land", w=9, h=5.5)
outcex <- 1.2
### bar plot of individual index stream PEs
col7 <- c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69")
fig <- function() {
par(mar=c(2.5, 2.5, 1, 1), mfrow=c(3, 2), yaxs="i", oma=c(1.5, 1.5, 0, 0), cex=1.2)
for(i in 1:5) {
mymap <- mapL[[i]]
mystreamdf <- indices[[i]]$streamdf
myindxdf <- indices[[i]]$indxdf
mystreamdf <- mystreamdf[mystreamdf$year >= YEAR1, ]
myindxdf <- myindxdf[myindxdf$year >= YEAR1, ]
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p[is.na(myindxdf$indxkeep), ] <- NA
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
a <- barplot(t(p)/1000, las=1, col=col7, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.01*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="", ylab="", main=Lakenames[i])
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2, las=1)
box()
legend("topleft", rev(colnames(p)), fill=rev(col7[1:dim(p)[2]]), cex=0.5, bty="n")
if(i==1) {
frame()
}
}
mtext("Year", outer=TRUE, side=1, cex=outcex)
mtext("Adult abundance  (thousands)", outer=TRUE, side=2, cex=outcex)
}
figu("Adult sea lamprey abundance estimates for index streams.", newpage="port", w=6, h=7.5)
### spawner model and adult index time series overlaid
fig <- function() {
par(mfrow=c(3, 2), mar=c(3, 3, 1, 3), oma=c(1.5, 1.5, 0, 0), cex=1.2, yaxs="i")
for(i in 1:5) {
mylk <- lk[lk$lake==i, ]# lake year PE lo hi
myindxdf <- indices[[i]]$indxdf# year lake indxraw n.mr indxkeep indxkeep.lo indxkeep.hi
convfac <- indices[[i]]$scaleup
x1 <- myindxdf$year
y1 <- myindxdf$indxkeep/1000
x2 <- mylk$year
y2 <- mylk$PE/convfac/1000
yr <- 1.05*range(0, y1, y2[x2>=YEAR1], na.rm=TRUE)
plot(1, 1, type="n", xlim=range(lk$year), ylim=yr, xlab="", ylab="", main=Lakenames[i], axes=FALSE)
axis(1)
axis(2, col=blindcolz[7], col.axis=blindcolz[7], las=1)
par(mgp=c(3, 2.2, 0))
axis(4, at=pretty(convfac*yr)/convfac, labels=pretty(convfac*yr), col=blindcolz[3], col.axis=blindcolz[3], las=1, hadj=1)
par(mgp=c(3, 1, 0))
box()
abline(h=targets.sm$target[i]/convfac/1000, col=blindcolz[3], lty=2)
abline(h=targets.ai.adj$target[i]/1000, col=blindcolz[7], lty=2)
lines(x2, y2, col=blindcolz[3], type="o", pch=18, lwd=2)
lines(x1, y1, col=blindcolz[7], type="o", pch=17, lwd=2)
if(i==1) {
plot(1, 1, type="n", xlab="", ylab="", axes=FALSE)
legend("center", c("Adult index", "Spawner model"), col=blindcolz[c(7, 3)], lwd=2, pch=c(17, 18))
}
}
mtext("Year", outer=TRUE, side=1, cex=outcex)
mtext("Adult abundance  (thousands)", outer=TRUE, side=2, cex=outcex)
}
figu("Patterns over time in adult sea lamprey abundance, comparing the newly derived index with the spawner model.",
"  Targets are indicated by dashed horizontal lines.",
"  Targets are based on averages from five years with historically acceptable wounding rates: ", paste(paste(targyrz, "in", Lakenames), collapse=", "), ".", 
newpage="port", w=6, h=7.5)
endrtf()
names(indices[[1]])
# "indfit"   "streamdf" "scaleup"  "indxdf"
# scale up
round(sapply(indices, "[[", 3), 2)
# 3.84 1.85 2.82 1.01 2.40
indxall[7:11, ]
   # year lake   indxraw n.mr  indxkeep indxkeep.lo indxkeep.hi
# 7  1986    1 24275.673    5 24275.673   18726.753   27579.203
# 8  1987    1 10994.483    5 10994.483   10269.609   11494.884
# 9  1988    1 13630.037    5 13630.037   11710.612   14680.398
# 10 1989    1 20227.926    6 20227.926   18704.166   21988.594
# 11 1990    1  9332.001    5  9332.001    8435.646   11991.514
?barplot
# C:\JVA\Lamprey\Adults\AdultIndex\2014\AdultIndex v2.r
{ # functions
# the following seven plot.table related function are from the Systmatic Investor Toolbox
# load Systematic Investor Toolbox
# require(RCurl)
# sit = getURLContent("https://github.com/systematicinvestor/SIT/raw/master/sit.gz", binary=TRUE, followlocation=TRUE, ssl.verifypeer=FALSE)
# con = gzcon(rawConnection(sit, "rb"))
# source(con)
# close(con)
draw.cell <- function(title, r, c, text.cex = 1, bg.col = 'white', frame.cell = T) {
if(!frame.cell) bcol = bg.col else bcol = 'black'
rect((2*(c - 1) + .5), -(r - .5), (2*c + .5), -(r + .5), col = bg.col, border = bcol)
if( c == 1) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else if( r == 1 ) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else {
text((2*c + .5), -r, title, adj = 1, cex = text.cex)
}
}
plot.table.helper.auto.adjust.cex <- function(temp.table, keep.all.same.cex = FALSE) {
nr = nrow(temp.table)
nc = ncol(temp.table)
all.xrange = diff(par()$usr[1:2]) / nc
xrange = matrix( strwidth(paste('  ', temp.table), units = 'user', cex = 1), nc = nc)
all.yrange = diff(par()$usr[3:4]) / nr
yrange = matrix( 5/3 * strheight(temp.table, units = 'user', cex = 1), nc = nc)
plot.matrix.cex = pmin( round(all.yrange / yrange, 2) , round(all.xrange / xrange, 2) )
header.col.cex = min(plot.matrix.cex[1,-1])
header.row.cex = min(plot.matrix.cex[-1,1])
title.cex = plot.matrix.cex[1, 1]
data.cex = min(plot.matrix.cex[-1, -1])
if ( keep.all.same.cex ) {
plot.matrix.cex[] = min(plot.matrix.cex)
} else {
plot.matrix.cex[1,-1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,-1]= min(c(header.col.cex, header.row.cex, data.cex))
plot.matrix.cex[1,1]= min(c(header.col.cex, header.row.cex, data.cex, title.cex))
plot.matrix.cex[1,-1] = min(c(header.col.cex))
plot.matrix.cex[-1,1] = min(c(header.row.cex))
plot.matrix.cex[-1,-1]= min(c(data.cex))
plot.matrix.cex[1,1]= min(c(title.cex))
}
return(plot.matrix.cex)
}
make.table <- function(nr, nc) {
savepar = par(mar = rep(1, 4))
plot(c(0.5, nc*2 + 0.5), c(-0.5, -(nr + 0.5)), xaxs = 'i', yaxs = 'i',
type = 'n', xlab = '', ylab = '', axes = FALSE)
savepar
}
trim <- function(s) {
s = sub(pattern = '^ +', replacement = '', x = s)
s = sub(pattern = ' +$', replacement = '', x = s)
return(s)
}
plot.table.param <- function(plot.matrix, smain = '', plot.matrix.cex, plot.matrix_bg.col, frame.cell = T, keep.all.same.cex = FALSE) {
n = nrow(plot.matrix)
pages = unique(c(seq(0, n, by = 120), n))
for(p in 1:(length(pages)-1)) {
rindex = (pages[p]+1) : pages[p+1]
temp.table = matrix('', nr = length(rindex)+1, nc = ncol(plot.matrix)+1)
temp.table[-1, -1] = plot.matrix[rindex,]
temp.table[1, -1] = colnames(plot.matrix)
temp.table[-1, 1] = rownames(plot.matrix)[rindex]
temp.table[1, 1] = smain
nr = nrow(temp.table)
nc = ncol(temp.table)
par(mar = c(0, 0, 0, 0), cex = 0.5)
oldpar = make.table(nr, nc)
text.cex = plot.matrix.cex[c(1, 1 + rindex), ]
text.cex = plot.table.helper.auto.adjust.cex(temp.table, keep.all.same.cex)
bg.col = plot.matrix_bg.col[c(1, 1 + rindex), ]
for(r in 1:nr) {
for(c in 1:nc) {
draw.cell( paste('', temp.table[r,c], '', sep=' '), r, c,
text.cex = text.cex[r,c], bg.col = bg.col[r,c], frame.cell = frame.cell)
}}
}
}
plot.table <- function(plot.matrix, smain="", text.cex=1, frame.cell=TRUE, highlight=FALSE, colorbar=FALSE, keep_all.same.cex=FALSE) {
if( is.null(rownames(plot.matrix)) & is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
if( ncol(temp.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[-1, -1, drop = FALSE]
colnames(plot.matrix) = temp.matrix[1, -1]
rownames(plot.matrix) = temp.matrix[-1, 1]
smain = temp.matrix[1, 1]
} else if( is.null(rownames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( ncol(plot.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[, -1, drop = FALSE]
colnames(plot.matrix) = colnames(temp.matrix)[-1]
rownames(plot.matrix) = temp.matrix[,1]
smain = colnames(temp.matrix)[1]
} else if( is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
plot.matrix = temp.matrix[-1, , drop = FALSE]
rownames(plot.matrix) = rownames(temp.matrix)[-1]
colnames(plot.matrix) = temp.matrix[1, ]
smain = rownames(temp.matrix)[1]
}
plot.matrix[which(trim(plot.matrix) == "NA")] = ""
plot.matrix[which(trim(plot.matrix) == "NA%")] = ""
plot.matrix[which(is.na(plot.matrix))] = ""
nr = nrow(plot.matrix) + 1
nc = ncol(plot.matrix) + 1
is_highlight = TRUE
if(is.logical(highlight)) {
is_highlight = highlight
if(highlight) highlight = plot.table.helper.color(plot.matrix)
}
if(!is_highlight) {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[seq(1, nr, 2), ] = "yellow"
plot.matrix_bg.col[1,] = "gray";
plot.table.param( plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
} else {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[1,] = "gray"
plot.matrix_bg.col[2:nr,2:nc] = highlight
plot.table.param(plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
}
}
plot.table.helper.color <- function (temp) {
temp = matrix(as.double(gsub("[%,$]", "", temp)), nrow(temp), ncol(temp))
highlight = as.vector(temp)
cols = rep(NA, length(highlight))
ncols = length(highlight[!is.na(highlight)])
cols[1:ncols] = rev(rainbow(ncols, start=0.5/6, end=3.5/6))
o = sort.list(highlight, na.last = TRUE, decreasing = FALSE)
o1 = sort.list(o, na.last = TRUE, decreasing = FALSE)
highlight = matrix(cols[o1], nrow = nrow(temp))
highlight[is.na(temp)] = NA
return(highlight)
}
ModelEst <- function(fit, df) {
# derive regression estimates from log(y) fit
mse <- rev(as.matrix(summary(fit)[[1]])[, "Mean Sq"])[1]
plpe <- predict(fit, newdata=df, se.fit=T)
m <- plpe$fit
v <- plpe$se.fit^2 + mse
exp(m + v/2)
}
myrange <- function(x) {
if(all(is.na(x))) r <- c(NA, NA) else r <- range(x, na.rm=TRUE)
return(r)
}
jackindex <- function(m) {
# m is a matrix of numbers (stream PEs) with observations (years) as rows and individuals (streams) as columns
if(any(is.na(m))) stop("The input matrix may not have any missing values.")
# calculate the index as the sum of the columns for each row
rowsum <- apply(m, 1, sum)
# calculate the mean of the index
avgind <- mean(rowsum)
# recalculate the index, leaving out one individual at a time
loo <- apply(m, 2, function(column) (rowsum - column))
# rescale the loo index, relative to mean
looscaled <- apply(loo, 2, function(x) x/mean(x))
# convert to original scale
looscaled2 <- looscaled * avgind
# calculate range
ranges <- t(apply(looscaled2, 1, range))
cbind(index=rowsum, lo=ranges[, 1], hi=ranges[, 2])
}
# selstreams <- index.streams[[1]] 
# allstreamdf <- dat
# alllakedf <- lk 
# min.nmr=2 
# show=FALSE
index.est <- function(selstreams, allstreamdf, alllakedf, min.nmr=2, show=FALSE) {
# INDEX OF ADULT SEA LAMPREY ABUNDANCE
### INPUTS
# selstreams = vector of stream ids, e.g., 1.064 (lake + strcode/1000)
# allstreamdf = data frame of mark-recap estimates for all streams, with vars:  year lake ls Emr CVmr
# alllakedf = data frame of lake-wide PEs from Mullett et al. (2003) spawner model with vars:  lake year PE
# min.nmr = minimum number of mark-recapture estimates needed in a year to generate an index, default 2
# show = print out a brief summary of the results, default FALSE
### OUTPUTS
# indfit = simple model used to predict missing mark-recap estimates
# streamdf = original allstreamdf, subsetted by selstreams, with estimates for missing mark-recaps
# indxdf = original alllakedf, subsetted by lake, with annual index, including raw (indxraw), kept based on min.nmr (indxkeep, indxkeep.lo, indxkeep.hi)
# scaleup = conversion factor used to scale up annual index to spawner model PE
streamdf <- allstreamdf[allstreamdf$ls %in% selstreams, ]
# error checks
check1 <- var(streamdf$lake)
if(is.na(check1) | is.null(check1)) stop("Either no streams selected or critical data missing.") else if(check1 > 0) stop("Selected streams should be only from ONE lake.")
if(any(is.na(match(c("year", "lake", "ls", "Emr", "CVmr"), names(allstreamdf))))) stop("allstreamdf must include these variables: year lake ls Emr CVmr.")
if(any(is.na(match(c("year", "lake", "PE"), names(alllakedf))))) stop("alllakedf must include these variables: lake year PE.")
# fill in missing mark-recap data
indfit <- aov(log(Emr) ~ as.factor(ls) + as.factor(year), data=streamdf, weights=1/CVmr^2)
# figure out estimable years (those with at least 1 m-r estimate)
n.mr <- tapply(!is.na(streamdf$Emr), streamdf$year, sum)
eyrs <- as.numeric(names(n.mr)[n.mr > 0.5])
estimable <- streamdf$year %in% eyrs
streamdf$Pmr <- NA
streamdf$Pmr[estimable] <- ModelEst(fit=indfit, df=streamdf[estimable, ])
streamdf$COMBmr <- ifelse(is.na(streamdf$Emr), streamdf$Pmr, streamdf$Emr)
# annual index (sum across streams)
indxdf <- aggregate(COMBmr ~ year + lake, streamdf, sum, na.rm=TRUE, na.action=na.pass)
names(indxdf)[names(indxdf)=="COMBmr"] <- "indxraw"
indxdf$indxraw[indxdf$indxraw==0] <- NA
# only keep lake-wide index for years with at least min.nmr mark-recap estimates
indxdf$n.mr <- n.mr
indxdf$indxkeep <- ifelse(indxdf$n.mr > (min.nmr - 0.5), indxdf$indxraw, NA)
indxdf$indxkeep.lo <- NA
indxdf$indxkeep.hi <- NA
# matrix of stream estimates (rows = years, columns = index streams)
streamests <- with(streamdf, tapply(COMBmr, list(year, ls), mean))
# selection of only those streams with a keepable index
selkeep <- !is.na(indxdf$indxkeep)
jack <- jackindex(streamests[selkeep, ])
indxdf$indxkeep.lo[selkeep] <- jack[, "lo"]
indxdf$indxkeep.hi[selkeep] <- jack[, "hi"]
# scale up the index to the spawner model PE
lk1 <- lk[lk$lake == streamdf$lake[1], ]
indxdf2 <- merge(lk1, indxdf, all=TRUE)
scaleup <- median(indxdf2$PE / indxdf2$indxkeep, na.rm=TRUE)
if(show) {
cat("\nindfit\n")
print(summary(indfit))
cat("\nstreamdf\n")
print(tail(streamdf[, c("lake", "year", "ls", "Emr", "CVmr", "Pmr", "COMBmr")]))
cat("\nscaleup\n")
print(scaleup)
cat("\nindxdf\n")
print(tail(indxdf[, c("lake", "year", "n.mr", "indxraw", "indxkeep", "indxkeep.lo", "indxkeep.hi")]))
}
list(indfit=indfit, streamdf=streamdf, scaleup=scaleup, indxdf=indxdf)
}
calctarg <- function(lakenum, adults, year, targyears, adjust=c(1, 1, 0.25, 1, 1)) {
# lakenum = vector of lake numbers (1-5)
# adults = vector of lakewide adult sea lamprey estimates
# year = vector of years
# targyears = list (length 5) of selected years from which to calculate targets
# lake huron target is 25% of
targets <- data.frame(lake=1:5, target=rep(NA, 5), lo=rep(NA, 5), hi=rep(NA, 5))
for(i in 1:5) {
pick5 <- adults[lakenum==i & is.element(year, targyears[[i]]) & !is.na(adults)]
if(length(pick5) > 0) {
targets$target[i] <- mean(pick5)
n <- length(pick5)
ci <- qnorm(1 - 0.05/2) * sqrt(var(pick5)) / sqrt(n)
targets[i, c("lo", "hi")] <- mean(pick5) + c(-1, 1)*ci# using z dist (known variance)
targets[i, c("target", "lo", "hi")] <- adjust[i]*targets[i, c("target", "lo", "hi")]
} else {
targets[i, c("target", "lo", "hi")] <- c(NA, NA, NA)
}
}
targets
}
}
# bring in lake-wide spawner data
lk <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/LakePEdynamic.csv", as.is=T)
# bring in stream-specific data
dat <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/StreamPEdynamicALLCOLS.csv", as.is=T)
dat$ls <- dat$lscode
# 2014-04-09 Jess and Gale agreed that the East Au Gres (38) should be replaced with the Au Sable (36) in Lake Huron
# 2014-04-10 Jess thinks that we should just stick with the East Au Gres (38)
index.streams <- list(
Sup = c(1, 2, 9, 29, 31, 32, 62),
Mic = c(5, 6, 15, 24, 26, 35),
Hur = c(10, 16, 27, 32, 999, 38),
Eri = c(1, 2, 3, 7, 9),
Ont = c(5, 9, 22, 23, 36)
)
index.streams <- lapply(1:5, function(i) i + index.streams[[i]]/1000)
# estimate adult index of abundance for each lake using index streams
indices <- lapply(index.streams, index.est, dat, lk)
# combine index data for all lakes in one dataframe
indxall <- do.call(rbind, lapply(indices, "[[", "indxdf"))
# calculate targets 
sptargyrz <- list(1994:1998, 1988:1992, 1989:1993, 1991:1995, 1999:2003)
targyrz <- apply(sapply(sptargyrz, range), 2, paste, collapse="-")
# spawner model
targets.sm <- calctarg(lakenum=lk$lake, adults=lk$PE, year=lk$year, targyears=sptargyrz)
# adult index
targets.ai <- calctarg(lakenum=indxall$lake, adults=indxall$indxkeep, year=indxall$year, targyears=sptargyrz)
# spawner model targets scaled down to adult index
targets.sm.su <- cbind(lake=targets.sm[, 1], (1/sapply(indices, "[[", "scaleup")) * targets.sm[, -1])
# adult index adjusted
targets.ai.adj <- targets.ai
targets.ai.adj[is.na(targets.ai$target), ] <- targets.sm.su[is.na(targets.ai$target), ]
YEAR1 <- 1984
# create a Word document with results
doc <- startrtf(file="2014-10 SLCB Index", dir="C:/JVA/Lamprey/Adults/AdultIndex/2014", omi=c(1, 1.25, 1, 1.25))
heading("Index of Adult Sea Lamprey Abundance in each Great Lake")
heading(paste("Adams, Barber, Bravener, Steeves -", as.character(Sys.Date())), htype=2)
### Spawner model time series
heading("Purpose of the index", htype=3)
heading("Selection of index streams", htype=3)
heading("Calculation of index", htype=3)
heading("Assumptions", htype=3)
heading("Fate of current spawner model", htype=3)
para("Conversion factors: ", paste(Lakenames, round(sapply(indices, "[[", "scaleup"), 2), collapse=", "), ".")
# position of text for selected streams in each lake (for map drawing)
posp <- list(c(3, 1, 3, 1, 1, 3, 1),
c(2, 2, 2, 2, 2, 2),
c(4, 4, 4, 4, 4, 4),
c(2, 2, 2, 2, 2),
c(2, 2, 2, 2, 2, 2))
### map of selected streams
col5 <- c("#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00")
mymap <- map5
fig <- function() {
par(mar=c(0, 0, 0, 0))
map(xlim=range(mymap$x, na.rm=T), ylim=range(mymap$y, na.rm=T), col=NA, mar=rep(1, 4))
lines(mymap$x, mymap$y, col="darkgray", lwd=0.5)
for(i in 1:5) {
mystreamdf <- indices[[i]]$streamdf
with(mystreamdf[mystreamdf$year==2010, ], {
points(long, lat, cex=1.5, pch=16, col=col5[i])
par(xpd=NA)
text(long, lat, strname, cex=1.2, pos=posp[[i]], col=col5[i])
})
}
}
figu("Streams selected for inclusion in the index of adult sea lamprey abundance.", newpage="land", w=9, h=5.5)
outcex <- 1.2
### bar plot of individual index stream PEs
col7 <- c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69")
fig <- function() {
par(mar=c(2.5, 2.5, 1, 1), mfrow=c(3, 2), yaxs="i", oma=c(1.5, 1.5, 0, 0), cex=1.2)
for(i in 1:5) {
mymap <- mapL[[i]]
mystreamdf <- indices[[i]]$streamdf
myindxdf <- indices[[i]]$indxdf
mystreamdf <- mystreamdf[mystreamdf$year >= YEAR1, ]
myindxdf <- myindxdf[myindxdf$year >= YEAR1, ]
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p[is.na(myindxdf$indxkeep), ] <- NA
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
a <- barplot(t(p)/1000, las=1, col=col7, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.01*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="", ylab="", main=Lakenames[i], border=NA)
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2, las=1)
box()
legend("topleft", rev(colnames(p)), fill=rev(col7[1:dim(p)[2]]), cex=0.5, bty="n")
if(i==1) {
frame()
}
}
mtext("Year", outer=TRUE, side=1, cex=outcex)
mtext("Adult abundance  (thousands)", outer=TRUE, side=2, cex=outcex)
}
figu("Adult sea lamprey abundance estimates for index streams.", newpage="port", w=6, h=7.5)
### spawner model and adult index time series overlaid
fig <- function() {
par(mfrow=c(3, 2), mar=c(3, 3, 1, 3), oma=c(1.5, 1.5, 0, 0), cex=1.2, yaxs="i")
for(i in 1:5) {
mylk <- lk[lk$lake==i, ]# lake year PE lo hi
myindxdf <- indices[[i]]$indxdf# year lake indxraw n.mr indxkeep indxkeep.lo indxkeep.hi
convfac <- indices[[i]]$scaleup
x1 <- myindxdf$year
y1 <- myindxdf$indxkeep/1000
x2 <- mylk$year
y2 <- mylk$PE/convfac/1000
yr <- 1.05*range(0, y1, y2[x2>=YEAR1], na.rm=TRUE)
plot(1, 1, type="n", xlim=range(lk$year), ylim=yr, xlab="", ylab="", main=Lakenames[i], axes=FALSE)
axis(1)
axis(2, col=blindcolz[7], col.axis=blindcolz[7], las=1)
par(mgp=c(3, 2.2, 0))
axis(4, at=pretty(convfac*yr)/convfac, labels=pretty(convfac*yr), col=blindcolz[3], col.axis=blindcolz[3], las=1, hadj=1)
par(mgp=c(3, 1, 0))
box()
abline(h=targets.sm$target[i]/convfac/1000, col=blindcolz[3], lty=2)
abline(h=targets.ai.adj$target[i]/1000, col=blindcolz[7], lty=2)
lines(x2, y2, col=blindcolz[3], type="o", pch=18, lwd=2)
lines(x1, y1, col=blindcolz[7], type="o", pch=17, lwd=2)
if(i==1) {
plot(1, 1, type="n", xlab="", ylab="", axes=FALSE)
legend("center", c("Adult index", "Spawner model"), col=blindcolz[c(7, 3)], lwd=2, pch=c(17, 18))
}
}
mtext("Year", outer=TRUE, side=1, cex=outcex)
mtext("Adult abundance  (thousands)", outer=TRUE, side=2, cex=outcex)
}
figu("Patterns over time in adult sea lamprey abundance, comparing the newly derived index with the spawner model.",
"  Targets are indicated by dashed horizontal lines.",
"  Targets are based on averages from five years with historically acceptable wounding rates: ", paste(paste(targyrz, "in", Lakenames), collapse=", "), ".", 
newpage="port", w=6, h=7.5)
endrtf()
names(indices[[1]])
# "indfit"   "streamdf" "scaleup"  "indxdf"
# scale up
round(sapply(indices, "[[", 3), 2)
# 3.84 1.85 2.82 1.01 2.40
indxall[7:11, ]
   # year lake   indxraw n.mr  indxkeep indxkeep.lo indxkeep.hi
# 7  1986    1 24275.673    5 24275.673   18726.753   27579.203
# 8  1987    1 10994.483    5 10994.483   10269.609   11494.884
# 9  1988    1 13630.037    5 13630.037   11710.612   14680.398
# 10 1989    1 20227.926    6 20227.926   18704.166   21988.594
# 11 1990    1  9332.001    5  9332.001    8435.646   11991.514
# C:\JVA\Lamprey\Adults\AdultIndex\2014\AdultIndex v2.r
{ # functions
# the following seven plot.table related function are from the Systmatic Investor Toolbox
# load Systematic Investor Toolbox
# require(RCurl)
# sit = getURLContent("https://github.com/systematicinvestor/SIT/raw/master/sit.gz", binary=TRUE, followlocation=TRUE, ssl.verifypeer=FALSE)
# con = gzcon(rawConnection(sit, "rb"))
# source(con)
# close(con)
draw.cell <- function(title, r, c, text.cex = 1, bg.col = 'white', frame.cell = T) {
if(!frame.cell) bcol = bg.col else bcol = 'black'
rect((2*(c - 1) + .5), -(r - .5), (2*c + .5), -(r + .5), col = bg.col, border = bcol)
if( c == 1) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else if( r == 1 ) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else {
text((2*c + .5), -r, title, adj = 1, cex = text.cex)
}
}
plot.table.helper.auto.adjust.cex <- function(temp.table, keep.all.same.cex = FALSE) {
nr = nrow(temp.table)
nc = ncol(temp.table)
all.xrange = diff(par()$usr[1:2]) / nc
xrange = matrix( strwidth(paste('  ', temp.table), units = 'user', cex = 1), nc = nc)
all.yrange = diff(par()$usr[3:4]) / nr
yrange = matrix( 5/3 * strheight(temp.table, units = 'user', cex = 1), nc = nc)
plot.matrix.cex = pmin( round(all.yrange / yrange, 2) , round(all.xrange / xrange, 2) )
header.col.cex = min(plot.matrix.cex[1,-1])
header.row.cex = min(plot.matrix.cex[-1,1])
title.cex = plot.matrix.cex[1, 1]
data.cex = min(plot.matrix.cex[-1, -1])
if ( keep.all.same.cex ) {
plot.matrix.cex[] = min(plot.matrix.cex)
} else {
plot.matrix.cex[1,-1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,-1]= min(c(header.col.cex, header.row.cex, data.cex))
plot.matrix.cex[1,1]= min(c(header.col.cex, header.row.cex, data.cex, title.cex))
plot.matrix.cex[1,-1] = min(c(header.col.cex))
plot.matrix.cex[-1,1] = min(c(header.row.cex))
plot.matrix.cex[-1,-1]= min(c(data.cex))
plot.matrix.cex[1,1]= min(c(title.cex))
}
return(plot.matrix.cex)
}
make.table <- function(nr, nc) {
savepar = par(mar = rep(1, 4))
plot(c(0.5, nc*2 + 0.5), c(-0.5, -(nr + 0.5)), xaxs = 'i', yaxs = 'i',
type = 'n', xlab = '', ylab = '', axes = FALSE)
savepar
}
trim <- function(s) {
s = sub(pattern = '^ +', replacement = '', x = s)
s = sub(pattern = ' +$', replacement = '', x = s)
return(s)
}
plot.table.param <- function(plot.matrix, smain = '', plot.matrix.cex, plot.matrix_bg.col, frame.cell = T, keep.all.same.cex = FALSE) {
n = nrow(plot.matrix)
pages = unique(c(seq(0, n, by = 120), n))
for(p in 1:(length(pages)-1)) {
rindex = (pages[p]+1) : pages[p+1]
temp.table = matrix('', nr = length(rindex)+1, nc = ncol(plot.matrix)+1)
temp.table[-1, -1] = plot.matrix[rindex,]
temp.table[1, -1] = colnames(plot.matrix)
temp.table[-1, 1] = rownames(plot.matrix)[rindex]
temp.table[1, 1] = smain
nr = nrow(temp.table)
nc = ncol(temp.table)
par(mar = c(0, 0, 0, 0), cex = 0.5)
oldpar = make.table(nr, nc)
text.cex = plot.matrix.cex[c(1, 1 + rindex), ]
text.cex = plot.table.helper.auto.adjust.cex(temp.table, keep.all.same.cex)
bg.col = plot.matrix_bg.col[c(1, 1 + rindex), ]
for(r in 1:nr) {
for(c in 1:nc) {
draw.cell( paste('', temp.table[r,c], '', sep=' '), r, c,
text.cex = text.cex[r,c], bg.col = bg.col[r,c], frame.cell = frame.cell)
}}
}
}
plot.table <- function(plot.matrix, smain="", text.cex=1, frame.cell=TRUE, highlight=FALSE, colorbar=FALSE, keep_all.same.cex=FALSE) {
if( is.null(rownames(plot.matrix)) & is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
if( ncol(temp.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[-1, -1, drop = FALSE]
colnames(plot.matrix) = temp.matrix[1, -1]
rownames(plot.matrix) = temp.matrix[-1, 1]
smain = temp.matrix[1, 1]
} else if( is.null(rownames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( ncol(plot.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[, -1, drop = FALSE]
colnames(plot.matrix) = colnames(temp.matrix)[-1]
rownames(plot.matrix) = temp.matrix[,1]
smain = colnames(temp.matrix)[1]
} else if( is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
plot.matrix = temp.matrix[-1, , drop = FALSE]
rownames(plot.matrix) = rownames(temp.matrix)[-1]
colnames(plot.matrix) = temp.matrix[1, ]
smain = rownames(temp.matrix)[1]
}
plot.matrix[which(trim(plot.matrix) == "NA")] = ""
plot.matrix[which(trim(plot.matrix) == "NA%")] = ""
plot.matrix[which(is.na(plot.matrix))] = ""
nr = nrow(plot.matrix) + 1
nc = ncol(plot.matrix) + 1
is_highlight = TRUE
if(is.logical(highlight)) {
is_highlight = highlight
if(highlight) highlight = plot.table.helper.color(plot.matrix)
}
if(!is_highlight) {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[seq(1, nr, 2), ] = "yellow"
plot.matrix_bg.col[1,] = "gray";
plot.table.param( plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
} else {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[1,] = "gray"
plot.matrix_bg.col[2:nr,2:nc] = highlight
plot.table.param(plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
}
}
plot.table.helper.color <- function (temp) {
temp = matrix(as.double(gsub("[%,$]", "", temp)), nrow(temp), ncol(temp))
highlight = as.vector(temp)
cols = rep(NA, length(highlight))
ncols = length(highlight[!is.na(highlight)])
cols[1:ncols] = rev(rainbow(ncols, start=0.5/6, end=3.5/6))
o = sort.list(highlight, na.last = TRUE, decreasing = FALSE)
o1 = sort.list(o, na.last = TRUE, decreasing = FALSE)
highlight = matrix(cols[o1], nrow = nrow(temp))
highlight[is.na(temp)] = NA
return(highlight)
}
ModelEst <- function(fit, df) {
# derive regression estimates from log(y) fit
mse <- rev(as.matrix(summary(fit)[[1]])[, "Mean Sq"])[1]
plpe <- predict(fit, newdata=df, se.fit=T)
m <- plpe$fit
v <- plpe$se.fit^2 + mse
exp(m + v/2)
}
myrange <- function(x) {
if(all(is.na(x))) r <- c(NA, NA) else r <- range(x, na.rm=TRUE)
return(r)
}
jackindex <- function(m) {
# m is a matrix of numbers (stream PEs) with observations (years) as rows and individuals (streams) as columns
if(any(is.na(m))) stop("The input matrix may not have any missing values.")
# calculate the index as the sum of the columns for each row
rowsum <- apply(m, 1, sum)
# calculate the mean of the index
avgind <- mean(rowsum)
# recalculate the index, leaving out one individual at a time
loo <- apply(m, 2, function(column) (rowsum - column))
# rescale the loo index, relative to mean
looscaled <- apply(loo, 2, function(x) x/mean(x))
# convert to original scale
looscaled2 <- looscaled * avgind
# calculate range
ranges <- t(apply(looscaled2, 1, range))
cbind(index=rowsum, lo=ranges[, 1], hi=ranges[, 2])
}
# selstreams <- index.streams[[1]] 
# allstreamdf <- dat
# alllakedf <- lk 
# min.nmr=2 
# show=FALSE
index.est <- function(selstreams, allstreamdf, alllakedf, min.nmr=2, show=FALSE) {
# INDEX OF ADULT SEA LAMPREY ABUNDANCE
### INPUTS
# selstreams = vector of stream ids, e.g., 1.064 (lake + strcode/1000)
# allstreamdf = data frame of mark-recap estimates for all streams, with vars:  year lake ls Emr CVmr
# alllakedf = data frame of lake-wide PEs from Mullett et al. (2003) spawner model with vars:  lake year PE
# min.nmr = minimum number of mark-recapture estimates needed in a year to generate an index, default 2
# show = print out a brief summary of the results, default FALSE
### OUTPUTS
# indfit = simple model used to predict missing mark-recap estimates
# streamdf = original allstreamdf, subsetted by selstreams, with estimates for missing mark-recaps
# indxdf = original alllakedf, subsetted by lake, with annual index, including raw (indxraw), kept based on min.nmr (indxkeep, indxkeep.lo, indxkeep.hi)
# scaleup = conversion factor used to scale up annual index to spawner model PE
streamdf <- allstreamdf[allstreamdf$ls %in% selstreams, ]
# error checks
check1 <- var(streamdf$lake)
if(is.na(check1) | is.null(check1)) stop("Either no streams selected or critical data missing.") else if(check1 > 0) stop("Selected streams should be only from ONE lake.")
if(any(is.na(match(c("year", "lake", "ls", "Emr", "CVmr"), names(allstreamdf))))) stop("allstreamdf must include these variables: year lake ls Emr CVmr.")
if(any(is.na(match(c("year", "lake", "PE"), names(alllakedf))))) stop("alllakedf must include these variables: lake year PE.")
# fill in missing mark-recap data
indfit <- aov(log(Emr) ~ as.factor(ls) + as.factor(year), data=streamdf, weights=1/CVmr^2)
# figure out estimable years (those with at least 1 m-r estimate)
n.mr <- tapply(!is.na(streamdf$Emr), streamdf$year, sum)
eyrs <- as.numeric(names(n.mr)[n.mr > 0.5])
estimable <- streamdf$year %in% eyrs
streamdf$Pmr <- NA
streamdf$Pmr[estimable] <- ModelEst(fit=indfit, df=streamdf[estimable, ])
streamdf$COMBmr <- ifelse(is.na(streamdf$Emr), streamdf$Pmr, streamdf$Emr)
# annual index (sum across streams)
indxdf <- aggregate(COMBmr ~ year + lake, streamdf, sum, na.rm=TRUE, na.action=na.pass)
names(indxdf)[names(indxdf)=="COMBmr"] <- "indxraw"
indxdf$indxraw[indxdf$indxraw==0] <- NA
# only keep lake-wide index for years with at least min.nmr mark-recap estimates
indxdf$n.mr <- n.mr
indxdf$indxkeep <- ifelse(indxdf$n.mr > (min.nmr - 0.5), indxdf$indxraw, NA)
indxdf$indxkeep.lo <- NA
indxdf$indxkeep.hi <- NA
# matrix of stream estimates (rows = years, columns = index streams)
streamests <- with(streamdf, tapply(COMBmr, list(year, ls), mean))
# selection of only those streams with a keepable index
selkeep <- !is.na(indxdf$indxkeep)
jack <- jackindex(streamests[selkeep, ])
indxdf$indxkeep.lo[selkeep] <- jack[, "lo"]
indxdf$indxkeep.hi[selkeep] <- jack[, "hi"]
# scale up the index to the spawner model PE
lk1 <- lk[lk$lake == streamdf$lake[1], ]
indxdf2 <- merge(lk1, indxdf, all=TRUE)
scaleup <- median(indxdf2$PE / indxdf2$indxkeep, na.rm=TRUE)
if(show) {
cat("\nindfit\n")
print(summary(indfit))
cat("\nstreamdf\n")
print(tail(streamdf[, c("lake", "year", "ls", "Emr", "CVmr", "Pmr", "COMBmr")]))
cat("\nscaleup\n")
print(scaleup)
cat("\nindxdf\n")
print(tail(indxdf[, c("lake", "year", "n.mr", "indxraw", "indxkeep", "indxkeep.lo", "indxkeep.hi")]))
}
list(indfit=indfit, streamdf=streamdf, scaleup=scaleup, indxdf=indxdf)
}
calctarg <- function(lakenum, adults, year, targyears, adjust=c(1, 1, 0.25, 1, 1)) {
# lakenum = vector of lake numbers (1-5)
# adults = vector of lakewide adult sea lamprey estimates
# year = vector of years
# targyears = list (length 5) of selected years from which to calculate targets
# lake huron target is 25% of
targets <- data.frame(lake=1:5, target=rep(NA, 5), lo=rep(NA, 5), hi=rep(NA, 5))
for(i in 1:5) {
pick5 <- adults[lakenum==i & is.element(year, targyears[[i]]) & !is.na(adults)]
if(length(pick5) > 0) {
targets$target[i] <- mean(pick5)
n <- length(pick5)
ci <- qnorm(1 - 0.05/2) * sqrt(var(pick5)) / sqrt(n)
targets[i, c("lo", "hi")] <- mean(pick5) + c(-1, 1)*ci# using z dist (known variance)
targets[i, c("target", "lo", "hi")] <- adjust[i]*targets[i, c("target", "lo", "hi")]
} else {
targets[i, c("target", "lo", "hi")] <- c(NA, NA, NA)
}
}
targets
}
}
# bring in lake-wide spawner data
lk <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/LakePEdynamic.csv", as.is=T)
# bring in stream-specific data
dat <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/StreamPEdynamicALLCOLS.csv", as.is=T)
dat$ls <- dat$lscode
# 2014-04-09 Jess and Gale agreed that the East Au Gres (38) should be replaced with the Au Sable (36) in Lake Huron
# 2014-04-10 Jess thinks that we should just stick with the East Au Gres (38)
index.streams <- list(
Sup = c(1, 2, 9, 29, 31, 32, 62),
Mic = c(5, 6, 15, 24, 26, 35),
Hur = c(10, 16, 27, 32, 999, 38),
Eri = c(1, 2, 3, 7, 9),
Ont = c(5, 9, 22, 23, 36)
)
index.streams <- lapply(1:5, function(i) i + index.streams[[i]]/1000)
# estimate adult index of abundance for each lake using index streams
indices <- lapply(index.streams, index.est, dat, lk)
# combine index data for all lakes in one dataframe
indxall <- do.call(rbind, lapply(indices, "[[", "indxdf"))
# calculate targets 
sptargyrz <- list(1994:1998, 1988:1992, 1989:1993, 1991:1995, 1999:2003)
targyrz <- apply(sapply(sptargyrz, range), 2, paste, collapse="-")
# spawner model
targets.sm <- calctarg(lakenum=lk$lake, adults=lk$PE, year=lk$year, targyears=sptargyrz)
# adult index
targets.ai <- calctarg(lakenum=indxall$lake, adults=indxall$indxkeep, year=indxall$year, targyears=sptargyrz)
# spawner model targets scaled down to adult index
targets.sm.su <- cbind(lake=targets.sm[, 1], (1/sapply(indices, "[[", "scaleup")) * targets.sm[, -1])
# adult index adjusted
targets.ai.adj <- targets.ai
targets.ai.adj[is.na(targets.ai$target), ] <- targets.sm.su[is.na(targets.ai$target), ]
YEAR1 <- 1984
# create a Word document with results
doc <- startrtf(file="2014-10 SLCB Index", dir="C:/JVA/Lamprey/Adults/AdultIndex/2014", omi=c(1, 1.25, 1, 1.25))
heading("Index of Adult Sea Lamprey Abundance in each Great Lake")
heading(paste("Adams, Barber, Bravener, Steeves -", as.character(Sys.Date())), htype=2)
### Spawner model time series
heading("Purpose of the index", htype=3)
heading("Selection of index streams", htype=3)
heading("Calculation of index", htype=3)
heading("Assumptions", htype=3)
heading("Fate of current spawner model", htype=3)
para("Conversion factors: ", paste(Lakenames, round(sapply(indices, "[[", "scaleup"), 2), collapse=", "), ".")
# position of text for selected streams in each lake (for map drawing)
posp <- list(c(3, 1, 3, 1, 1, 3, 1),
c(2, 2, 2, 2, 2, 2),
c(4, 4, 4, 4, 4, 4),
c(4, 2, 4, 2, 4),
c(2, 3, 2, 2, 2, 2))
### map of selected streams
col5 <- c("#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00")
mymap <- map5
fig <- function() {
par(mar=c(0, 0, 0, 0))
map(xlim=range(mymap$x, na.rm=T), ylim=range(mymap$y, na.rm=T), col=NA, mar=rep(1, 4))
lines(mymap$x, mymap$y, col="darkgray", lwd=0.5)
for(i in 1:5) {
mystreamdf <- indices[[i]]$streamdf
with(mystreamdf[mystreamdf$year==2010, ], {
points(long, lat, cex=1.5, pch=16, col=col5[i])
par(xpd=NA)
text(long, lat, strname, cex=1.2, pos=posp[[i]], col=col5[i])
})
}
}
figu("Streams selected for inclusion in the index of adult sea lamprey abundance.", newpage="land", w=9, h=5.7)
outcex <- 1.2
### bar plot of individual index stream PEs
col7 <- c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69")
fig <- function() {
par(mar=c(2.5, 2.5, 1, 1), mfrow=c(3, 2), yaxs="i", oma=c(1.5, 1.5, 0, 0), cex=1.2)
for(i in 1:5) {
mymap <- mapL[[i]]
mystreamdf <- indices[[i]]$streamdf
myindxdf <- indices[[i]]$indxdf
mystreamdf <- mystreamdf[mystreamdf$year >= YEAR1, ]
myindxdf <- myindxdf[myindxdf$year >= YEAR1, ]
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p[is.na(myindxdf$indxkeep), ] <- NA
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
a <- barplot(t(p)/1000, las=1, col=col7, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.01*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="", ylab="", main=Lakenames[i], border=NA, lwd=0.5)
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2, las=1)
box()
legend("topleft", rev(colnames(p)), fill=rev(col7[1:dim(p)[2]]), cex=0.5, bty="n", lwd=0.5)
if(i==1) {
frame()
}
}
mtext("Year", outer=TRUE, side=1, cex=outcex)
mtext("Adult abundance  (thousands)", outer=TRUE, side=2, cex=outcex)
}
figu("Adult sea lamprey abundance estimates for index streams.", newpage="port", w=6, h=7.5)
### spawner model and adult index time series overlaid
fig <- function() {
par(mfrow=c(3, 2), mar=c(3, 3, 1, 3), oma=c(1.5, 1.5, 0, 0), cex=1.2, yaxs="i")
for(i in 1:5) {
mylk <- lk[lk$lake==i, ]# lake year PE lo hi
myindxdf <- indices[[i]]$indxdf# year lake indxraw n.mr indxkeep indxkeep.lo indxkeep.hi
convfac <- indices[[i]]$scaleup
x1 <- myindxdf$year
y1 <- myindxdf$indxkeep/1000
x2 <- mylk$year
y2 <- mylk$PE/convfac/1000
yr <- 1.05*range(0, y1, y2[x2>=YEAR1], na.rm=TRUE)
plot(1, 1, type="n", xlim=range(lk$year), ylim=yr, xlab="", ylab="", main=Lakenames[i], axes=FALSE)
axis(1)
axis(2, col=blindcolz[7], col.axis=blindcolz[7], las=1)
par(mgp=c(3, 2.2, 0))
axis(4, at=pretty(convfac*yr)/convfac, labels=pretty(convfac*yr), col=blindcolz[3], col.axis=blindcolz[3], las=1, hadj=1)
par(mgp=c(3, 1, 0))
box()
abline(h=targets.sm$target[i]/convfac/1000, col=blindcolz[3], lty=2)
abline(h=targets.ai.adj$target[i]/1000, col=blindcolz[7], lty=2)
lines(x2, y2, col=blindcolz[3], type="o", pch=18, lwd=2)
lines(x1, y1, col=blindcolz[7], type="o", pch=17, lwd=2)
if(i==1) {
plot(1, 1, type="n", xlab="", ylab="", axes=FALSE)
legend("center", c("Adult index", "Spawner model"), col=blindcolz[c(7, 3)], lwd=2, pch=c(17, 18))
}
}
mtext("Year", outer=TRUE, side=1, cex=outcex)
mtext("Adult abundance  (thousands)", outer=TRUE, side=2, cex=outcex)
}
figu("Patterns over time in adult sea lamprey abundance, comparing the newly derived index with the spawner model.",
"  Targets are indicated by dashed horizontal lines.",
"  Targets are based on averages from five years with historically acceptable wounding rates: ", paste(paste(targyrz, "in", Lakenames), collapse=", "), ".", 
newpage="port", w=6, h=7.5)
endrtf()
names(indices[[1]])
# "indfit"   "streamdf" "scaleup"  "indxdf"
# scale up
round(sapply(indices, "[[", 3), 2)
# 3.84 1.85 2.82 1.01 2.40
indxall[7:11, ]
   # year lake   indxraw n.mr  indxkeep indxkeep.lo indxkeep.hi
# 7  1986    1 24275.673    5 24275.673   18726.753   27579.203
# 8  1987    1 10994.483    5 10994.483   10269.609   11494.884
# 9  1988    1 13630.037    5 13630.037   11710.612   14680.398
# 10 1989    1 20227.926    6 20227.926   18704.166   21988.594
# 11 1990    1  9332.001    5  9332.001    8435.646   11991.514
?legend
# C:\JVA\Lamprey\Adults\AdultIndex\2014\AdultIndex v2.r
{ # functions
# the following seven plot.table related function are from the Systmatic Investor Toolbox
# load Systematic Investor Toolbox
# require(RCurl)
# sit = getURLContent("https://github.com/systematicinvestor/SIT/raw/master/sit.gz", binary=TRUE, followlocation=TRUE, ssl.verifypeer=FALSE)
# con = gzcon(rawConnection(sit, "rb"))
# source(con)
# close(con)
draw.cell <- function(title, r, c, text.cex = 1, bg.col = 'white', frame.cell = T) {
if(!frame.cell) bcol = bg.col else bcol = 'black'
rect((2*(c - 1) + .5), -(r - .5), (2*c + .5), -(r + .5), col = bg.col, border = bcol)
if( c == 1) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else if( r == 1 ) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else {
text((2*c + .5), -r, title, adj = 1, cex = text.cex)
}
}
plot.table.helper.auto.adjust.cex <- function(temp.table, keep.all.same.cex = FALSE) {
nr = nrow(temp.table)
nc = ncol(temp.table)
all.xrange = diff(par()$usr[1:2]) / nc
xrange = matrix( strwidth(paste('  ', temp.table), units = 'user', cex = 1), nc = nc)
all.yrange = diff(par()$usr[3:4]) / nr
yrange = matrix( 5/3 * strheight(temp.table, units = 'user', cex = 1), nc = nc)
plot.matrix.cex = pmin( round(all.yrange / yrange, 2) , round(all.xrange / xrange, 2) )
header.col.cex = min(plot.matrix.cex[1,-1])
header.row.cex = min(plot.matrix.cex[-1,1])
title.cex = plot.matrix.cex[1, 1]
data.cex = min(plot.matrix.cex[-1, -1])
if ( keep.all.same.cex ) {
plot.matrix.cex[] = min(plot.matrix.cex)
} else {
plot.matrix.cex[1,-1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,-1]= min(c(header.col.cex, header.row.cex, data.cex))
plot.matrix.cex[1,1]= min(c(header.col.cex, header.row.cex, data.cex, title.cex))
plot.matrix.cex[1,-1] = min(c(header.col.cex))
plot.matrix.cex[-1,1] = min(c(header.row.cex))
plot.matrix.cex[-1,-1]= min(c(data.cex))
plot.matrix.cex[1,1]= min(c(title.cex))
}
return(plot.matrix.cex)
}
make.table <- function(nr, nc) {
savepar = par(mar = rep(1, 4))
plot(c(0.5, nc*2 + 0.5), c(-0.5, -(nr + 0.5)), xaxs = 'i', yaxs = 'i',
type = 'n', xlab = '', ylab = '', axes = FALSE)
savepar
}
trim <- function(s) {
s = sub(pattern = '^ +', replacement = '', x = s)
s = sub(pattern = ' +$', replacement = '', x = s)
return(s)
}
plot.table.param <- function(plot.matrix, smain = '', plot.matrix.cex, plot.matrix_bg.col, frame.cell = T, keep.all.same.cex = FALSE) {
n = nrow(plot.matrix)
pages = unique(c(seq(0, n, by = 120), n))
for(p in 1:(length(pages)-1)) {
rindex = (pages[p]+1) : pages[p+1]
temp.table = matrix('', nr = length(rindex)+1, nc = ncol(plot.matrix)+1)
temp.table[-1, -1] = plot.matrix[rindex,]
temp.table[1, -1] = colnames(plot.matrix)
temp.table[-1, 1] = rownames(plot.matrix)[rindex]
temp.table[1, 1] = smain
nr = nrow(temp.table)
nc = ncol(temp.table)
par(mar = c(0, 0, 0, 0), cex = 0.5)
oldpar = make.table(nr, nc)
text.cex = plot.matrix.cex[c(1, 1 + rindex), ]
text.cex = plot.table.helper.auto.adjust.cex(temp.table, keep.all.same.cex)
bg.col = plot.matrix_bg.col[c(1, 1 + rindex), ]
for(r in 1:nr) {
for(c in 1:nc) {
draw.cell( paste('', temp.table[r,c], '', sep=' '), r, c,
text.cex = text.cex[r,c], bg.col = bg.col[r,c], frame.cell = frame.cell)
}}
}
}
plot.table <- function(plot.matrix, smain="", text.cex=1, frame.cell=TRUE, highlight=FALSE, colorbar=FALSE, keep_all.same.cex=FALSE) {
if( is.null(rownames(plot.matrix)) & is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
if( ncol(temp.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[-1, -1, drop = FALSE]
colnames(plot.matrix) = temp.matrix[1, -1]
rownames(plot.matrix) = temp.matrix[-1, 1]
smain = temp.matrix[1, 1]
} else if( is.null(rownames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( ncol(plot.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[, -1, drop = FALSE]
colnames(plot.matrix) = colnames(temp.matrix)[-1]
rownames(plot.matrix) = temp.matrix[,1]
smain = colnames(temp.matrix)[1]
} else if( is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
plot.matrix = temp.matrix[-1, , drop = FALSE]
rownames(plot.matrix) = rownames(temp.matrix)[-1]
colnames(plot.matrix) = temp.matrix[1, ]
smain = rownames(temp.matrix)[1]
}
plot.matrix[which(trim(plot.matrix) == "NA")] = ""
plot.matrix[which(trim(plot.matrix) == "NA%")] = ""
plot.matrix[which(is.na(plot.matrix))] = ""
nr = nrow(plot.matrix) + 1
nc = ncol(plot.matrix) + 1
is_highlight = TRUE
if(is.logical(highlight)) {
is_highlight = highlight
if(highlight) highlight = plot.table.helper.color(plot.matrix)
}
if(!is_highlight) {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[seq(1, nr, 2), ] = "yellow"
plot.matrix_bg.col[1,] = "gray";
plot.table.param( plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
} else {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[1,] = "gray"
plot.matrix_bg.col[2:nr,2:nc] = highlight
plot.table.param(plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
}
}
plot.table.helper.color <- function (temp) {
temp = matrix(as.double(gsub("[%,$]", "", temp)), nrow(temp), ncol(temp))
highlight = as.vector(temp)
cols = rep(NA, length(highlight))
ncols = length(highlight[!is.na(highlight)])
cols[1:ncols] = rev(rainbow(ncols, start=0.5/6, end=3.5/6))
o = sort.list(highlight, na.last = TRUE, decreasing = FALSE)
o1 = sort.list(o, na.last = TRUE, decreasing = FALSE)
highlight = matrix(cols[o1], nrow = nrow(temp))
highlight[is.na(temp)] = NA
return(highlight)
}
ModelEst <- function(fit, df) {
# derive regression estimates from log(y) fit
mse <- rev(as.matrix(summary(fit)[[1]])[, "Mean Sq"])[1]
plpe <- predict(fit, newdata=df, se.fit=T)
m <- plpe$fit
v <- plpe$se.fit^2 + mse
exp(m + v/2)
}
myrange <- function(x) {
if(all(is.na(x))) r <- c(NA, NA) else r <- range(x, na.rm=TRUE)
return(r)
}
jackindex <- function(m) {
# m is a matrix of numbers (stream PEs) with observations (years) as rows and individuals (streams) as columns
if(any(is.na(m))) stop("The input matrix may not have any missing values.")
# calculate the index as the sum of the columns for each row
rowsum <- apply(m, 1, sum)
# calculate the mean of the index
avgind <- mean(rowsum)
# recalculate the index, leaving out one individual at a time
loo <- apply(m, 2, function(column) (rowsum - column))
# rescale the loo index, relative to mean
looscaled <- apply(loo, 2, function(x) x/mean(x))
# convert to original scale
looscaled2 <- looscaled * avgind
# calculate range
ranges <- t(apply(looscaled2, 1, range))
cbind(index=rowsum, lo=ranges[, 1], hi=ranges[, 2])
}
# selstreams <- index.streams[[1]] 
# allstreamdf <- dat
# alllakedf <- lk 
# min.nmr=2 
# show=FALSE
index.est <- function(selstreams, allstreamdf, alllakedf, min.nmr=2, show=FALSE) {
# INDEX OF ADULT SEA LAMPREY ABUNDANCE
### INPUTS
# selstreams = vector of stream ids, e.g., 1.064 (lake + strcode/1000)
# allstreamdf = data frame of mark-recap estimates for all streams, with vars:  year lake ls Emr CVmr
# alllakedf = data frame of lake-wide PEs from Mullett et al. (2003) spawner model with vars:  lake year PE
# min.nmr = minimum number of mark-recapture estimates needed in a year to generate an index, default 2
# show = print out a brief summary of the results, default FALSE
### OUTPUTS
# indfit = simple model used to predict missing mark-recap estimates
# streamdf = original allstreamdf, subsetted by selstreams, with estimates for missing mark-recaps
# indxdf = original alllakedf, subsetted by lake, with annual index, including raw (indxraw), kept based on min.nmr (indxkeep, indxkeep.lo, indxkeep.hi)
# scaleup = conversion factor used to scale up annual index to spawner model PE
streamdf <- allstreamdf[allstreamdf$ls %in% selstreams, ]
# error checks
check1 <- var(streamdf$lake)
if(is.na(check1) | is.null(check1)) stop("Either no streams selected or critical data missing.") else if(check1 > 0) stop("Selected streams should be only from ONE lake.")
if(any(is.na(match(c("year", "lake", "ls", "Emr", "CVmr"), names(allstreamdf))))) stop("allstreamdf must include these variables: year lake ls Emr CVmr.")
if(any(is.na(match(c("year", "lake", "PE"), names(alllakedf))))) stop("alllakedf must include these variables: lake year PE.")
# fill in missing mark-recap data
indfit <- aov(log(Emr) ~ as.factor(ls) + as.factor(year), data=streamdf, weights=1/CVmr^2)
# figure out estimable years (those with at least 1 m-r estimate)
n.mr <- tapply(!is.na(streamdf$Emr), streamdf$year, sum)
eyrs <- as.numeric(names(n.mr)[n.mr > 0.5])
estimable <- streamdf$year %in% eyrs
streamdf$Pmr <- NA
streamdf$Pmr[estimable] <- ModelEst(fit=indfit, df=streamdf[estimable, ])
streamdf$COMBmr <- ifelse(is.na(streamdf$Emr), streamdf$Pmr, streamdf$Emr)
# annual index (sum across streams)
indxdf <- aggregate(COMBmr ~ year + lake, streamdf, sum, na.rm=TRUE, na.action=na.pass)
names(indxdf)[names(indxdf)=="COMBmr"] <- "indxraw"
indxdf$indxraw[indxdf$indxraw==0] <- NA
# only keep lake-wide index for years with at least min.nmr mark-recap estimates
indxdf$n.mr <- n.mr
indxdf$indxkeep <- ifelse(indxdf$n.mr > (min.nmr - 0.5), indxdf$indxraw, NA)
indxdf$indxkeep.lo <- NA
indxdf$indxkeep.hi <- NA
# matrix of stream estimates (rows = years, columns = index streams)
streamests <- with(streamdf, tapply(COMBmr, list(year, ls), mean))
# selection of only those streams with a keepable index
selkeep <- !is.na(indxdf$indxkeep)
jack <- jackindex(streamests[selkeep, ])
indxdf$indxkeep.lo[selkeep] <- jack[, "lo"]
indxdf$indxkeep.hi[selkeep] <- jack[, "hi"]
# scale up the index to the spawner model PE
lk1 <- lk[lk$lake == streamdf$lake[1], ]
indxdf2 <- merge(lk1, indxdf, all=TRUE)
scaleup <- median(indxdf2$PE / indxdf2$indxkeep, na.rm=TRUE)
if(show) {
cat("\nindfit\n")
print(summary(indfit))
cat("\nstreamdf\n")
print(tail(streamdf[, c("lake", "year", "ls", "Emr", "CVmr", "Pmr", "COMBmr")]))
cat("\nscaleup\n")
print(scaleup)
cat("\nindxdf\n")
print(tail(indxdf[, c("lake", "year", "n.mr", "indxraw", "indxkeep", "indxkeep.lo", "indxkeep.hi")]))
}
list(indfit=indfit, streamdf=streamdf, scaleup=scaleup, indxdf=indxdf)
}
calctarg <- function(lakenum, adults, year, targyears, adjust=c(1, 1, 0.25, 1, 1)) {
# lakenum = vector of lake numbers (1-5)
# adults = vector of lakewide adult sea lamprey estimates
# year = vector of years
# targyears = list (length 5) of selected years from which to calculate targets
# lake huron target is 25% of
targets <- data.frame(lake=1:5, target=rep(NA, 5), lo=rep(NA, 5), hi=rep(NA, 5))
for(i in 1:5) {
pick5 <- adults[lakenum==i & is.element(year, targyears[[i]]) & !is.na(adults)]
if(length(pick5) > 0) {
targets$target[i] <- mean(pick5)
n <- length(pick5)
ci <- qnorm(1 - 0.05/2) * sqrt(var(pick5)) / sqrt(n)
targets[i, c("lo", "hi")] <- mean(pick5) + c(-1, 1)*ci# using z dist (known variance)
targets[i, c("target", "lo", "hi")] <- adjust[i]*targets[i, c("target", "lo", "hi")]
} else {
targets[i, c("target", "lo", "hi")] <- c(NA, NA, NA)
}
}
targets
}
}
# bring in lake-wide spawner data
lk <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/LakePEdynamic.csv", as.is=T)
# bring in stream-specific data
dat <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/StreamPEdynamicALLCOLS.csv", as.is=T)
dat$ls <- dat$lscode
# 2014-04-09 Jess and Gale agreed that the East Au Gres (38) should be replaced with the Au Sable (36) in Lake Huron
# 2014-04-10 Jess thinks that we should just stick with the East Au Gres (38)
index.streams <- list(
Sup = c(1, 2, 9, 29, 31, 32, 62),
Mic = c(5, 6, 15, 24, 26, 35),
Hur = c(10, 16, 27, 32, 999, 38),
Eri = c(1, 2, 3, 7, 9),
Ont = c(5, 9, 22, 23, 36)
)
index.streams <- lapply(1:5, function(i) i + index.streams[[i]]/1000)
# estimate adult index of abundance for each lake using index streams
indices <- lapply(index.streams, index.est, dat, lk)
# combine index data for all lakes in one dataframe
indxall <- do.call(rbind, lapply(indices, "[[", "indxdf"))
# calculate targets 
sptargyrz <- list(1994:1998, 1988:1992, 1989:1993, 1991:1995, 1999:2003)
targyrz <- apply(sapply(sptargyrz, range), 2, paste, collapse="-")
# spawner model
targets.sm <- calctarg(lakenum=lk$lake, adults=lk$PE, year=lk$year, targyears=sptargyrz)
# adult index
targets.ai <- calctarg(lakenum=indxall$lake, adults=indxall$indxkeep, year=indxall$year, targyears=sptargyrz)
# spawner model targets scaled down to adult index
targets.sm.su <- cbind(lake=targets.sm[, 1], (1/sapply(indices, "[[", "scaleup")) * targets.sm[, -1])
# adult index adjusted
targets.ai.adj <- targets.ai
targets.ai.adj[is.na(targets.ai$target), ] <- targets.sm.su[is.na(targets.ai$target), ]
YEAR1 <- 1984
# create a Word document with results
doc <- startrtf(file="2014-10 SLCB Index", dir="C:/JVA/Lamprey/Adults/AdultIndex/2014", omi=c(1, 1.25, 1, 1.25))
heading("Index of Adult Sea Lamprey Abundance in each Great Lake")
heading(paste("Adams, Barber, Bravener, Steeves -", as.character(Sys.Date())), htype=2)
### Spawner model time series
heading("Purpose of the index", htype=3)
heading("Selection of index streams", htype=3)
heading("Calculation of index", htype=3)
heading("Assumptions", htype=3)
heading("Fate of current spawner model", htype=3)
para("Conversion factors: ", paste(Lakenames, round(sapply(indices, "[[", "scaleup"), 2), collapse=", "), ".")
# position of text for selected streams in each lake (for map drawing)
posp <- list(c(3, 1, 3, 1, 1, 3, 1),
c(2, 2, 2, 2, 2, 2),
c(4, 4, 4, 4, 4, 4),
c(2, 4, 2, 4, 2),
c(2, 2, 3, 2, 2, 2))
### map of selected streams
col5 <- c("#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00")
mymap <- map5
fig <- function() {
par(mar=c(0, 0, 0, 0))
map(xlim=range(mymap$x, na.rm=T), ylim=range(mymap$y, na.rm=T), col=NA, mar=rep(1, 4))
lines(mymap$x, mymap$y, col="darkgray", lwd=0.5)
for(i in 1:5) {
mystreamdf <- indices[[i]]$streamdf
with(mystreamdf[mystreamdf$year==2010, ], {
points(long, lat, cex=1.5, pch=16, col=col5[i])
par(xpd=NA)
text(long, lat, strname, cex=1.2, pos=posp[[i]], col=col5[i])
})
}
}
figu("Streams selected for inclusion in the index of adult sea lamprey abundance.", newpage="land", w=9, h=5.7)
outcex <- 1.2
### bar plot of individual index stream PEs
col7 <- c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69")
fig <- function() {
par(mar=c(2.5, 2.5, 1, 1), mfrow=c(3, 2), yaxs="i", oma=c(1.5, 1.5, 0, 0), cex=1.2)
for(i in 1:5) {
mymap <- mapL[[i]]
mystreamdf <- indices[[i]]$streamdf
myindxdf <- indices[[i]]$indxdf
mystreamdf <- mystreamdf[mystreamdf$year >= YEAR1, ]
myindxdf <- myindxdf[myindxdf$year >= YEAR1, ]
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p[is.na(myindxdf$indxkeep), ] <- NA
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
a <- barplot(t(p)/1000, las=1, col=col7, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.01*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="", ylab="", main=Lakenames[i], border=NA)
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2, las=1)
box()
legend("topleft", rev(colnames(p)), fill=rev(col7[1:dim(p)[2]]), cex=0.5, bty="n", border=NA)
if(i==1) {
frame()
}
}
mtext("Year", outer=TRUE, side=1, cex=outcex)
mtext("Adult abundance  (thousands)", outer=TRUE, side=2, cex=outcex)
}
figu("Adult sea lamprey abundance estimates for index streams.", newpage="port", w=6, h=7.5)
### spawner model and adult index time series overlaid
fig <- function() {
par(mfrow=c(3, 2), mar=c(3, 3, 1, 3), oma=c(1.5, 1.5, 0, 0), cex=1.2, yaxs="i")
for(i in 1:5) {
mylk <- lk[lk$lake==i, ]# lake year PE lo hi
myindxdf <- indices[[i]]$indxdf# year lake indxraw n.mr indxkeep indxkeep.lo indxkeep.hi
convfac <- indices[[i]]$scaleup
x1 <- myindxdf$year
y1 <- myindxdf$indxkeep/1000
x2 <- mylk$year
y2 <- mylk$PE/convfac/1000
yr <- 1.05*range(0, y1, y2[x2>=YEAR1], na.rm=TRUE)
plot(1, 1, type="n", xlim=range(lk$year), ylim=yr, xlab="", ylab="", main=Lakenames[i], axes=FALSE)
axis(1)
axis(2, col=blindcolz[7], col.axis=blindcolz[7], las=1)
par(mgp=c(3, 2.2, 0))
axis(4, at=pretty(convfac*yr)/convfac, labels=pretty(convfac*yr), col=blindcolz[3], col.axis=blindcolz[3], las=1, hadj=1)
par(mgp=c(3, 1, 0))
box()
abline(h=targets.sm$target[i]/convfac/1000, col=blindcolz[3], lty=2)
abline(h=targets.ai.adj$target[i]/1000, col=blindcolz[7], lty=2)
lines(x2, y2, col=blindcolz[3], type="o", pch=18, lwd=2)
lines(x1, y1, col=blindcolz[7], type="o", pch=17, lwd=2)
if(i==1) {
plot(1, 1, type="n", xlab="", ylab="", axes=FALSE)
legend("center", c("Adult index", "Spawner model"), col=blindcolz[c(7, 3)], lwd=2, pch=c(17, 18))
}
}
mtext("Year", outer=TRUE, side=1, cex=outcex)
mtext("Adult abundance  (thousands)", outer=TRUE, side=2, cex=outcex)
}
figu("Patterns over time in adult sea lamprey abundance, comparing the newly derived index with the spawner model.",
"  Targets are indicated by dashed horizontal lines.",
"  Targets are based on averages from five years with historically acceptable wounding rates: ", paste(paste(targyrz, "in", Lakenames), collapse=", "), ".", 
newpage="port", w=6, h=7.5)
endrtf()
names(indices[[1]])
# "indfit"   "streamdf" "scaleup"  "indxdf"
# scale up
round(sapply(indices, "[[", 3), 2)
# 3.84 1.85 2.82 1.01 2.40
indxall[7:11, ]
   # year lake   indxraw n.mr  indxkeep indxkeep.lo indxkeep.hi
# 7  1986    1 24275.673    5 24275.673   18726.753   27579.203
# 8  1987    1 10994.483    5 10994.483   10269.609   11494.884
# 9  1988    1 13630.037    5 13630.037   11710.612   14680.398
# 10 1989    1 20227.926    6 20227.926   18704.166   21988.594
# 11 1990    1  9332.001    5  9332.001    8435.646   11991.514
1995:2014
# C:\JVA\Lamprey\Adults\AdultIndex\2014\AdultIndex v2.r
{ # functions
# the following seven plot.table related function are from the Systmatic Investor Toolbox
# load Systematic Investor Toolbox
# require(RCurl)
# sit = getURLContent("https://github.com/systematicinvestor/SIT/raw/master/sit.gz", binary=TRUE, followlocation=TRUE, ssl.verifypeer=FALSE)
# con = gzcon(rawConnection(sit, "rb"))
# source(con)
# close(con)
draw.cell <- function(title, r, c, text.cex = 1, bg.col = 'white', frame.cell = T) {
if(!frame.cell) bcol = bg.col else bcol = 'black'
rect((2*(c - 1) + .5), -(r - .5), (2*c + .5), -(r + .5), col = bg.col, border = bcol)
if( c == 1) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else if( r == 1 ) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else {
text((2*c + .5), -r, title, adj = 1, cex = text.cex)
}
}
plot.table.helper.auto.adjust.cex <- function(temp.table, keep.all.same.cex = FALSE) {
nr = nrow(temp.table)
nc = ncol(temp.table)
all.xrange = diff(par()$usr[1:2]) / nc
xrange = matrix( strwidth(paste('  ', temp.table), units = 'user', cex = 1), nc = nc)
all.yrange = diff(par()$usr[3:4]) / nr
yrange = matrix( 5/3 * strheight(temp.table, units = 'user', cex = 1), nc = nc)
plot.matrix.cex = pmin( round(all.yrange / yrange, 2) , round(all.xrange / xrange, 2) )
header.col.cex = min(plot.matrix.cex[1,-1])
header.row.cex = min(plot.matrix.cex[-1,1])
title.cex = plot.matrix.cex[1, 1]
data.cex = min(plot.matrix.cex[-1, -1])
if ( keep.all.same.cex ) {
plot.matrix.cex[] = min(plot.matrix.cex)
} else {
plot.matrix.cex[1,-1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,-1]= min(c(header.col.cex, header.row.cex, data.cex))
plot.matrix.cex[1,1]= min(c(header.col.cex, header.row.cex, data.cex, title.cex))
plot.matrix.cex[1,-1] = min(c(header.col.cex))
plot.matrix.cex[-1,1] = min(c(header.row.cex))
plot.matrix.cex[-1,-1]= min(c(data.cex))
plot.matrix.cex[1,1]= min(c(title.cex))
}
return(plot.matrix.cex)
}
make.table <- function(nr, nc) {
savepar = par(mar = rep(1, 4))
plot(c(0.5, nc*2 + 0.5), c(-0.5, -(nr + 0.5)), xaxs = 'i', yaxs = 'i',
type = 'n', xlab = '', ylab = '', axes = FALSE)
savepar
}
trim <- function(s) {
s = sub(pattern = '^ +', replacement = '', x = s)
s = sub(pattern = ' +$', replacement = '', x = s)
return(s)
}
plot.table.param <- function(plot.matrix, smain = '', plot.matrix.cex, plot.matrix_bg.col, frame.cell = T, keep.all.same.cex = FALSE) {
n = nrow(plot.matrix)
pages = unique(c(seq(0, n, by = 120), n))
for(p in 1:(length(pages)-1)) {
rindex = (pages[p]+1) : pages[p+1]
temp.table = matrix('', nr = length(rindex)+1, nc = ncol(plot.matrix)+1)
temp.table[-1, -1] = plot.matrix[rindex,]
temp.table[1, -1] = colnames(plot.matrix)
temp.table[-1, 1] = rownames(plot.matrix)[rindex]
temp.table[1, 1] = smain
nr = nrow(temp.table)
nc = ncol(temp.table)
par(mar = c(0, 0, 0, 0), cex = 0.5)
oldpar = make.table(nr, nc)
text.cex = plot.matrix.cex[c(1, 1 + rindex), ]
text.cex = plot.table.helper.auto.adjust.cex(temp.table, keep.all.same.cex)
bg.col = plot.matrix_bg.col[c(1, 1 + rindex), ]
for(r in 1:nr) {
for(c in 1:nc) {
draw.cell( paste('', temp.table[r,c], '', sep=' '), r, c,
text.cex = text.cex[r,c], bg.col = bg.col[r,c], frame.cell = frame.cell)
}}
}
}
plot.table <- function(plot.matrix, smain="", text.cex=1, frame.cell=TRUE, highlight=FALSE, colorbar=FALSE, keep_all.same.cex=FALSE) {
if( is.null(rownames(plot.matrix)) & is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
if( ncol(temp.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[-1, -1, drop = FALSE]
colnames(plot.matrix) = temp.matrix[1, -1]
rownames(plot.matrix) = temp.matrix[-1, 1]
smain = temp.matrix[1, 1]
} else if( is.null(rownames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( ncol(plot.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[, -1, drop = FALSE]
colnames(plot.matrix) = colnames(temp.matrix)[-1]
rownames(plot.matrix) = temp.matrix[,1]
smain = colnames(temp.matrix)[1]
} else if( is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
plot.matrix = temp.matrix[-1, , drop = FALSE]
rownames(plot.matrix) = rownames(temp.matrix)[-1]
colnames(plot.matrix) = temp.matrix[1, ]
smain = rownames(temp.matrix)[1]
}
plot.matrix[which(trim(plot.matrix) == "NA")] = ""
plot.matrix[which(trim(plot.matrix) == "NA%")] = ""
plot.matrix[which(is.na(plot.matrix))] = ""
nr = nrow(plot.matrix) + 1
nc = ncol(plot.matrix) + 1
is_highlight = TRUE
if(is.logical(highlight)) {
is_highlight = highlight
if(highlight) highlight = plot.table.helper.color(plot.matrix)
}
if(!is_highlight) {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[seq(1, nr, 2), ] = "yellow"
plot.matrix_bg.col[1,] = "gray";
plot.table.param( plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
} else {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[1,] = "gray"
plot.matrix_bg.col[2:nr,2:nc] = highlight
plot.table.param(plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
}
}
plot.table.helper.color <- function (temp) {
temp = matrix(as.double(gsub("[%,$]", "", temp)), nrow(temp), ncol(temp))
highlight = as.vector(temp)
cols = rep(NA, length(highlight))
ncols = length(highlight[!is.na(highlight)])
cols[1:ncols] = rev(rainbow(ncols, start=0.5/6, end=3.5/6))
o = sort.list(highlight, na.last = TRUE, decreasing = FALSE)
o1 = sort.list(o, na.last = TRUE, decreasing = FALSE)
highlight = matrix(cols[o1], nrow = nrow(temp))
highlight[is.na(temp)] = NA
return(highlight)
}
ModelEst <- function(fit, df) {
# derive regression estimates from log(y) fit
mse <- rev(as.matrix(summary(fit)[[1]])[, "Mean Sq"])[1]
plpe <- predict(fit, newdata=df, se.fit=T)
m <- plpe$fit
v <- plpe$se.fit^2 + mse
exp(m + v/2)
}
myrange <- function(x) {
if(all(is.na(x))) r <- c(NA, NA) else r <- range(x, na.rm=TRUE)
return(r)
}
jackindex <- function(m) {
# m is a matrix of numbers (stream PEs) with observations (years) as rows and individuals (streams) as columns
if(any(is.na(m))) stop("The input matrix may not have any missing values.")
# calculate the index as the sum of the columns for each row
rowsum <- apply(m, 1, sum)
# calculate the mean of the index
avgind <- mean(rowsum)
# recalculate the index, leaving out one individual at a time
loo <- apply(m, 2, function(column) (rowsum - column))
# rescale the loo index, relative to mean
looscaled <- apply(loo, 2, function(x) x/mean(x))
# convert to original scale
looscaled2 <- looscaled * avgind
# calculate range
ranges <- t(apply(looscaled2, 1, range))
cbind(index=rowsum, lo=ranges[, 1], hi=ranges[, 2])
}
# selstreams <- index.streams[[1]] 
# allstreamdf <- dat
# alllakedf <- lk 
# min.nmr=2 
# show=FALSE
index.est <- function(selstreams, allstreamdf, alllakedf, min.nmr=2, show=FALSE) {
# INDEX OF ADULT SEA LAMPREY ABUNDANCE
### INPUTS
# selstreams = vector of stream ids, e.g., 1.064 (lake + strcode/1000)
# allstreamdf = data frame of mark-recap estimates for all streams, with vars:  year lake ls Emr CVmr
# alllakedf = data frame of lake-wide PEs from Mullett et al. (2003) spawner model with vars:  lake year PE
# min.nmr = minimum number of mark-recapture estimates needed in a year to generate an index, default 2
# show = print out a brief summary of the results, default FALSE
### OUTPUTS
# indfit = simple model used to predict missing mark-recap estimates
# streamdf = original allstreamdf, subsetted by selstreams, with estimates for missing mark-recaps
# indxdf = original alllakedf, subsetted by lake, with annual index, including raw (indxraw), kept based on min.nmr (indxkeep, indxkeep.lo, indxkeep.hi)
# scaleup = conversion factor used to scale up annual index to spawner model PE
streamdf <- allstreamdf[allstreamdf$ls %in% selstreams, ]
# error checks
check1 <- var(streamdf$lake)
if(is.na(check1) | is.null(check1)) stop("Either no streams selected or critical data missing.") else if(check1 > 0) stop("Selected streams should be only from ONE lake.")
if(any(is.na(match(c("year", "lake", "ls", "Emr", "CVmr"), names(allstreamdf))))) stop("allstreamdf must include these variables: year lake ls Emr CVmr.")
if(any(is.na(match(c("year", "lake", "PE"), names(alllakedf))))) stop("alllakedf must include these variables: lake year PE.")
# fill in missing mark-recap data
indfit <- aov(log(Emr) ~ as.factor(ls) + as.factor(year), data=streamdf, weights=1/CVmr^2)
# figure out estimable years (those with at least 1 m-r estimate)
n.mr <- tapply(!is.na(streamdf$Emr), streamdf$year, sum)
eyrs <- as.numeric(names(n.mr)[n.mr > 0.5])
estimable <- streamdf$year %in% eyrs
streamdf$Pmr <- NA
streamdf$Pmr[estimable] <- ModelEst(fit=indfit, df=streamdf[estimable, ])
streamdf$COMBmr <- ifelse(is.na(streamdf$Emr), streamdf$Pmr, streamdf$Emr)
# annual index (sum across streams)
indxdf <- aggregate(COMBmr ~ year + lake, streamdf, sum, na.rm=TRUE, na.action=na.pass)
names(indxdf)[names(indxdf)=="COMBmr"] <- "indxraw"
indxdf$indxraw[indxdf$indxraw==0] <- NA
# only keep lake-wide index for years with at least min.nmr mark-recap estimates
indxdf$n.mr <- n.mr
indxdf$indxkeep <- ifelse(indxdf$n.mr > (min.nmr - 0.5), indxdf$indxraw, NA)
indxdf$indxkeep.lo <- NA
indxdf$indxkeep.hi <- NA
# matrix of stream estimates (rows = years, columns = index streams)
streamests <- with(streamdf, tapply(COMBmr, list(year, ls), mean))
# selection of only those streams with a keepable index
selkeep <- !is.na(indxdf$indxkeep)
jack <- jackindex(streamests[selkeep, ])
indxdf$indxkeep.lo[selkeep] <- jack[, "lo"]
indxdf$indxkeep.hi[selkeep] <- jack[, "hi"]
# scale up the index to the spawner model PE
lk1 <- lk[lk$lake == streamdf$lake[1], ]
indxdf2 <- merge(lk1, indxdf, all=TRUE)
scaleup <- median(indxdf2$PE / indxdf2$indxkeep, na.rm=TRUE)
if(show) {
cat("\nindfit\n")
print(summary(indfit))
cat("\nstreamdf\n")
print(tail(streamdf[, c("lake", "year", "ls", "Emr", "CVmr", "Pmr", "COMBmr")]))
cat("\nscaleup\n")
print(scaleup)
cat("\nindxdf\n")
print(tail(indxdf[, c("lake", "year", "n.mr", "indxraw", "indxkeep", "indxkeep.lo", "indxkeep.hi")]))
}
list(indfit=indfit, streamdf=streamdf, scaleup=scaleup, indxdf=indxdf)
}
calctarg <- function(lakenum, adults, year, targyears, adjust=c(1, 1, 0.25, 1, 1)) {
# lakenum = vector of lake numbers (1-5)
# adults = vector of lakewide adult sea lamprey estimates
# year = vector of years
# targyears = list (length 5) of selected years from which to calculate targets
# lake huron target is 25% of
targets <- data.frame(lake=1:5, target=rep(NA, 5), lo=rep(NA, 5), hi=rep(NA, 5))
for(i in 1:5) {
pick5 <- adults[lakenum==i & is.element(year, targyears[[i]]) & !is.na(adults)]
if(length(pick5) > 0) {
targets$target[i] <- mean(pick5)
n <- length(pick5)
ci <- qnorm(1 - 0.05/2) * sqrt(var(pick5)) / sqrt(n)
targets[i, c("lo", "hi")] <- mean(pick5) + c(-1, 1)*ci# using z dist (known variance)
targets[i, c("target", "lo", "hi")] <- adjust[i]*targets[i, c("target", "lo", "hi")]
} else {
targets[i, c("target", "lo", "hi")] <- c(NA, NA, NA)
}
}
targets
}
}
# bring in lake-wide spawner data
lk <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/LakePEdynamic.csv", as.is=T)
# bring in stream-specific data
dat <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/StreamPEdynamicALLCOLS.csv", as.is=T)
dat$ls <- dat$lscode
# 2014-04-09 Jess and Gale agreed that the East Au Gres (38) should be replaced with the Au Sable (36) in Lake Huron
# 2014-04-10 Jess thinks that we should just stick with the East Au Gres (38)
index.streams <- list(
Sup = c(1, 2, 9, 29, 31, 32, 62),
Mic = c(5, 6, 15, 24, 26, 35),
Hur = c(10, 16, 27, 32, 999, 38),
Eri = c(1, 2, 3, 7, 9),
Ont = c(5, 9, 22, 23, 36)
)
index.streams <- lapply(1:5, function(i) i + index.streams[[i]]/1000)
# estimate adult index of abundance for each lake using index streams
indices <- lapply(index.streams, index.est, dat, lk)
# combine index data for all lakes in one dataframe
indxall <- do.call(rbind, lapply(indices, "[[", "indxdf"))
# calculate targets 
sptargyrz <- list(1994:1998, 1988:1992, 1989:1993, 1991:1995, 1999:2003)
targyrz <- apply(sapply(sptargyrz, range), 2, paste, collapse="-")
# spawner model
targets.sm <- calctarg(lakenum=lk$lake, adults=lk$PE, year=lk$year, targyears=sptargyrz)
# adult index
targets.ai <- calctarg(lakenum=indxall$lake, adults=indxall$indxkeep, year=indxall$year, targyears=sptargyrz)
# spawner model targets scaled down to adult index
targets.sm.su <- cbind(lake=targets.sm[, 1], (1/sapply(indices, "[[", "scaleup")) * targets.sm[, -1])
# adult index adjusted
targets.ai.adj <- targets.ai
targets.ai.adj[is.na(targets.ai$target), ] <- targets.sm.su[is.na(targets.ai$target), ]
YEAR1 <- 1984
# create a Word document with results
doc <- startrtf(file="2014-10 SLCB Index", dir="C:/JVA/Lamprey/Adults/AdultIndex/2014", omi=c(1, 1.25, 1, 1.25))
heading("Index of Adult Sea Lamprey Abundance in each Great Lake")
heading(paste("Adams, Barber, Bravener, Steeves -", as.character(Sys.Date())), htype=2)
### Spawner model time series
heading("Purpose of the index", htype=3)
heading("Selection of index streams", htype=3)
heading("Calculation of index", htype=3)
heading("Assumptions", htype=3)
heading("Fate of current spawner model", htype=3)
para("Conversion factors: ", paste(Lakenames, round(sapply(indices, "[[", "scaleup"), 2), collapse=", "), ".")
# position of text for selected streams in each lake (for map drawing)
posp <- list(c(3, 1, 3, 1, 1, 3, 1),
c(2, 2, 2, 2, 2, 2),
c(4, 4, 4, 4, 4, 4),
c(2, 4, 2, 4, 3),
c(2, 2, 3, 2, 2, 2))
### map of selected streams
col5 <- c("#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00")
mymap <- map5
fig <- function() {
par(mar=c(0, 0, 0, 0))
map(xlim=range(mymap$x, na.rm=T), ylim=range(mymap$y, na.rm=T), col=NA, mar=rep(1, 4))
lines(mymap$x, mymap$y, col="darkgray", lwd=0.5)
for(i in 1:5) {
mystreamdf <- indices[[i]]$streamdf
with(mystreamdf[mystreamdf$year==2010, ], {
points(long, lat, cex=1.5, pch=16, col=col5[i])
par(xpd=NA)
text(long, lat, strname, cex=1.2, pos=posp[[i]], col=col5[i])
})
}
}
figu("Streams selected for inclusion in the index of adult sea lamprey abundance.", newpage="land", w=9, h=5.7)
outcex <- 1.2
YEARb <- 1995
### bar plot of individual index stream PEs
col7 <- c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69")
fig <- function() {
par(mar=c(2.5, 2.5, 1, 1), mfrow=c(3, 2), yaxs="i", oma=c(1.5, 1.5, 0, 0), cex=1.2)
for(i in 1:5) {
mymap <- mapL[[i]]
mystreamdf <- indices[[i]]$streamdf
myindxdf <- indices[[i]]$indxdf
mystreamdf <- mystreamdf[mystreamdf$year >= YEARb, ]
myindxdf <- myindxdf[myindxdf$year >= YEARb, ]
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p[is.na(myindxdf$indxkeep), ] <- NA
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
a <- barplot(t(p)/1000, las=1, col=col7, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.01*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="", ylab="", main=Lakenames[i], border=NA)
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2, las=1)
box()
legend("topleft", rev(colnames(p)), fill=rev(col7[1:dim(p)[2]]), cex=0.5, bty="n", border=NA)
if(i==1) {
frame()
}
}
mtext("Year", outer=TRUE, side=1, cex=outcex)
mtext("Adult abundance  (thousands)", outer=TRUE, side=2, cex=outcex)
}
figu("Adult sea lamprey abundance estimates for index streams.", newpage="port", w=6, h=7.5)
### spawner model and adult index time series overlaid
fig <- function() {
par(mfrow=c(3, 2), mar=c(3, 3, 1, 3), oma=c(1.5, 1.5, 0, 0), cex=1.2, yaxs="i")
for(i in 1:5) {
mylk <- lk[lk$lake==i, ]# lake year PE lo hi
myindxdf <- indices[[i]]$indxdf# year lake indxraw n.mr indxkeep indxkeep.lo indxkeep.hi
convfac <- indices[[i]]$scaleup
x1 <- myindxdf$year
y1 <- myindxdf$indxkeep/1000
x2 <- mylk$year
y2 <- mylk$PE/convfac/1000
yr <- 1.05*range(0, y1, y2[x2>=YEAR1], na.rm=TRUE)
plot(1, 1, type="n", xlim=range(lk$year), ylim=yr, xlab="", ylab="", main=Lakenames[i], axes=FALSE)
axis(1)
axis(2, col=blindcolz[7], col.axis=blindcolz[7], las=1)
par(mgp=c(3, 2.2, 0))
axis(4, at=pretty(convfac*yr)/convfac, labels=pretty(convfac*yr), col=blindcolz[3], col.axis=blindcolz[3], las=1, hadj=1)
par(mgp=c(3, 1, 0))
box()
abline(h=targets.sm$target[i]/convfac/1000, col=blindcolz[3], lty=2)
abline(h=targets.ai.adj$target[i]/1000, col=blindcolz[7], lty=2)
lines(x2, y2, col=blindcolz[3], type="o", pch=18, lwd=2)
lines(x1, y1, col=blindcolz[7], type="o", pch=17, lwd=2)
if(i==1) {
plot(1, 1, type="n", xlab="", ylab="", axes=FALSE)
legend("center", c("Adult index", "Spawner model"), col=blindcolz[c(7, 3)], lwd=2, pch=c(17, 18))
}
}
mtext("Year", outer=TRUE, side=1, cex=outcex)
mtext("Adult abundance  (thousands)", outer=TRUE, side=2, cex=outcex)
}
figu("Patterns over time in adult sea lamprey abundance, comparing the newly derived index with the spawner model.",
"  Targets are indicated by dashed horizontal lines.",
"  Targets are based on averages from five years with historically acceptable wounding rates: ", paste(paste(targyrz, "in", Lakenames), collapse=", "), ".", 
newpage="port", w=6, h=7.5)
endrtf()
names(indices[[1]])
# "indfit"   "streamdf" "scaleup"  "indxdf"
# scale up
round(sapply(indices, "[[", 3), 2)
# 3.84 1.85 2.82 1.01 2.40
indxall[7:11, ]
   # year lake   indxraw n.mr  indxkeep indxkeep.lo indxkeep.hi
# 7  1986    1 24275.673    5 24275.673   18726.753   27579.203
# 8  1987    1 10994.483    5 10994.483   10269.609   11494.884
# 9  1988    1 13630.037    5 13630.037   11710.612   14680.398
# 10 1989    1 20227.926    6 20227.926   18704.166   21988.594
# 11 1990    1  9332.001    5  9332.001    8435.646   11991.514
# C:\JVA\Lamprey\Adults\AdultIndex\2014\AdultIndex v2.r
{ # functions
# the following seven plot.table related function are from the Systmatic Investor Toolbox
# load Systematic Investor Toolbox
# require(RCurl)
# sit = getURLContent("https://github.com/systematicinvestor/SIT/raw/master/sit.gz", binary=TRUE, followlocation=TRUE, ssl.verifypeer=FALSE)
# con = gzcon(rawConnection(sit, "rb"))
# source(con)
# close(con)
draw.cell <- function(title, r, c, text.cex = 1, bg.col = 'white', frame.cell = T) {
if(!frame.cell) bcol = bg.col else bcol = 'black'
rect((2*(c - 1) + .5), -(r - .5), (2*c + .5), -(r + .5), col = bg.col, border = bcol)
if( c == 1) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else if( r == 1 ) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else {
text((2*c + .5), -r, title, adj = 1, cex = text.cex)
}
}
plot.table.helper.auto.adjust.cex <- function(temp.table, keep.all.same.cex = FALSE) {
nr = nrow(temp.table)
nc = ncol(temp.table)
all.xrange = diff(par()$usr[1:2]) / nc
xrange = matrix( strwidth(paste('  ', temp.table), units = 'user', cex = 1), nc = nc)
all.yrange = diff(par()$usr[3:4]) / nr
yrange = matrix( 5/3 * strheight(temp.table, units = 'user', cex = 1), nc = nc)
plot.matrix.cex = pmin( round(all.yrange / yrange, 2) , round(all.xrange / xrange, 2) )
header.col.cex = min(plot.matrix.cex[1,-1])
header.row.cex = min(plot.matrix.cex[-1,1])
title.cex = plot.matrix.cex[1, 1]
data.cex = min(plot.matrix.cex[-1, -1])
if ( keep.all.same.cex ) {
plot.matrix.cex[] = min(plot.matrix.cex)
} else {
plot.matrix.cex[1,-1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,-1]= min(c(header.col.cex, header.row.cex, data.cex))
plot.matrix.cex[1,1]= min(c(header.col.cex, header.row.cex, data.cex, title.cex))
plot.matrix.cex[1,-1] = min(c(header.col.cex))
plot.matrix.cex[-1,1] = min(c(header.row.cex))
plot.matrix.cex[-1,-1]= min(c(data.cex))
plot.matrix.cex[1,1]= min(c(title.cex))
}
return(plot.matrix.cex)
}
make.table <- function(nr, nc) {
savepar = par(mar = rep(1, 4))
plot(c(0.5, nc*2 + 0.5), c(-0.5, -(nr + 0.5)), xaxs = 'i', yaxs = 'i',
type = 'n', xlab = '', ylab = '', axes = FALSE)
savepar
}
trim <- function(s) {
s = sub(pattern = '^ +', replacement = '', x = s)
s = sub(pattern = ' +$', replacement = '', x = s)
return(s)
}
plot.table.param <- function(plot.matrix, smain = '', plot.matrix.cex, plot.matrix_bg.col, frame.cell = T, keep.all.same.cex = FALSE) {
n = nrow(plot.matrix)
pages = unique(c(seq(0, n, by = 120), n))
for(p in 1:(length(pages)-1)) {
rindex = (pages[p]+1) : pages[p+1]
temp.table = matrix('', nr = length(rindex)+1, nc = ncol(plot.matrix)+1)
temp.table[-1, -1] = plot.matrix[rindex,]
temp.table[1, -1] = colnames(plot.matrix)
temp.table[-1, 1] = rownames(plot.matrix)[rindex]
temp.table[1, 1] = smain
nr = nrow(temp.table)
nc = ncol(temp.table)
par(mar = c(0, 0, 0, 0), cex = 0.5)
oldpar = make.table(nr, nc)
text.cex = plot.matrix.cex[c(1, 1 + rindex), ]
text.cex = plot.table.helper.auto.adjust.cex(temp.table, keep.all.same.cex)
bg.col = plot.matrix_bg.col[c(1, 1 + rindex), ]
for(r in 1:nr) {
for(c in 1:nc) {
draw.cell( paste('', temp.table[r,c], '', sep=' '), r, c,
text.cex = text.cex[r,c], bg.col = bg.col[r,c], frame.cell = frame.cell)
}}
}
}
plot.table <- function(plot.matrix, smain="", text.cex=1, frame.cell=TRUE, highlight=FALSE, colorbar=FALSE, keep_all.same.cex=FALSE) {
if( is.null(rownames(plot.matrix)) & is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
if( ncol(temp.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[-1, -1, drop = FALSE]
colnames(plot.matrix) = temp.matrix[1, -1]
rownames(plot.matrix) = temp.matrix[-1, 1]
smain = temp.matrix[1, 1]
} else if( is.null(rownames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( ncol(plot.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[, -1, drop = FALSE]
colnames(plot.matrix) = colnames(temp.matrix)[-1]
rownames(plot.matrix) = temp.matrix[,1]
smain = colnames(temp.matrix)[1]
} else if( is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
plot.matrix = temp.matrix[-1, , drop = FALSE]
rownames(plot.matrix) = rownames(temp.matrix)[-1]
colnames(plot.matrix) = temp.matrix[1, ]
smain = rownames(temp.matrix)[1]
}
plot.matrix[which(trim(plot.matrix) == "NA")] = ""
plot.matrix[which(trim(plot.matrix) == "NA%")] = ""
plot.matrix[which(is.na(plot.matrix))] = ""
nr = nrow(plot.matrix) + 1
nc = ncol(plot.matrix) + 1
is_highlight = TRUE
if(is.logical(highlight)) {
is_highlight = highlight
if(highlight) highlight = plot.table.helper.color(plot.matrix)
}
if(!is_highlight) {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[seq(1, nr, 2), ] = "yellow"
plot.matrix_bg.col[1,] = "gray";
plot.table.param( plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
} else {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[1,] = "gray"
plot.matrix_bg.col[2:nr,2:nc] = highlight
plot.table.param(plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
}
}
plot.table.helper.color <- function (temp) {
temp = matrix(as.double(gsub("[%,$]", "", temp)), nrow(temp), ncol(temp))
highlight = as.vector(temp)
cols = rep(NA, length(highlight))
ncols = length(highlight[!is.na(highlight)])
cols[1:ncols] = rev(rainbow(ncols, start=0.5/6, end=3.5/6))
o = sort.list(highlight, na.last = TRUE, decreasing = FALSE)
o1 = sort.list(o, na.last = TRUE, decreasing = FALSE)
highlight = matrix(cols[o1], nrow = nrow(temp))
highlight[is.na(temp)] = NA
return(highlight)
}
ModelEst <- function(fit, df) {
# derive regression estimates from log(y) fit
mse <- rev(as.matrix(summary(fit)[[1]])[, "Mean Sq"])[1]
plpe <- predict(fit, newdata=df, se.fit=T)
m <- plpe$fit
v <- plpe$se.fit^2 + mse
exp(m + v/2)
}
myrange <- function(x) {
if(all(is.na(x))) r <- c(NA, NA) else r <- range(x, na.rm=TRUE)
return(r)
}
jackindex <- function(m) {
# m is a matrix of numbers (stream PEs) with observations (years) as rows and individuals (streams) as columns
if(any(is.na(m))) stop("The input matrix may not have any missing values.")
# calculate the index as the sum of the columns for each row
rowsum <- apply(m, 1, sum)
# calculate the mean of the index
avgind <- mean(rowsum)
# recalculate the index, leaving out one individual at a time
loo <- apply(m, 2, function(column) (rowsum - column))
# rescale the loo index, relative to mean
looscaled <- apply(loo, 2, function(x) x/mean(x))
# convert to original scale
looscaled2 <- looscaled * avgind
# calculate range
ranges <- t(apply(looscaled2, 1, range))
cbind(index=rowsum, lo=ranges[, 1], hi=ranges[, 2])
}
# selstreams <- index.streams[[1]] 
# allstreamdf <- dat
# alllakedf <- lk 
# min.nmr=2 
# show=FALSE
index.est <- function(selstreams, allstreamdf, alllakedf, min.nmr=2, show=FALSE) {
# INDEX OF ADULT SEA LAMPREY ABUNDANCE
### INPUTS
# selstreams = vector of stream ids, e.g., 1.064 (lake + strcode/1000)
# allstreamdf = data frame of mark-recap estimates for all streams, with vars:  year lake ls Emr CVmr
# alllakedf = data frame of lake-wide PEs from Mullett et al. (2003) spawner model with vars:  lake year PE
# min.nmr = minimum number of mark-recapture estimates needed in a year to generate an index, default 2
# show = print out a brief summary of the results, default FALSE
### OUTPUTS
# indfit = simple model used to predict missing mark-recap estimates
# streamdf = original allstreamdf, subsetted by selstreams, with estimates for missing mark-recaps
# indxdf = original alllakedf, subsetted by lake, with annual index, including raw (indxraw), kept based on min.nmr (indxkeep, indxkeep.lo, indxkeep.hi)
# scaleup = conversion factor used to scale up annual index to spawner model PE
streamdf <- allstreamdf[allstreamdf$ls %in% selstreams, ]
# error checks
check1 <- var(streamdf$lake)
if(is.na(check1) | is.null(check1)) stop("Either no streams selected or critical data missing.") else if(check1 > 0) stop("Selected streams should be only from ONE lake.")
if(any(is.na(match(c("year", "lake", "ls", "Emr", "CVmr"), names(allstreamdf))))) stop("allstreamdf must include these variables: year lake ls Emr CVmr.")
if(any(is.na(match(c("year", "lake", "PE"), names(alllakedf))))) stop("alllakedf must include these variables: lake year PE.")
# fill in missing mark-recap data
indfit <- aov(log(Emr) ~ as.factor(ls) + as.factor(year), data=streamdf, weights=1/CVmr^2)
# figure out estimable years (those with at least 1 m-r estimate)
n.mr <- tapply(!is.na(streamdf$Emr), streamdf$year, sum)
eyrs <- as.numeric(names(n.mr)[n.mr > 0.5])
estimable <- streamdf$year %in% eyrs
streamdf$Pmr <- NA
streamdf$Pmr[estimable] <- ModelEst(fit=indfit, df=streamdf[estimable, ])
streamdf$COMBmr <- ifelse(is.na(streamdf$Emr), streamdf$Pmr, streamdf$Emr)
# annual index (sum across streams)
indxdf <- aggregate(COMBmr ~ year + lake, streamdf, sum, na.rm=TRUE, na.action=na.pass)
names(indxdf)[names(indxdf)=="COMBmr"] <- "indxraw"
indxdf$indxraw[indxdf$indxraw==0] <- NA
# only keep lake-wide index for years with at least min.nmr mark-recap estimates
indxdf$n.mr <- n.mr
indxdf$indxkeep <- ifelse(indxdf$n.mr > (min.nmr - 0.5), indxdf$indxraw, NA)
indxdf$indxkeep.lo <- NA
indxdf$indxkeep.hi <- NA
# matrix of stream estimates (rows = years, columns = index streams)
streamests <- with(streamdf, tapply(COMBmr, list(year, ls), mean))
# selection of only those streams with a keepable index
selkeep <- !is.na(indxdf$indxkeep)
jack <- jackindex(streamests[selkeep, ])
indxdf$indxkeep.lo[selkeep] <- jack[, "lo"]
indxdf$indxkeep.hi[selkeep] <- jack[, "hi"]
# scale up the index to the spawner model PE
lk1 <- lk[lk$lake == streamdf$lake[1], ]
indxdf2 <- merge(lk1, indxdf, all=TRUE)
scaleup <- median(indxdf2$PE / indxdf2$indxkeep, na.rm=TRUE)
if(show) {
cat("\nindfit\n")
print(summary(indfit))
cat("\nstreamdf\n")
print(tail(streamdf[, c("lake", "year", "ls", "Emr", "CVmr", "Pmr", "COMBmr")]))
cat("\nscaleup\n")
print(scaleup)
cat("\nindxdf\n")
print(tail(indxdf[, c("lake", "year", "n.mr", "indxraw", "indxkeep", "indxkeep.lo", "indxkeep.hi")]))
}
list(indfit=indfit, streamdf=streamdf, scaleup=scaleup, indxdf=indxdf)
}
calctarg <- function(lakenum, adults, year, targyears, adjust=c(1, 1, 0.25, 1, 1)) {
# lakenum = vector of lake numbers (1-5)
# adults = vector of lakewide adult sea lamprey estimates
# year = vector of years
# targyears = list (length 5) of selected years from which to calculate targets
# lake huron target is 25% of
targets <- data.frame(lake=1:5, target=rep(NA, 5), lo=rep(NA, 5), hi=rep(NA, 5))
for(i in 1:5) {
pick5 <- adults[lakenum==i & is.element(year, targyears[[i]]) & !is.na(adults)]
if(length(pick5) > 0) {
targets$target[i] <- mean(pick5)
n <- length(pick5)
ci <- qnorm(1 - 0.05/2) * sqrt(var(pick5)) / sqrt(n)
targets[i, c("lo", "hi")] <- mean(pick5) + c(-1, 1)*ci# using z dist (known variance)
targets[i, c("target", "lo", "hi")] <- adjust[i]*targets[i, c("target", "lo", "hi")]
} else {
targets[i, c("target", "lo", "hi")] <- c(NA, NA, NA)
}
}
targets
}
}
# bring in lake-wide spawner data
lk <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/LakePEdynamic.csv", as.is=T)
# bring in stream-specific data
dat <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/StreamPEdynamicALLCOLS.csv", as.is=T)
dat$ls <- dat$lscode
# 2014-04-09 Jess and Gale agreed that the East Au Gres (38) should be replaced with the Au Sable (36) in Lake Huron
# 2014-04-10 Jess thinks that we should just stick with the East Au Gres (38)
index.streams <- list(
Sup = c(1, 2, 9, 29, 31, 32, 62),
Mic = c(5, 6, 15, 24, 26, 35),
Hur = c(10, 16, 27, 32, 999, 38),
Eri = c(1, 2, 3, 7, 9),
Ont = c(5, 9, 22, 23, 36)
)
index.streams <- lapply(1:5, function(i) i + index.streams[[i]]/1000)
# estimate adult index of abundance for each lake using index streams
indices <- lapply(index.streams, index.est, dat, lk)
# combine index data for all lakes in one dataframe
indxall <- do.call(rbind, lapply(indices, "[[", "indxdf"))
# calculate targets 
sptargyrz <- list(1994:1998, 1988:1992, 1989:1993, 1991:1995, 1999:2003)
targyrz <- apply(sapply(sptargyrz, range), 2, paste, collapse="-")
# spawner model
targets.sm <- calctarg(lakenum=lk$lake, adults=lk$PE, year=lk$year, targyears=sptargyrz)
# adult index
targets.ai <- calctarg(lakenum=indxall$lake, adults=indxall$indxkeep, year=indxall$year, targyears=sptargyrz)
# spawner model targets scaled down to adult index
targets.sm.su <- cbind(lake=targets.sm[, 1], (1/sapply(indices, "[[", "scaleup")) * targets.sm[, -1])
# adult index adjusted
targets.ai.adj <- targets.ai
targets.ai.adj[is.na(targets.ai$target), ] <- targets.sm.su[is.na(targets.ai$target), ]
YEAR1 <- 1984
# create a Word document with results
doc <- startrtf(file="2014-10 SLCB Index", dir="C:/JVA/Lamprey/Adults/AdultIndex/2014", omi=c(1, 1.25, 1, 1.25))
heading("Index of Adult Sea Lamprey Abundance in each Great Lake")
heading(paste("Adams, Barber, Bravener, Steeves -", as.character(Sys.Date())), htype=2)
### Spawner model time series
heading("Purpose of the index", htype=3)
heading("Selection of index streams", htype=3)
heading("Calculation of index", htype=3)
heading("Assumptions", htype=3)
heading("Fate of current spawner model", htype=3)
para("Conversion factors: ", paste(Lakenames, round(sapply(indices, "[[", "scaleup"), 2), collapse=", "), ".")
# position of text for selected streams in each lake (for map drawing)
posp <- list(c(3, 1, 3, 1, 1, 3, 1),
c(2, 2, 2, 2, 2, 2),
c(4, 4, 4, 4, 4, 4),
c(2, 4, 2, 4, 3),
c(2, 2, 3, 2, 2, 2))
### map of selected streams
col5 <- c("#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00")
mymap <- map5
fig <- function() {
par(mar=c(0, 0, 0, 0))
map(xlim=range(mymap$x, na.rm=T), ylim=range(mymap$y, na.rm=T), col=NA, mar=rep(1, 4))
lines(mymap$x, mymap$y, col="darkgray", lwd=0.5)
for(i in 1:5) {
mystreamdf <- indices[[i]]$streamdf
with(mystreamdf[mystreamdf$year==2010, ], {
points(long, lat, cex=1.5, pch=16, col=col5[i])
par(xpd=NA)
text(long, lat, strname, cex=1.2, pos=posp[[i]], col=col5[i])
print(strname)
})
}
}
figu("Streams selected for inclusion in the index of adult sea lamprey abundance.", newpage="land", w=9, h=5.7)
outcex <- 1.2
YEARb <- 1995
### bar plot of individual index stream PEs
col7 <- c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69")
fig <- function() {
par(mar=c(2.5, 2.5, 1, 1), mfrow=c(3, 2), yaxs="i", oma=c(1.5, 1.5, 0, 0), cex=1.2)
for(i in 1:5) {
mymap <- mapL[[i]]
mystreamdf <- indices[[i]]$streamdf
myindxdf <- indices[[i]]$indxdf
mystreamdf <- mystreamdf[mystreamdf$year >= YEARb, ]
myindxdf <- myindxdf[myindxdf$year >= YEARb, ]
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p[is.na(myindxdf$indxkeep), ] <- NA
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
a <- barplot(t(p)/1000, las=1, col=col7, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.03*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="", ylab="", main=Lakenames[i], border=NA)
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2, las=1)
box()
legend("topleft", rev(colnames(p)), fill=rev(col7[1:dim(p)[2]]), cex=0.5, bty="n", border=NA)
if(i==1) {
frame()
}
}
mtext("Year", outer=TRUE, side=1, cex=outcex)
mtext("Adult abundance  (thousands)", outer=TRUE, side=2, cex=outcex)
}
figu("Adult sea lamprey abundance estimates for index streams.", newpage="port", w=6, h=7.5)
### spawner model and adult index time series overlaid
fig <- function() {
par(mfrow=c(3, 2), mar=c(3, 3, 1, 3), oma=c(1.5, 1.5, 0, 0), cex=1.2, yaxs="i")
for(i in 1:5) {
mylk <- lk[lk$lake==i, ]# lake year PE lo hi
myindxdf <- indices[[i]]$indxdf# year lake indxraw n.mr indxkeep indxkeep.lo indxkeep.hi
convfac <- indices[[i]]$scaleup
x1 <- myindxdf$year
y1 <- myindxdf$indxkeep/1000
x2 <- mylk$year
y2 <- mylk$PE/convfac/1000
yr <- 1.05*range(0, y1, y2[x2>=YEAR1], na.rm=TRUE)
plot(1, 1, type="n", xlim=range(lk$year), ylim=yr, xlab="", ylab="", main=Lakenames[i], axes=FALSE)
axis(1)
axis(2, col=blindcolz[7], col.axis=blindcolz[7], las=1)
par(mgp=c(3, 2.2, 0))
axis(4, at=pretty(convfac*yr)/convfac, labels=pretty(convfac*yr), col=blindcolz[3], col.axis=blindcolz[3], las=1, hadj=1)
par(mgp=c(3, 1, 0))
box()
abline(h=targets.sm$target[i]/convfac/1000, col=blindcolz[3], lty=2)
abline(h=targets.ai.adj$target[i]/1000, col=blindcolz[7], lty=2)
lines(x2, y2, col=blindcolz[3], type="o", pch=18, lwd=2)
lines(x1, y1, col=blindcolz[7], type="o", pch=17, lwd=2)
if(i==1) {
plot(1, 1, type="n", xlab="", ylab="", axes=FALSE)
legend("center", c("Adult index", "Spawner model"), col=blindcolz[c(7, 3)], lwd=2, pch=c(17, 18))
}
}
mtext("Year", outer=TRUE, side=1, cex=outcex)
mtext("Adult abundance  (thousands)", outer=TRUE, side=2, cex=outcex)
}
figu("Patterns over time in adult sea lamprey abundance, comparing the newly derived index with the spawner model.",
"  Targets are indicated by dashed horizontal lines.",
"  Targets are based on averages from five years with historically acceptable wounding rates: ", paste(paste(targyrz, "in", Lakenames), collapse=", "), ".", 
newpage="port", w=6, h=7.5)
endrtf()
names(indices[[1]])
# "indfit"   "streamdf" "scaleup"  "indxdf"
# scale up
round(sapply(indices, "[[", 3), 2)
# 3.84 1.85 2.82 1.01 2.40
indxall[7:11, ]
   # year lake   indxraw n.mr  indxkeep indxkeep.lo indxkeep.hi
# 7  1986    1 24275.673    5 24275.673   18726.753   27579.203
# 8  1987    1 10994.483    5 10994.483   10269.609   11494.884
# 9  1988    1 13630.037    5 13630.037   11710.612   14680.398
# 10 1989    1 20227.926    6 20227.926   18704.166   21988.594
# 11 1990    1  9332.001    5  9332.001    8435.646   11991.514
# C:\JVA\Lamprey\Adults\AdultIndex\2014\AdultIndex v2.r
{ # functions
# the following seven plot.table related function are from the Systmatic Investor Toolbox
# load Systematic Investor Toolbox
# require(RCurl)
# sit = getURLContent("https://github.com/systematicinvestor/SIT/raw/master/sit.gz", binary=TRUE, followlocation=TRUE, ssl.verifypeer=FALSE)
# con = gzcon(rawConnection(sit, "rb"))
# source(con)
# close(con)
draw.cell <- function(title, r, c, text.cex = 1, bg.col = 'white', frame.cell = T) {
if(!frame.cell) bcol = bg.col else bcol = 'black'
rect((2*(c - 1) + .5), -(r - .5), (2*c + .5), -(r + .5), col = bg.col, border = bcol)
if( c == 1) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else if( r == 1 ) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else {
text((2*c + .5), -r, title, adj = 1, cex = text.cex)
}
}
plot.table.helper.auto.adjust.cex <- function(temp.table, keep.all.same.cex = FALSE) {
nr = nrow(temp.table)
nc = ncol(temp.table)
all.xrange = diff(par()$usr[1:2]) / nc
xrange = matrix( strwidth(paste('  ', temp.table), units = 'user', cex = 1), nc = nc)
all.yrange = diff(par()$usr[3:4]) / nr
yrange = matrix( 5/3 * strheight(temp.table, units = 'user', cex = 1), nc = nc)
plot.matrix.cex = pmin( round(all.yrange / yrange, 2) , round(all.xrange / xrange, 2) )
header.col.cex = min(plot.matrix.cex[1,-1])
header.row.cex = min(plot.matrix.cex[-1,1])
title.cex = plot.matrix.cex[1, 1]
data.cex = min(plot.matrix.cex[-1, -1])
if ( keep.all.same.cex ) {
plot.matrix.cex[] = min(plot.matrix.cex)
} else {
plot.matrix.cex[1,-1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,-1]= min(c(header.col.cex, header.row.cex, data.cex))
plot.matrix.cex[1,1]= min(c(header.col.cex, header.row.cex, data.cex, title.cex))
plot.matrix.cex[1,-1] = min(c(header.col.cex))
plot.matrix.cex[-1,1] = min(c(header.row.cex))
plot.matrix.cex[-1,-1]= min(c(data.cex))
plot.matrix.cex[1,1]= min(c(title.cex))
}
return(plot.matrix.cex)
}
make.table <- function(nr, nc) {
savepar = par(mar = rep(1, 4))
plot(c(0.5, nc*2 + 0.5), c(-0.5, -(nr + 0.5)), xaxs = 'i', yaxs = 'i',
type = 'n', xlab = '', ylab = '', axes = FALSE)
savepar
}
trim <- function(s) {
s = sub(pattern = '^ +', replacement = '', x = s)
s = sub(pattern = ' +$', replacement = '', x = s)
return(s)
}
plot.table.param <- function(plot.matrix, smain = '', plot.matrix.cex, plot.matrix_bg.col, frame.cell = T, keep.all.same.cex = FALSE) {
n = nrow(plot.matrix)
pages = unique(c(seq(0, n, by = 120), n))
for(p in 1:(length(pages)-1)) {
rindex = (pages[p]+1) : pages[p+1]
temp.table = matrix('', nr = length(rindex)+1, nc = ncol(plot.matrix)+1)
temp.table[-1, -1] = plot.matrix[rindex,]
temp.table[1, -1] = colnames(plot.matrix)
temp.table[-1, 1] = rownames(plot.matrix)[rindex]
temp.table[1, 1] = smain
nr = nrow(temp.table)
nc = ncol(temp.table)
par(mar = c(0, 0, 0, 0), cex = 0.5)
oldpar = make.table(nr, nc)
text.cex = plot.matrix.cex[c(1, 1 + rindex), ]
text.cex = plot.table.helper.auto.adjust.cex(temp.table, keep.all.same.cex)
bg.col = plot.matrix_bg.col[c(1, 1 + rindex), ]
for(r in 1:nr) {
for(c in 1:nc) {
draw.cell( paste('', temp.table[r,c], '', sep=' '), r, c,
text.cex = text.cex[r,c], bg.col = bg.col[r,c], frame.cell = frame.cell)
}}
}
}
plot.table <- function(plot.matrix, smain="", text.cex=1, frame.cell=TRUE, highlight=FALSE, colorbar=FALSE, keep_all.same.cex=FALSE) {
if( is.null(rownames(plot.matrix)) & is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
if( ncol(temp.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[-1, -1, drop = FALSE]
colnames(plot.matrix) = temp.matrix[1, -1]
rownames(plot.matrix) = temp.matrix[-1, 1]
smain = temp.matrix[1, 1]
} else if( is.null(rownames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( ncol(plot.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[, -1, drop = FALSE]
colnames(plot.matrix) = colnames(temp.matrix)[-1]
rownames(plot.matrix) = temp.matrix[,1]
smain = colnames(temp.matrix)[1]
} else if( is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
plot.matrix = temp.matrix[-1, , drop = FALSE]
rownames(plot.matrix) = rownames(temp.matrix)[-1]
colnames(plot.matrix) = temp.matrix[1, ]
smain = rownames(temp.matrix)[1]
}
plot.matrix[which(trim(plot.matrix) == "NA")] = ""
plot.matrix[which(trim(plot.matrix) == "NA%")] = ""
plot.matrix[which(is.na(plot.matrix))] = ""
nr = nrow(plot.matrix) + 1
nc = ncol(plot.matrix) + 1
is_highlight = TRUE
if(is.logical(highlight)) {
is_highlight = highlight
if(highlight) highlight = plot.table.helper.color(plot.matrix)
}
if(!is_highlight) {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[seq(1, nr, 2), ] = "yellow"
plot.matrix_bg.col[1,] = "gray";
plot.table.param( plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
} else {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[1,] = "gray"
plot.matrix_bg.col[2:nr,2:nc] = highlight
plot.table.param(plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
}
}
plot.table.helper.color <- function (temp) {
temp = matrix(as.double(gsub("[%,$]", "", temp)), nrow(temp), ncol(temp))
highlight = as.vector(temp)
cols = rep(NA, length(highlight))
ncols = length(highlight[!is.na(highlight)])
cols[1:ncols] = rev(rainbow(ncols, start=0.5/6, end=3.5/6))
o = sort.list(highlight, na.last = TRUE, decreasing = FALSE)
o1 = sort.list(o, na.last = TRUE, decreasing = FALSE)
highlight = matrix(cols[o1], nrow = nrow(temp))
highlight[is.na(temp)] = NA
return(highlight)
}
ModelEst <- function(fit, df) {
# derive regression estimates from log(y) fit
mse <- rev(as.matrix(summary(fit)[[1]])[, "Mean Sq"])[1]
plpe <- predict(fit, newdata=df, se.fit=T)
m <- plpe$fit
v <- plpe$se.fit^2 + mse
exp(m + v/2)
}
myrange <- function(x) {
if(all(is.na(x))) r <- c(NA, NA) else r <- range(x, na.rm=TRUE)
return(r)
}
jackindex <- function(m) {
# m is a matrix of numbers (stream PEs) with observations (years) as rows and individuals (streams) as columns
if(any(is.na(m))) stop("The input matrix may not have any missing values.")
# calculate the index as the sum of the columns for each row
rowsum <- apply(m, 1, sum)
# calculate the mean of the index
avgind <- mean(rowsum)
# recalculate the index, leaving out one individual at a time
loo <- apply(m, 2, function(column) (rowsum - column))
# rescale the loo index, relative to mean
looscaled <- apply(loo, 2, function(x) x/mean(x))
# convert to original scale
looscaled2 <- looscaled * avgind
# calculate range
ranges <- t(apply(looscaled2, 1, range))
cbind(index=rowsum, lo=ranges[, 1], hi=ranges[, 2])
}
# selstreams <- index.streams[[1]] 
# allstreamdf <- dat
# alllakedf <- lk 
# min.nmr=2 
# show=FALSE
index.est <- function(selstreams, allstreamdf, alllakedf, min.nmr=2, show=FALSE) {
# INDEX OF ADULT SEA LAMPREY ABUNDANCE
### INPUTS
# selstreams = vector of stream ids, e.g., 1.064 (lake + strcode/1000)
# allstreamdf = data frame of mark-recap estimates for all streams, with vars:  year lake ls Emr CVmr
# alllakedf = data frame of lake-wide PEs from Mullett et al. (2003) spawner model with vars:  lake year PE
# min.nmr = minimum number of mark-recapture estimates needed in a year to generate an index, default 2
# show = print out a brief summary of the results, default FALSE
### OUTPUTS
# indfit = simple model used to predict missing mark-recap estimates
# streamdf = original allstreamdf, subsetted by selstreams, with estimates for missing mark-recaps
# indxdf = original alllakedf, subsetted by lake, with annual index, including raw (indxraw), kept based on min.nmr (indxkeep, indxkeep.lo, indxkeep.hi)
# scaleup = conversion factor used to scale up annual index to spawner model PE
streamdf <- allstreamdf[allstreamdf$ls %in% selstreams, ]
# error checks
check1 <- var(streamdf$lake)
if(is.na(check1) | is.null(check1)) stop("Either no streams selected or critical data missing.") else if(check1 > 0) stop("Selected streams should be only from ONE lake.")
if(any(is.na(match(c("year", "lake", "ls", "Emr", "CVmr"), names(allstreamdf))))) stop("allstreamdf must include these variables: year lake ls Emr CVmr.")
if(any(is.na(match(c("year", "lake", "PE"), names(alllakedf))))) stop("alllakedf must include these variables: lake year PE.")
# fill in missing mark-recap data
indfit <- aov(log(Emr) ~ as.factor(ls) + as.factor(year), data=streamdf, weights=1/CVmr^2)
# figure out estimable years (those with at least 1 m-r estimate)
n.mr <- tapply(!is.na(streamdf$Emr), streamdf$year, sum)
eyrs <- as.numeric(names(n.mr)[n.mr > 0.5])
estimable <- streamdf$year %in% eyrs
streamdf$Pmr <- NA
streamdf$Pmr[estimable] <- ModelEst(fit=indfit, df=streamdf[estimable, ])
streamdf$COMBmr <- ifelse(is.na(streamdf$Emr), streamdf$Pmr, streamdf$Emr)
# annual index (sum across streams)
indxdf <- aggregate(COMBmr ~ year + lake, streamdf, sum, na.rm=TRUE, na.action=na.pass)
names(indxdf)[names(indxdf)=="COMBmr"] <- "indxraw"
indxdf$indxraw[indxdf$indxraw==0] <- NA
# only keep lake-wide index for years with at least min.nmr mark-recap estimates
indxdf$n.mr <- n.mr
indxdf$indxkeep <- ifelse(indxdf$n.mr > (min.nmr - 0.5), indxdf$indxraw, NA)
indxdf$indxkeep.lo <- NA
indxdf$indxkeep.hi <- NA
# matrix of stream estimates (rows = years, columns = index streams)
streamests <- with(streamdf, tapply(COMBmr, list(year, ls), mean))
# selection of only those streams with a keepable index
selkeep <- !is.na(indxdf$indxkeep)
jack <- jackindex(streamests[selkeep, ])
indxdf$indxkeep.lo[selkeep] <- jack[, "lo"]
indxdf$indxkeep.hi[selkeep] <- jack[, "hi"]
# scale up the index to the spawner model PE
lk1 <- lk[lk$lake == streamdf$lake[1], ]
indxdf2 <- merge(lk1, indxdf, all=TRUE)
scaleup <- median(indxdf2$PE / indxdf2$indxkeep, na.rm=TRUE)
if(show) {
cat("\nindfit\n")
print(summary(indfit))
cat("\nstreamdf\n")
print(tail(streamdf[, c("lake", "year", "ls", "Emr", "CVmr", "Pmr", "COMBmr")]))
cat("\nscaleup\n")
print(scaleup)
cat("\nindxdf\n")
print(tail(indxdf[, c("lake", "year", "n.mr", "indxraw", "indxkeep", "indxkeep.lo", "indxkeep.hi")]))
}
list(indfit=indfit, streamdf=streamdf, scaleup=scaleup, indxdf=indxdf)
}
calctarg <- function(lakenum, adults, year, targyears, adjust=c(1, 1, 0.25, 1, 1)) {
# lakenum = vector of lake numbers (1-5)
# adults = vector of lakewide adult sea lamprey estimates
# year = vector of years
# targyears = list (length 5) of selected years from which to calculate targets
# lake huron target is 25% of
targets <- data.frame(lake=1:5, target=rep(NA, 5), lo=rep(NA, 5), hi=rep(NA, 5))
for(i in 1:5) {
pick5 <- adults[lakenum==i & is.element(year, targyears[[i]]) & !is.na(adults)]
if(length(pick5) > 0) {
targets$target[i] <- mean(pick5)
n <- length(pick5)
ci <- qnorm(1 - 0.05/2) * sqrt(var(pick5)) / sqrt(n)
targets[i, c("lo", "hi")] <- mean(pick5) + c(-1, 1)*ci# using z dist (known variance)
targets[i, c("target", "lo", "hi")] <- adjust[i]*targets[i, c("target", "lo", "hi")]
} else {
targets[i, c("target", "lo", "hi")] <- c(NA, NA, NA)
}
}
targets
}
}
# bring in lake-wide spawner data
lk <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/LakePEdynamic.csv", as.is=T)
# bring in stream-specific data
dat <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/StreamPEdynamicALLCOLS.csv", as.is=T)
dat$ls <- dat$lscode
# 2014-04-09 Jess and Gale agreed that the East Au Gres (38) should be replaced with the Au Sable (36) in Lake Huron
# 2014-04-10 Jess thinks that we should just stick with the East Au Gres (38)
index.streams <- list(
Sup = c(1, 2, 9, 29, 31, 32, 62),
Mic = c(5, 6, 15, 24, 26, 35),
Hur = c(10, 16, 27, 32, 999, 38),
Eri = c(1, 2, 3, 7, 9),
Ont = c(5, 9, 22, 23, 36)
)
index.streams <- lapply(1:5, function(i) i + index.streams[[i]]/1000)
# estimate adult index of abundance for each lake using index streams
indices <- lapply(index.streams, index.est, dat, lk)
# combine index data for all lakes in one dataframe
indxall <- do.call(rbind, lapply(indices, "[[", "indxdf"))
# calculate targets 
sptargyrz <- list(1994:1998, 1988:1992, 1989:1993, 1991:1995, 1999:2003)
targyrz <- apply(sapply(sptargyrz, range), 2, paste, collapse="-")
# spawner model
targets.sm <- calctarg(lakenum=lk$lake, adults=lk$PE, year=lk$year, targyears=sptargyrz)
# adult index
targets.ai <- calctarg(lakenum=indxall$lake, adults=indxall$indxkeep, year=indxall$year, targyears=sptargyrz)
# spawner model targets scaled down to adult index
targets.sm.su <- cbind(lake=targets.sm[, 1], (1/sapply(indices, "[[", "scaleup")) * targets.sm[, -1])
# adult index adjusted
targets.ai.adj <- targets.ai
targets.ai.adj[is.na(targets.ai$target), ] <- targets.sm.su[is.na(targets.ai$target), ]
YEAR1 <- 1984
# create a Word document with results
doc <- startrtf(file="2014-10 SLCB Index", dir="C:/JVA/Lamprey/Adults/AdultIndex/2014", omi=c(1, 1.25, 1, 1.25))
heading("Index of Adult Sea Lamprey Abundance in each Great Lake")
heading(paste("Adams, Barber, Bravener, Steeves -", as.character(Sys.Date())), htype=2)
para("Conversion factors: ", paste(Lakenames, round(sapply(indices, "[[", "scaleup"), 2), collapse=", "), ".")
# position of text for selected streams in each lake (for map drawing)
posp <- list(c(3, 1, 3, 1, 1, 3, 1),
c(2, 2, 2, 2, 2, 2),
c(4, 4, 4, 4, 4, 4),
c(2, 4, 3, 4, 4),
c(2, 2, 3, 2, 2, 2))
### map of selected streams
col5 <- c("#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00")
mymap <- map5
fig <- function() {
par(mar=c(0, 0, 0, 0))
map(xlim=range(mymap$x, na.rm=T), ylim=range(mymap$y, na.rm=T), col=NA, mar=rep(1, 4))
lines(mymap$x, mymap$y, col="darkgray", lwd=0.5)
for(i in 1:5) {
mystreamdf <- indices[[i]]$streamdf
with(mystreamdf[mystreamdf$year==2010, ], {
points(long, lat, cex=1.5, pch=16, col=col5[i])
par(xpd=NA)
text(long, lat, strname, cex=1.2, pos=posp[[i]], col=col5[i])
print(strname)
})
}
}
figu("Streams selected for inclusion in the index of adult sea lamprey abundance.", newpage="land", w=9, h=5.7)
outcex <- 1.2
YEARb <- 1995
### bar plot of individual index stream PEs
col7 <- c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69")
fig <- function() {
par(mar=c(2.5, 2.5, 1, 1), mfrow=c(3, 2), yaxs="i", oma=c(1.5, 1.5, 0, 0), cex=1.2)
for(i in 1:5) {
mymap <- mapL[[i]]
mystreamdf <- indices[[i]]$streamdf
myindxdf <- indices[[i]]$indxdf
mystreamdf <- mystreamdf[mystreamdf$year >= YEARb, ]
myindxdf <- myindxdf[myindxdf$year >= YEARb, ]
p <- with(mystreamdf, tapply(COMBmr, list(year, substring(strname, 1, 10)), mean))
p[is.na(myindxdf$indxkeep), ] <- NA
p <- p[, rev(order(apply(p, 2, median, na.rm=TRUE)))]
yrz <- as.numeric(dimnames(p)[[1]])
pyrz <- pretty(yrz)
a <- barplot(t(p)/1000, las=1, col=col7, axes=FALSE, names.arg=rep("", dim(p)[1]), ylim=1.03*c(0, max(apply(p, 1, sum, na.rm=TRUE)))/1000, 
xlab="", ylab="", main=Lakenames[i], border=NA)
axis(1, at=a[match(pyrz, yrz)], pyrz)
axis(2, las=1)
box()
legend("topleft", rev(colnames(p)), fill=rev(col7[1:dim(p)[2]]), cex=0.5, bty="n", border=NA)
if(i==1) {
frame()
}
}
mtext("Year", outer=TRUE, side=1, cex=outcex)
mtext("Adult abundance  (thousands)", outer=TRUE, side=2, cex=outcex)
}
figu("Adult sea lamprey abundance estimates for index streams.", newpage="port", w=6, h=7.5)
### spawner model and adult index time series overlaid
fig <- function() {
par(mfrow=c(3, 2), mar=c(3, 3, 1, 3), oma=c(1.5, 1.5, 0, 0), cex=1.2, yaxs="i")
for(i in 1:5) {
mylk <- lk[lk$lake==i, ]# lake year PE lo hi
myindxdf <- indices[[i]]$indxdf# year lake indxraw n.mr indxkeep indxkeep.lo indxkeep.hi
convfac <- indices[[i]]$scaleup
x1 <- myindxdf$year
y1 <- myindxdf$indxkeep/1000
x2 <- mylk$year
y2 <- mylk$PE/convfac/1000
yr <- 1.05*range(0, y1, y2[x2>=YEAR1], na.rm=TRUE)
plot(1, 1, type="n", xlim=range(lk$year), ylim=yr, xlab="", ylab="", main=Lakenames[i], axes=FALSE)
axis(1)
axis(2, col=blindcolz[7], col.axis=blindcolz[7], las=1)
par(mgp=c(3, 2.2, 0))
axis(4, at=pretty(convfac*yr)/convfac, labels=pretty(convfac*yr), col=blindcolz[3], col.axis=blindcolz[3], las=1, hadj=1)
par(mgp=c(3, 1, 0))
box()
abline(h=targets.sm$target[i]/convfac/1000, col=blindcolz[3], lty=2)
abline(h=targets.ai.adj$target[i]/1000, col=blindcolz[7], lty=2)
lines(x2, y2, col=blindcolz[3], type="o", pch=18, lwd=2)
lines(x1, y1, col=blindcolz[7], type="o", pch=17, lwd=2)
if(i==1) {
plot(1, 1, type="n", xlab="", ylab="", axes=FALSE)
legend("center", c("Adult index", "Spawner model"), col=blindcolz[c(7, 3)], lwd=2, pch=c(17, 18))
}
}
mtext("Year", outer=TRUE, side=1, cex=outcex)
mtext("Adult abundance  (thousands)", outer=TRUE, side=2, cex=outcex)
}
figu("Patterns over time in adult sea lamprey abundance, comparing the newly derived index with the spawner model.",
"  Targets are indicated by dashed horizontal lines.",
"  Targets are based on averages from five years with historically acceptable wounding rates: ", paste(paste(targyrz, "in", Lakenames), collapse=", "), ".", 
newpage="port", w=6, h=7.5)
endrtf()
names(indices[[1]])
# "indfit"   "streamdf" "scaleup"  "indxdf"
# scale up
round(sapply(indices, "[[", 3), 2)
# 3.84 1.85 2.82 1.01 2.40
indxall[7:11, ]
   # year lake   indxraw n.mr  indxkeep indxkeep.lo indxkeep.hi
# 7  1986    1 24275.673    5 24275.673   18726.753   27579.203
# 8  1987    1 10994.483    5 10994.483   10269.609   11494.884
# 9  1988    1 13630.037    5 13630.037   11710.612   14680.398
# 10 1989    1 20227.926    6 20227.926   18704.166   21988.594
# 11 1990    1  9332.001    5  9332.001    8435.646   11991.514
cleanup()
q()
rmse <- c(7.9, 16.5, 13.3)
r2 <- c(.65, .18, .48)
plot(rmse, r2)
cor.test(rmse, r2)
q()
cor.test
# C:\JVA\Consult\Stapanian\AmphibSens\Three Group Approach.r
# Find the best predictive model of the following three responses
# 1. number of sensitive species (x.ssp) 
# 2. % sensitive species (x.sen)
# 3. % tolerant species (x.ol)
# using as independent variables the 6 ORAM metrics, OVIBI score, and the 10 LDI metrics.
# needed functions
select.varz <- function(resname, indnames, mydat, max.no.ind.var, print=TRUE) {
# keep only those indnames that have at least two unique non-missing values
indnames <- indnames[apply(mydat[, indnames], 2, function(x) {
y <- var(x[!is.na(x)])
!is.na(y) & y>0
})]
m <- allcombs(length(indnames), 0, max.no.ind.var)
dimnames(m)[[2]] <- indnames
# right side of the formula
rightside <- apply(m, 1, function(row) paste(indnames[row==1], collapse=" + "))
# if no predictors, use 1 to represent intercept only model
rightside[rightside==""] <- "1"
form <- paste(resname, rightside, sep=" ~ ")
fits <- lapply(form, function(f) lm(formula(f), dat=mydat))
# AIC table
aictab <- AICc(fits)
bigtab <- cbind(formula=rightside[aictab$model], aictab)
nmodzfit <- dim(bigtab)[1]
# top models
topmods <- bigtab[bigtab$daicc < 2, ]
# add coefficients to top model
coef <- lapply(fits[topmods$model], coef)
xmod <- unique(unlist(lapply(coef, names)))
topcoef <- t(sapply(coef, function(x) 
{
blank <- rep(0, length(xmod))
blank[match(names(x), xmod)] <- x
blank
}))
dimnames(topcoef)[[2]] <- xmod
topmods <- cbind(signif(topcoef, 3), round(topmods[, c("n", "p", "rmse", "aicc", "daicc", "aiccw")], 2))
# single best model
bestnum <- bigtab$model[1]
bestfit <- fits[[bestnum]]
xvarz <- indnames[m[bestnum, ]==1]
# output
out <- list(yvar=resname, xvarz=xvarz, nmodzfit=nmodzfit, bestfit=bestfit, topmods=topmods, allfits=fits, allmods=bigtab, allpreds=m)
if(print) print(out[1:4])
out
}
assess.fit <- function(resname, fit, newd) {
p <- predict(fit, newdata=newd)
y <- newd[, resname]
r <- p - y
rmse <- sqrt(mean(r^2))
    r2 <- 1 - sum(r^2)/sum((y - mean(y))^2)
list(cbind(p=p, y=y, r=r), rmse=rmse, r2=r2)
}
# bring in data
wb <- loadWorkbook("C:/JVA/Consult/Stapanian/AmphibSens/amphibians_16JAN 2014.xlsx")
dat <- readWorksheet(wb, sheet="Jean2")
names(dat) <- make.names(casefold(names(dat)), unique=T, allow_=F)
info <- readWorksheet(wb, sheet="Jean")
names(info) <- make.names(casefold(names(info)), unique=T, allow_=F)
all.equal(info$site.code, dat$site.code)
dat$lat.dd <- info$lat.dd
dat$lon.dd <- info$lon.dd
dat$veg.class <- info$veg.class
dat$aqai <- info$aqai
# natural log transform LDI vars
attach(dat)
logk <- function(x) {
mx <- min(x, na.rm=TRUE)
if(mx<0) {
x <- x + abs(mx)
mx <- 0
}
k <- min(x[x>0], na.rm=TRUE)/2
print(k)
log(x + min(x[x>0], na.rm=TRUE)/2)
}
tranvar <- logk(as.vector(dat[, c("water", "forest", "wtld.forest", "wtld.emerg", "pasture", "row.crop", "suburban", "transitional", "rock", "urban")]))
names(tranvar) <- paste0("log", names(tranvar))
head(tranvar)
dat2 <- cbind(dat, tranvar)
rm(logk, tranvar)
detach(dat)
logk
# natural log transform LDI vars
attach(dat)
logk <- function(x) {
mx <- min(x, na.rm=TRUE)
if(mx<0) {
x <- x + abs(mx)
mx <- 0
}
k <- min(x[x>0], na.rm=TRUE)/2
print(k)
log(x + min(x[x>0], na.rm=TRUE)/2)
}
tranvar <- logk(as.vector(dat[, c("water", "forest", "wtld.forest", "wtld.emerg", "pasture", "row.crop", "suburban", "transitional", "rock", "urban")]))
logk(as.vector(dat[, c("water", "forest", "wtld.forest", "wtld.emerg", "pasture", "row.crop", "suburban", "transitional", "rock", "urban")]))
search()
logk <- function(x) {
mx <- min(x, na.rm=TRUE)
if(mx<0) {
x <- x + abs(mx)
mx <- 0
}
k <- min(x[x>0], na.rm=TRUE)/2
#print(k)
list(trans=log(x + min(x[x>0], na.rm=TRUE)/2, k=k)
}
tranvar <- logk(as.vector(dat[, c("water", "forest", "wtld.forest", "wtld.emerg", "pasture", "row.crop", "suburban", "transitional", "rock", "urban")]))
logk <- function(x) {
mx <- min(x, na.rm=TRUE)
if(mx<0) {
x <- x + abs(mx)
mx <- 0
}
k <- min(x[x>0], na.rm=TRUE)/2
#print(k)
list(trans=log(x + min(x[x>0], na.rm=TRUE)/2, k=k))
}
tranvar <- logk(as.vector(dat[, c("water", "forest", "wtld.forest", "wtld.emerg", "pasture", "row.crop", "suburban", "transitional", "rock", "urban")]))
as.vector(dat[, c("water", "forest", "wtld.forest", "wtld.emerg", "pasture", "row.crop", "suburban", "transitional", "rock", "urban")])
logk <- function(x) {
mx <- min(x, na.rm=TRUE)
if(mx<0) {
x <- x + abs(mx)
mx <- 0
}
k <- min(x[x>0], na.rm=TRUE)/2
print(k)
log(x + min(x[x>0], na.rm=TRUE)/2)
}
tranvar <- logk(as.vector(dat[, c("water", "forest", "wtld.forest", "wtld.emerg", "pasture", "row.crop", "suburban", "transitional", "rock", "urban")]))
names(tranvar) <- paste0("log", names(tranvar))
head(tranvar)
dat2 <- cbind(dat, tranvar)
dim(tranvar)
tranvar
round(tranvar)
head(round(tranvar))
search()
rm(logk, tranvar)
detach(dat)
responses <- c("x.ssp", "x.sen", "x.tol", "aqai")
respnames <- c("No. Pond-Breeding Sal. Species", "% Sensitive Species", "% Tolerant Species", "AQAI")
# don't use metric5, logtransitional, metric1, nor logrock
indeps <- c("metric2", "metric3", "metric4", "metric6", "vibi.score", 
"logwater", "logforest", "logwtld.forest", "logwtld.emerg", "logpasture", "logrow.crop", "logsuburban", "logurban")
indnames <- c("ORAM~metric~2", "ORAM~metric~3", "ORAM~metric~4", "ORAM~metric~6", "OVIBI", 
"LDI[water]", "LDI[forest]", "LDI[wetland~forest]", "LDI[wetland~emergent]", "LDI[pasture]", "LDI[crop]", "LDI[suburban]", "LDI[urban]")
# other varz ... c("site.code", "ldi..1km.", "x.tolscore", "x.senscore")
j <- 1
attach(dat2)
ct <- t(
sapply(indeps, function(x) {
ct <- cor.test(dat2[, x], dat2[, responses[j]])
ctp <- ct$p.value
ctr <- as.vector(ct$estimate)
c(p=ctp, r=ctr)
})
)
ct
dim(ct)
round(dim(ct), 2)
round(ct, 2)
0.05/13
round(ct, 3)
search()
detach()
for(j in seq(responses)) {
attach(dat2)
ct <- t(
sapply(indeps, function(x) {
ct <- cor.test(dat2[, x], dat2[, responses[j]])
ctp <- ct$p.value
ctr <- as.vector(ct$estimate)
c(p=ctp, r=ctr)
})
)
print(ct)
title <- ifelse(ct[, "p"] < 0.05/length(indeps), paste0("bold('*'~", indnames, ")"), indnames)
windows(h=8, w=5.5)
par(mfcol=c(5, 3), mar=c(2.5, 2, 1.5, 1), oma=c(0, 2.5, 0, 0), las=1, cex=0.7)
for(i in rev(order(ct[, "r"]))) plot(dat2[, indeps[i]], dat2[, responses[j]], xlab="", ylab="", main=as.expression(parse(text=title[i])))
mtext(respnames[j], side=2, outer=TRUE, las=0, line=1)
detach(dat2)
}
for(j in seq(responses)) {
attach(dat2)
ct <- t(
sapply(indeps, function(x) {
ct <- cor.test(dat2[, x], dat2[, responses[j]])
ctp <- ct$p.value
ctr <- as.vector(ct$estimate)
c(p=ctp, r=ctr)
})
)
print(responses[j])
print(round(ct, 4))
title <- ifelse(ct[, "p"] < 0.05/length(indeps), paste0("bold('*'~", indnames, ")"), indnames)
windows(h=8, w=5.5)
par(mfcol=c(5, 3), mar=c(2.5, 2, 1.5, 1), oma=c(0, 2.5, 0, 0), las=1, cex=0.7)
for(i in rev(order(ct[, "r"]))) plot(dat2[, indeps[i]], dat2[, responses[j]], xlab="", ylab="", main=as.expression(parse(text=title[i])))
mtext(respnames[j], side=2, outer=TRUE, las=0, line=1)
detach(dat2)
}
search()
cleanup()
q()
?lm.br
utils:::menuInstallPkgs()
# SegmentedReg.r - segmented regression
segreg <- function(x, y, k=NULL) {
if(is.null(k)) {
rsscp <- function(K, X, Y) {
obj <- lm(Y ~ X + I((X>K)*(X-K)))
sum(obj$residuals^2)
}
xes <- sort(unique(x))
somexes <- xes[2:(length(xes)-1)]
k <- optimize(rsscp, interval=somexes, X=x, Y=y)[[1]]
}
z <- I((x>k)*(x-k))
class(z) <- "numeric"
fit <- lm(y ~ x + z)
newd <- data.frame(x=c(x, k), z=c(z, 0))
newd <- newd[order(newd$x), ]
p <- predict(fit, newdata=newd)
list(fit, k, pred=data.frame(x=newd$x, y=p))
}
a <- sample(1:50, 100, replace=T)
b <- ifelse(a<32, a + 3, a/4 + 27) + rnorm(100, sd=2)
sr <- segreg(a, b)
plot(a, b)
lines(sr[[3]])
abline(v=sr[[2]], lty=2)
library(lm.br)
fit <- lm.br(b ~ a)
fit
names(fit)
lines(fit, col="red")
predict(fit)
points(a, fit$fitted, pch=16, col="red")
ci(fit)
fit$ci()
dos.time(segreg(a, b))
dos.time(lm.br(b ~ a))
?dos
??dos
??system
system.time(segreg(a, b))
system.time(lm.br(b ~ a))
system.time(segreg(a, b))
system.time(lm.br(b ~ a))
system.time(segreg(a, b))
system.time(lm.br(b ~ a))
ls()
sr
names(sr)
segreg <- function(x, y, k=NULL) {
if(is.null(k)) {
rsscp <- function(K, X, Y) {
obj <- lm(Y ~ X + I((X>K)*(X-K)))
sum(obj$residuals^2)
}
xes <- sort(unique(x))
somexes <- xes[2:(length(xes)-1)]
k <- optimize(rsscp, interval=somexes, X=x, Y=y)[[1]]
}
z <- I((x>k)*(x-k))
class(z) <- "numeric"
fit <- lm(y ~ x + z)
xk <- c(x, k)
newd <- data.frame(x=xk[!duplicated(xk)], z=c(z, 0)[!duplicated(xk)])
newd <- newd[order(newd$x), ]
p <- predict(fit, newdata=newd)
list(fit=fit, k=k, pred=data.frame(x=newd$x, y=p))
}
indvar <- sample(1:50, 100, replace=T)
depvar <- ifelse(a<32, a + 3, a/4 + 27) + rnorm(100, sd=2)
sr <- segreg(indvar, depvar)
plot(indvar, depvar)
depvar <- ifelse(indvar<32, indvar + 3, indvar/4 + 27) + rnorm(100, sd=2)
sr <- segreg(indvar, depvar)
plot(indvar, depvar)
lines(sr$pred)
abline(v=sr$k, lty=2)
?cheat
library(devtools)
setwd("C:/JVA/GitHub/jvamisc")
document()
q()
