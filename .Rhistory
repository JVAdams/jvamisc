lk1 <- lk[lk$lake == streamdf$lake[1], ]
indxdf <- merge(lk1, indxdf, all=TRUE)
scaleup <- median(indxdf$PE / indxdf$indxkeep, na.rm=TRUE)
indxdf$indxpe <- scaleup*indxdf$indxkeep
# calculate the annual sums, leaving one stream out at a time (loo = leave one out) ... for jackknife-ish "error bars"
streamests <- with(streamdf, tapply(COMBmr, list(year, ls), mean))
scaleup.streams <- apply(streamests, 2, function(column) median(indxdf$PE / (indxdf$indxkeep - column), na.rm=TRUE))
scaledup.loo <- apply(streamests, 2, function(column) (indxdf$indxkeep - column) * median(indxdf$PE / (indxdf$indxkeep - column), na.rm=TRUE))
lohi <- t(apply(scaledup.loo, 1, myrange))
dimnames(lohi)[[2]] <- c("indxpe.lo", "indxpe.hi")
indxdf <- cbind(indxdf, lohi)
if(show) {
cat("\nindfit\n")
print(summary(indfit))
cat("\nstreamdf\n")
print(tail(streamdf[, c("lake", "year", "ls", "Emr", "CVmr", "Pmr", "COMBmr")]))
cat("\nscaleup\n")
print(scaleup)
cat("\nscaleup.streams\n")
print(scaleup.streams)
cat("\nindxdf\n")
print(tail(indxdf[, c("lake", "year", "PE", "n.mr", "indxraw", "indxkeep", "indxpe", "indxpe.lo", "indxpe.hi")]))
}
list(indfit=indfit, streamdf=streamdf, scaleup=scaleup, scaleup.streams=scaleup.streams, indxdf=indxdf)
}
}
# bring in lake boundary
# GLmapdata()
# bring in lake-wide spawner data
lk <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/LakePEdynamic.csv", as.is=T)
# calculate targets 
sptargyrz <- list(1994:1998, 1988:1992, 1989:1993, 1991:1995, 1999:2003)
TARGET <- data.frame(lake=1:5, spawner.target=rep(NA, 5), sptarg.lo=rep(NA, 5), sptarg.hi=rep(NA, 5))
for(i in 1:5) {
pick5 <- with(lk, PE[lake==i & is.element(year, sptargyrz[[i]])])
TARGET$spawner.target[i] <- mean(pick5)
n <- length(pick5)
ci <- qnorm(1 - 0.05/2) * sqrt(var(pick5)) / sqrt(n)
#TARGET[i, c("sptarg.lo", "sptarg.hi")] <- CI(pick5)# using t dist (estimated variance)
TARGET[i, c("sptarg.lo", "sptarg.hi")] <- mean(pick5) + c(-1, 1)*ci# using z dist (known variance)
if(i==3) TARGET[i, c("spawner.target", "sptarg.lo", "sptarg.hi")] <- 0.25*TARGET[i, c("spawner.target", "sptarg.lo", "sptarg.hi")]
}
targyrz <- apply(sapply(sptargyrz, range), 2, paste, collapse="-")
rm(pick5, sptargyrz)
# bring in stream-specific data
dat <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/StreamPEdynamicALLCOLS.csv", as.is=T)
dat$ls <- dat$lscode
# Includes Lake Erie"s Big Otter Creek (first m-r in 2013)
# Need code for Lake Ontario"s Orwell Creek, both new
index.streams <- list(
Sup = c(1, 2, 9, 29, 31, 32, 62),
Mic = c(5, 6, 15, 24, 26, 35),
Hur = c(10, 16, 27, 32, 999),
Eri = c(1, 2, 3, 7, 9),
Ont = c(5, 9, 22, 23, NA)
)
index.streams <- lapply(1:5, function(i) i + index.streams[[i]]/1000)
# estimate adult index of abundance for each lake using index streams
indices <- lapply(index.streams, index.est, dat, lk)
# create a Word document with results
doc <- startrtf(file="2014-10 SLCB Index", dir="C:/JVA/Lamprey/Adults/AdultIndex/2014")
heading("Index of Adult Sea Lamprey Abundance in each Great Lake")
heading(paste("Adams, Barber, Bravener, Steeves -", as.character(Sys.Date())), htype=2)
### Spawner model time series
para("We created an index of adult sea lamprey abundance for each Great Lake.",
"  We selected index streams based on their trapping history.",
"  If there was no mark-recapture estimate for a given stream in a given year,",
" it was estimated from the mean stream PE and the mean annual pattern,",
" weighting by the inverse CV2 so that the more precise estimates had greater influence on the relation,")
para("ln(mark-recap for stream i and year j) = stream effect i + year effect j.")
para("The index was then calculated as the sum of the estimates from the index streams.",
"  No index was calculated in years with fewer than two mark-recapture estimates.",
"  A conversion factor was calculated as the median of the ratio of the lake-wide PE from the spawner model (Mullett et al. 2003) to the index.",
"  This conversion factor was then multiplied by the index to put the index on the same scale as the historic lake-wide PEs.",
"  Error bars were derived from the range of values calculated when, one at a time, each stream was removed from the index.")
names(indices[[1]])
# [1] "indfit"          "streamdf"        "scaleup"         "scaleup.streams"
# [5] "indxdf"  
# position of text for selected streams in each lake (for map drawing)
posp <- list(c(3, 1, 3, 1, 1, 3, 1),
c(2, 2, 2, 2, 2, 2),
c(4, 4, 4, 4, 4),
c(2, 2, 2, 2, 2),
c(2, 2, 2, 2, 2))
for(i in 1:5) {
mymap <- mapL[[i]]
mystreamdf <- indices[[i]]$streamdf
myindxdf <- indices[[i]]$indxdf
### map of selected streams
fig <- function() {
map(xlim=range(mymap$x, na.rm=T), ylim=range(mymap$y, na.rm=T), col=NA, mar=rep(1, 4))
lines(mymap$x, mymap$y, col="darkgray", lwd=0.5)
with(mystreamdf[mystreamdf$year==2010, ], {
points(long, lat, cex=1.5, pch=16)
par(xpd=NA)
text(long, lat, strname, cex=1.2, pos=posp[[i]], font=2)
})
}
figu("Lake ", Lakenames[i], " streams selected to create the index of adult sea lamprey abundance.", h=c(3.5, 6.5, 6.5, 3.5, 3.5)[i])
### colored table of mark-recap estimates of selected streams
m <- with(mystreamdf, tapply(Emr, list(year, substring(strname, 1, 10)), mean))
m <- m[, rev(order(apply(m, 2, median, na.rm=TRUE)))]
fig <- function() {
plot.table(format(round(m), big.mark=","), highlight=TRUE)
}
figu("Lake ", Lakenames[i], " mark-recapture estimates from streams selected for the index of adult sea lampreys.")
### time series of PEs
fig <- function() {
par(mar=c(4, 4, 1, 1), cex=1.5, yaxs="i")
with(myindxdf, {
just <- year >= min(year[!is.na(indxpe)])
yr <- 1.05*range(0, PE[just], indxpe.hi[just], na.rm=TRUE)/1000
plot(1, 1, xlim=range(year), ylim=yr, type="n", xlab="Year", ylab="PE  (thousands)", las=1)
arrows(year, indxpe.lo/1000, year, indxpe.hi/1000, length=0, angle=90, code=3, lwd=10, lend="square", col="#ffddc1")
lines(year, PE/1000, lwd=1, col=blindcolz[3], type="o", pch=18)
abline(h=TARGET$spawner.target[i]/1000, col=blindcolz[3])
abline(h=TARGET[i, c("sptarg.lo", "sptarg.hi")]/1000, col=blindcolz[3], lty=2)
lines(year, indxpe/1000, lwd=2, col=blindcolz[7], type="o", pch=17)
})
legend(c("topright", "topleft", "topright", "topleft", "top")[i], c("Spawner model", "Index"), 
col=blindcolz[c(3, 7)], lwd=1:2, pch=c(18, 17), cex=0.8)
}
figu("Patterns over time in adult sea lampreys in Lake ", Lakenames[i], " including both the Mullett et al. (2003) estimate and the newly derived index.", 
h=3.5)
}
endrtf()
# C:\JVA\Lamprey\Adults\AdultIndex\2014\2014AdultIndex v1.r
{ # functions
# the following seven plot.table related function are from the Systmatic Investor Toolbox
# load Systematic Investor Toolbox
# require(RCurl)
# sit = getURLContent("https://github.com/systematicinvestor/SIT/raw/master/sit.gz", binary=TRUE, followlocation=TRUE, ssl.verifypeer=FALSE)
# con = gzcon(rawConnection(sit, "rb"))
# source(con)
# close(con)
draw.cell <- function(title, r, c, text.cex = 1, bg.col = 'white', frame.cell = T) {
if(!frame.cell) bcol = bg.col else bcol = 'black'
rect((2*(c - 1) + .5), -(r - .5), (2*c + .5), -(r + .5), col = bg.col, border = bcol)
if( c == 1) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else if( r == 1 ) {
text((2*(c - 1) + .5), -r, title, adj = 0, cex = text.cex)
} else {
text((2*c + .5), -r, title, adj = 1, cex = text.cex)
}
}
plot.table.helper.auto.adjust.cex <- function(temp.table, keep.all.same.cex = FALSE) {
nr = nrow(temp.table)
nc = ncol(temp.table)
all.xrange = diff(par()$usr[1:2]) / nc
xrange = matrix( strwidth(paste('  ', temp.table), units = 'user', cex = 1), nc = nc)
all.yrange = diff(par()$usr[3:4]) / nr
yrange = matrix( 5/3 * strheight(temp.table, units = 'user', cex = 1), nc = nc)
plot.matrix.cex = pmin( round(all.yrange / yrange, 2) , round(all.xrange / xrange, 2) )
header.col.cex = min(plot.matrix.cex[1,-1])
header.row.cex = min(plot.matrix.cex[-1,1])
title.cex = plot.matrix.cex[1, 1]
data.cex = min(plot.matrix.cex[-1, -1])
if ( keep.all.same.cex ) {
plot.matrix.cex[] = min(plot.matrix.cex)
} else {
plot.matrix.cex[1,-1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,1] = min(c(header.col.cex, header.row.cex))
plot.matrix.cex[-1,-1]= min(c(header.col.cex, header.row.cex, data.cex))
plot.matrix.cex[1,1]= min(c(header.col.cex, header.row.cex, data.cex, title.cex))
plot.matrix.cex[1,-1] = min(c(header.col.cex))
plot.matrix.cex[-1,1] = min(c(header.row.cex))
plot.matrix.cex[-1,-1]= min(c(data.cex))
plot.matrix.cex[1,1]= min(c(title.cex))
}
return(plot.matrix.cex)
}
make.table <- function(nr, nc) {
savepar = par(mar = rep(1, 4))
plot(c(0.5, nc*2 + 0.5), c(-0.5, -(nr + 0.5)), xaxs = 'i', yaxs = 'i',
type = 'n', xlab = '', ylab = '', axes = FALSE)
savepar
}
trim <- function(s) {
s = sub(pattern = '^ +', replacement = '', x = s)
s = sub(pattern = ' +$', replacement = '', x = s)
return(s)
}
plot.table.param <- function(plot.matrix, smain = '', plot.matrix.cex, plot.matrix_bg.col, frame.cell = T, keep.all.same.cex = FALSE) {
n = nrow(plot.matrix)
pages = unique(c(seq(0, n, by = 120), n))
for(p in 1:(length(pages)-1)) {
rindex = (pages[p]+1) : pages[p+1]
temp.table = matrix('', nr = length(rindex)+1, nc = ncol(plot.matrix)+1)
temp.table[-1, -1] = plot.matrix[rindex,]
temp.table[1, -1] = colnames(plot.matrix)
temp.table[-1, 1] = rownames(plot.matrix)[rindex]
temp.table[1, 1] = smain
nr = nrow(temp.table)
nc = ncol(temp.table)
par(mar = c(0, 0, 0, 0), cex = 0.5)
oldpar = make.table(nr, nc)
text.cex = plot.matrix.cex[c(1, 1 + rindex), ]
text.cex = plot.table.helper.auto.adjust.cex(temp.table, keep.all.same.cex)
bg.col = plot.matrix_bg.col[c(1, 1 + rindex), ]
for(r in 1:nr) {
for(c in 1:nc) {
draw.cell( paste('', temp.table[r,c], '', sep=' '), r, c,
text.cex = text.cex[r,c], bg.col = bg.col[r,c], frame.cell = frame.cell)
}}
}
}
plot.table <- function(plot.matrix, smain="", text.cex=1, frame.cell=TRUE, highlight=FALSE, colorbar=FALSE, keep_all.same.cex=FALSE) {
if( is.null(rownames(plot.matrix)) & is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
if( ncol(temp.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[-1, -1, drop = FALSE]
colnames(plot.matrix) = temp.matrix[1, -1]
rownames(plot.matrix) = temp.matrix[-1, 1]
smain = temp.matrix[1, 1]
} else if( is.null(rownames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( ncol(plot.matrix) == 1 ) temp.matrix = cbind("", temp.matrix)
plot.matrix = temp.matrix[, -1, drop = FALSE]
colnames(plot.matrix) = colnames(temp.matrix)[-1]
rownames(plot.matrix) = temp.matrix[,1]
smain = colnames(temp.matrix)[1]
} else if( is.null(colnames(plot.matrix)) ) {
temp.matrix = plot.matrix
if( nrow(temp.matrix) == 1 ) temp.matrix = rbind("", temp.matrix)
plot.matrix = temp.matrix[-1, , drop = FALSE]
rownames(plot.matrix) = rownames(temp.matrix)[-1]
colnames(plot.matrix) = temp.matrix[1, ]
smain = rownames(temp.matrix)[1]
}
plot.matrix[which(trim(plot.matrix) == "NA")] = ""
plot.matrix[which(trim(plot.matrix) == "NA%")] = ""
plot.matrix[which(is.na(plot.matrix))] = ""
nr = nrow(plot.matrix) + 1
nc = ncol(plot.matrix) + 1
is_highlight = TRUE
if(is.logical(highlight)) {
is_highlight = highlight
if(highlight) highlight = plot.table.helper.color(plot.matrix)
}
if(!is_highlight) {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[seq(1, nr, 2), ] = "yellow"
plot.matrix_bg.col[1,] = "gray";
plot.table.param( plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
} else {
plot.matrix.cex = matrix(1, nr = nr, nc = nc )
plot.matrix_bg.col = matrix("white", nr = nr, nc = nc )
plot.matrix_bg.col[1,] = "gray"
plot.matrix_bg.col[2:nr,2:nc] = highlight
plot.table.param(plot.matrix, smain, plot.matrix.cex, plot.matrix_bg.col,
frame.cell, keep_all.same.cex)
}
}
plot.table.helper.color <- function(temp) {
temp = matrix(as.double(gsub("[%,$]", "", temp)), nrow(temp), ncol(temp))
highlight = as.vector(temp)
cols = rep(NA, length(highlight))
ncols = length(highlight[!is.na(highlight)])
cols[1:ncols] = rev(rainbow(ncols, start=1/6, end=4/6))
o = sort.list(highlight, na.last = TRUE, decreasing = FALSE)
o1 = sort.list(o, na.last = TRUE, decreasing = FALSE)
highlight = matrix(cols[o1], nrow = nrow(temp))
highlight[is.na(temp)] = NA
return(highlight)
}
ModelEst <- function(fit, df) {
# derive regression estimates from log(y) fit
mse <- rev(as.matrix(summary(fit)[[1]])[, "Mean Sq"])[1]
plpe <- predict(fit, newdata=df, se.fit=T)
m <- plpe$fit
v <- plpe$se.fit^2 + mse
exp(m + v/2)
}
myrange <- function(x) {
if(all(is.na(x))) r <- c(NA, NA) else r <- range(x, na.rm=TRUE)
return(r)
}
index.est <- function(selstreams, allstreamdf, alllakedf, min.nmr=2, show=FALSE) {
# INDEX OF ADULT SEA LAMPREY ABUNDANCE
### INPUTS
# selstreams = vector of stream ids, e.g., 1.064 (lake + strcode/1000)
# allstreamdf = data frame of mark-recap estimates for all streams, with vars:  year lake ls Emr CVmr
# alllakedf = data frame of lake-wide PEs from Mullett et al. (2003) spawner model with vars:  lake year PE
# min.nmr = minimum number of mark-recapture estimates needed in a year to generate an index, default 2
# show = print out a brief summary of the results, default FALSE
### OUTPUTS
# indfit = simple model used to predict missing mark-recap estimates
# streamdf = original allstreamdf, subsetted by selstreams, with estimates for missing mark-recaps
# scaleup = conversion factor used to scale up annual index to spawner model PE
# indxdf = original alllakedf, subsetted by lake, with annual index, including raw (indxraw), kept based on min.nmr (indxkeep), and scaled up (indxpe)
streamdf <- allstreamdf[allstreamdf$ls %in% selstreams, ]
# error checks
check1 <- var(streamdf$lake)
if(is.na(check1) | is.null(check1)) stop("Either no streams selected or critical data missing.") else if(check1 > 0) stop("Selected streams should be only from ONE lake.")
if(any(is.na(match(c("year", "lake", "ls", "Emr", "CVmr"), names(allstreamdf))))) stop("allstreamdf must include these variables: year lake ls Emr CVmr.")
if(any(is.na(match(c("year", "lake", "PE"), names(alllakedf))))) stop("alllakedf must include these variables: lake year PE.")
# fill in missing mark-recap data
indfit <- aov(log(Emr) ~ as.factor(ls) + as.factor(year), data=streamdf, weights=1/CVmr^2)
# figure out estimable years (those with at least 1 m-r estimate)
n.mr <- tapply(!is.na(streamdf$Emr), streamdf$year, sum)
eyrs <- as.numeric(names(n.mr)[n.mr > 0.5])
estimable <- streamdf$year %in% eyrs
streamdf$Pmr <- NA
streamdf$Pmr[estimable] <- ModelEst(fit=indfit, df=streamdf[estimable, ])
streamdf$COMBmr <- ifelse(is.na(streamdf$Emr), streamdf$Pmr, streamdf$Emr)
# annual index (sum across streams)
indxdf <- aggregate(COMBmr ~ year + lake, streamdf, sum, na.rm=TRUE, na.action=na.pass)
names(indxdf)[names(indxdf)=="COMBmr"] <- "indxraw"
indxdf$indxraw[indxdf$indxraw==0] <- NA
# only keep lake-wide index for years with at least min.nmr mark-recap estimates
indxdf$n.mr <- n.mr
indxdf$indxkeep <- ifelse(indxdf$n.mr > (min.nmr - 0.5), indxdf$indxraw, NA)
# scale up the index to the spawner model PE
lk1 <- lk[lk$lake == streamdf$lake[1], ]
indxdf <- merge(lk1, indxdf, all=TRUE)
scaleup <- median(indxdf$PE / indxdf$indxkeep, na.rm=TRUE)
indxdf$indxpe <- scaleup*indxdf$indxkeep
# calculate the annual sums, leaving one stream out at a time (loo = leave one out) ... for jackknife-ish "error bars"
streamests <- with(streamdf, tapply(COMBmr, list(year, ls), mean))
scaleup.streams <- apply(streamests, 2, function(column) median(indxdf$PE / (indxdf$indxkeep - column), na.rm=TRUE))
scaledup.loo <- apply(streamests, 2, function(column) (indxdf$indxkeep - column) * median(indxdf$PE / (indxdf$indxkeep - column), na.rm=TRUE))
lohi <- t(apply(scaledup.loo, 1, myrange))
dimnames(lohi)[[2]] <- c("indxpe.lo", "indxpe.hi")
indxdf <- cbind(indxdf, lohi)
if(show) {
cat("\nindfit\n")
print(summary(indfit))
cat("\nstreamdf\n")
print(tail(streamdf[, c("lake", "year", "ls", "Emr", "CVmr", "Pmr", "COMBmr")]))
cat("\nscaleup\n")
print(scaleup)
cat("\nscaleup.streams\n")
print(scaleup.streams)
cat("\nindxdf\n")
print(tail(indxdf[, c("lake", "year", "PE", "n.mr", "indxraw", "indxkeep", "indxpe", "indxpe.lo", "indxpe.hi")]))
}
list(indfit=indfit, streamdf=streamdf, scaleup=scaleup, scaleup.streams=scaleup.streams, indxdf=indxdf)
}
}
# bring in lake boundary
# GLmapdata()
# bring in lake-wide spawner data
lk <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/LakePEdynamic.csv", as.is=T)
# calculate targets 
sptargyrz <- list(1994:1998, 1988:1992, 1989:1993, 1991:1995, 1999:2003)
TARGET <- data.frame(lake=1:5, spawner.target=rep(NA, 5), sptarg.lo=rep(NA, 5), sptarg.hi=rep(NA, 5))
for(i in 1:5) {
pick5 <- with(lk, PE[lake==i & is.element(year, sptargyrz[[i]])])
TARGET$spawner.target[i] <- mean(pick5)
n <- length(pick5)
ci <- qnorm(1 - 0.05/2) * sqrt(var(pick5)) / sqrt(n)
#TARGET[i, c("sptarg.lo", "sptarg.hi")] <- CI(pick5)# using t dist (estimated variance)
TARGET[i, c("sptarg.lo", "sptarg.hi")] <- mean(pick5) + c(-1, 1)*ci# using z dist (known variance)
if(i==3) TARGET[i, c("spawner.target", "sptarg.lo", "sptarg.hi")] <- 0.25*TARGET[i, c("spawner.target", "sptarg.lo", "sptarg.hi")]
}
targyrz <- apply(sapply(sptargyrz, range), 2, paste, collapse="-")
rm(pick5, sptargyrz)
# bring in stream-specific data
dat <- read.csv("C:/JVA/Lamprey/Adults/SpawnDisModel/2014/StreamPEdynamicALLCOLS.csv", as.is=T)
dat$ls <- dat$lscode
# Includes Lake Erie"s Big Otter Creek (first m-r in 2013)
# Need code for Lake Ontario"s Orwell Creek, both new
index.streams <- list(
Sup = c(1, 2, 9, 29, 31, 32, 62),
Mic = c(5, 6, 15, 24, 26, 35),
Hur = c(10, 16, 27, 32, 999),
Eri = c(1, 2, 3, 7, 9),
Ont = c(5, 9, 22, 23, NA)
)
index.streams <- lapply(1:5, function(i) i + index.streams[[i]]/1000)
# estimate adult index of abundance for each lake using index streams
indices <- lapply(index.streams, index.est, dat, lk)
# create a Word document with results
doc <- startrtf(file="2014-10 SLCB Index", dir="C:/JVA/Lamprey/Adults/AdultIndex/2014")
heading("Index of Adult Sea Lamprey Abundance in each Great Lake")
heading(paste("Adams, Barber, Bravener, Steeves -", as.character(Sys.Date())), htype=2)
### Spawner model time series
para("We created an index of adult sea lamprey abundance for each Great Lake.",
"  We selected index streams based on their trapping history.",
"  If there was no mark-recapture estimate for a given stream in a given year,",
" it was estimated from the mean stream PE and the mean annual pattern,",
" weighting by the inverse CV2 so that the more precise estimates had greater influence on the relation,")
para("ln(mark-recap for stream i and year j) = stream effect i + year effect j.")
para("The index was then calculated as the sum of the estimates from the index streams.",
"  No index was calculated in years with fewer than two mark-recapture estimates.",
"  A conversion factor was calculated as the median of the ratio of the lake-wide PE from the spawner model (Mullett et al. 2003) to the index.",
"  This conversion factor was then multiplied by the index to put the index on the same scale as the historic lake-wide PEs.",
"  Error bars were derived from the range of values calculated when, one at a time, each stream was removed from the index.")
names(indices[[1]])
# [1] "indfit"          "streamdf"        "scaleup"         "scaleup.streams"
# [5] "indxdf"  
# position of text for selected streams in each lake (for map drawing)
posp <- list(c(3, 1, 3, 1, 1, 3, 1),
c(2, 2, 2, 2, 2, 2),
c(4, 4, 4, 4, 4),
c(2, 2, 2, 2, 2),
c(2, 2, 2, 2, 2))
for(i in 1:5) {
mymap <- mapL[[i]]
mystreamdf <- indices[[i]]$streamdf
myindxdf <- indices[[i]]$indxdf
### map of selected streams
fig <- function() {
map(xlim=range(mymap$x, na.rm=T), ylim=range(mymap$y, na.rm=T), col=NA, mar=rep(1, 4))
lines(mymap$x, mymap$y, col="darkgray", lwd=0.5)
with(mystreamdf[mystreamdf$year==2010, ], {
points(long, lat, cex=1.5, pch=16)
par(xpd=NA)
text(long, lat, strname, cex=1.2, pos=posp[[i]], font=2)
})
}
figu("Lake ", Lakenames[i], " streams selected to create the index of adult sea lamprey abundance.", h=c(3.5, 6.5, 6.5, 3.5, 3.5)[i])
### colored table of mark-recap estimates of selected streams
m <- with(mystreamdf, tapply(Emr, list(year, substring(strname, 1, 10)), mean))
m <- m[, rev(order(apply(m, 2, median, na.rm=TRUE)))]
fig <- function() {
plot.table(format(round(m), big.mark=","), highlight=TRUE)
}
figu("Lake ", Lakenames[i], " mark-recapture estimates from streams selected for the index of adult sea lampreys.")
### time series of PEs
fig <- function() {
par(mar=c(4, 4, 1, 1), cex=1.5, yaxs="i")
with(myindxdf, {
just <- year >= min(year[!is.na(indxpe)])
yr <- 1.05*range(0, PE[just], indxpe.hi[just], na.rm=TRUE)/1000
plot(1, 1, xlim=range(year), ylim=yr, type="n", xlab="Year", ylab="PE  (thousands)", las=1)
arrows(year, indxpe.lo/1000, year, indxpe.hi/1000, length=0, angle=90, code=3, lwd=10, lend="square", col="#ffddc1")
lines(year, PE/1000, lwd=1, col=blindcolz[3], type="o", pch=18)
abline(h=TARGET$spawner.target[i]/1000, col=blindcolz[3])
abline(h=TARGET[i, c("sptarg.lo", "sptarg.hi")]/1000, col=blindcolz[3], lty=2)
lines(year, indxpe/1000, lwd=2, col=blindcolz[7], type="o", pch=17)
})
legend(c("topright", "topleft", "topright", "topleft", "top")[i], c("Spawner model", "Index"), 
col=blindcolz[c(3, 7)], lwd=1:2, pch=c(18, 17), cex=0.8)
}
figu("Patterns over time in adult sea lampreys in Lake ", Lakenames[i], " including both the Mullett et al. (2003) estimate and the newly derived index.", 
h=3.5)
}
endrtf()
cleanup()
search()
# C:\JVA\Lamprey\Adults\SpawnDisModel\2014\Inputs v2014.r - inputs and source command to run Spawner Model (Mullett et al. 2013)
# spawner populations estimates generated dynamically every year (i.e., all estimates change every year)
# study years for selected Superior streams included in specified years
# mse + hat matrix is used for error propagation
#################################################################################################################
#########   Each year, the YEAR must be updated,                                                         ########
#########   Make changes as needed to the directory and input file names.                                ########
#################################################################################################################
#########                                       I N P U T S                                              ########
#################################################################################################################
YEAR        <- 2014
#DIRECTORY  <- "C:\\Documents and Settings\\jbarber\\My Documents\\Jessica Files\\Spawner Model Files\\2014 files"
#DIRECTORY   <- "C:\\Documents and Settings\\jbarber\\My Documents\\Jessica Files\\Spawner Model Files\\2014 files"
DIRECTORY   <- "C:\\JVA\\Lamprey\\Adults\\SpawnDisModel\\2014"
OLDDATA     <- "Trap&Schaefer 1977-2013.csv"
NEWDATA     <- "Trap&Schaefer 2014.csv"
TRAPPER     <- "Trapping Periods 2014.csv"
PROGRAM     <- "DynamicPECV ver2014-09-19.r"
FUNCTIONS   <- "Functions v2013.r"
LAKEMAP     <- "GreatLakes.dat"
#################################################################################################################
#########                                R U N   T H E   P R O G R A M                                   ########
#################################################################################################################
source(paste(DIRECTORY, FUNCTIONS, sep="\\"))
source(paste(DIRECTORY, PROGRAM, sep="\\"))
cleanup()
q()
# C:\JVA\Lamprey\Adults\SpawnDisModel\2014\Inputs v2014.r - inputs and source command to run Spawner Model (Mullett et al. 2013)
# spawner populations estimates generated dynamically every year (i.e., all estimates change every year)
# study years for selected Superior streams included in specified years
# mse + hat matrix is used for error propagation
#################################################################################################################
#########   Each year, the YEAR must be updated,                                                         ########
#########   Make changes as needed to the directory and input file names.                                ########
#################################################################################################################
#########                                       I N P U T S                                              ########
#################################################################################################################
YEAR        <- 2014
#DIRECTORY  <- "C:\\Documents and Settings\\jbarber\\My Documents\\Jessica Files\\Spawner Model Files\\2014 files"
#DIRECTORY   <- "C:\\Documents and Settings\\jbarber\\My Documents\\Jessica Files\\Spawner Model Files\\2014 files"
DIRECTORY   <- "C:\\JVA\\Lamprey\\Adults\\SpawnDisModel\\2014"
OLDDATA     <- "Trap&Schaefer 1977-2013.csv"
NEWDATA     <- "Trap&Schaefer 2014.csv"
TRAPPER     <- "Trapping Periods 2014.csv"
PROGRAM     <- "DynamicPECV ver2014-09-19.r"
FUNCTIONS   <- "Functions v2013.r"
LAKEMAP     <- "GreatLakes.dat"
#################################################################################################################
#########                                R U N   T H E   P R O G R A M                                   ########
#################################################################################################################
source(paste(DIRECTORY, FUNCTIONS, sep="\\"))
source(paste(DIRECTORY, PROGRAM, sep="\\"))
q()
library(devtools)
library(roxygen2)
setwd("C:/JVA/GitHub")
install("jvamisc")
setwd("C:/JVA/R/Working Directory")
library(jvamisc)
?figu
?figu
?cheat()
?cheat
library(devtools)
setwd("C:/JVA/GitHub/jvamisc")
document()
q()
